string[] watertiles = {"shallow", "water", "spring", "snow", "ice"};
enum TILETYPE
{
TILE_NONE, TILE_TILE, TILE_WALL
}
enum gatemodes
{
GATE_NONE, GATE_OPEN, GATE_OPENING, GATE_CLOSE, GATE_CLOSING
}
mapdata@[] maps(0);
mapdata@[] public_maps(0);
dictionary map_list;
string default_leave_sound = "unspawn";
string default_enter_sound = "move";

class mapdata
{
bool remove = false;
string name;
string owner_rd;
dictionary owner;
timer playerstimer;
int loadtime = 0;
string rawdata;
vector min, max, starting;
mapispawn[] mapispawns;
maprspawn[] maprspawns;
maptile[] maptiles, mapgates;
maptravel@[] maptravels;
mapdoor@[] mapdoors;
mapzone@[] mapzones;
bool event_on = false;
bool is_vehicle = false;
vehicle@ vhc;
int fighting = 1;
int no_teamhit = 0;
int public = 1;
int no_coord = 0;
int no_chat = 0;
int no_teleport = 0, no_recall = 0;
ctf@[] ctf_sdest, ctf_rdest;
uint ctf_slife = 0, ctf_rlife = 0;
bool ctf_run = false;
mapnoitem[] mapnoitems;
string enter_sound = default_enter_sound;
string leave_sound = default_leave_sound;
string move_start_sound = default_leave_sound;
string move_end_sound = default_enter_sound;
string limit;
double pan_step = 1;
int respawn_mode = 1, respawn_z = 0;
int no_tracking = 0;
int no_seethrough = 0;
int no_corpse = 0;
int tunnel_sight = 0;
int survival = 0;
int boundary_volume = 50;
timer spawntimer;
dictionary starting_items;
int active_vehicles = 0;
int active_pv = 0;
dictionary lastman_standing;

void internal_load(const string& in loadname, bool is_file = true, bool init = true)
{
timer loadtimer;
if (init)
{
name.resize(0);
owner.delete_all();
owner_rd.resize(0);
move_start_sound = default_leave_sound;
move_end_sound = default_enter_sound;
leave_sound = default_leave_sound;
enter_sound = default_enter_sound;
min.z = 0;
max.x = 0; max.y = 0; max.z = 0;
starting.x = 0; starting.y = 0; starting.z = 0;
respawn_z = 0;
respawn_mode = 1;
pan_step = 1;
maprspawns.resize(0);
mapispawns.resize(0);
mapnoitems.resize(0);
maptiles.resize(0);
mapgates.resize(0);
maptravels.resize(0);
mapdoors.resize(0);
mapzones.resize(0);
ctf_sdest.resize(0);
ctf_rdest.resize(0);
fighting = 1;
no_teamhit = 0;
public = 1;
no_coord = 0;
no_tracking = 0;
no_seethrough = 0;
no_chat = 0;
no_teleport = 0;
no_recall = 0;
no_seethrough = 0;
no_corpse = 0;
tunnel_sight = 0;
survival = 0;
boundary_volume = 50;
limit.resize(0);
starting_items.delete_all();
vending_machines.resize(0);
}
if (is_file)
{
fl.open("./maps/" + loadname + ".map", "rb");
rawdata = fl.read();
fl.close();
} // if.is_file.
else rawdata = loadname;
string[]@ map = string_split(rawdata, "\r\n", true);
int maplength = map.length;
for (uint i = 0; i < maplength; i++)
{
string[]@ parsed = string_split(map[i], ":", false);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed, this, false);
}
if (!name.is_empty() and !is_file and !is_vehicle)
{
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}
this.loadtime = loadtimer.elapsed;
} // method.

void add_rawdata(const string& in new_rawdata)
{
rawdata += new_rawdata;
fl.open("./maps/" + this.name + ".map", "ab");
fl.write(new_rawdata);
fl.close();
string[]@ map = string_split(new_rawdata, "\r\n", true);
int maplength = map.length;
for (uint i = 0; i < maplength; i++)
{
string[]@ parsed = string_split(map[i], ":", false);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed, this, true);
}
sendmap("m_data_add " + new_rawdata, this, 0);
int vslength = this.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = this.vs[i];
if (temp.inside is null) continue;
sendmap("vdata_add " + new_rawdata, temp.inside, 0);
}
}

// map objects
bomb_cracker@[] bomb_crackers;
canister@[] canisters;
carrier_missile@[] carrier_missiles;
concussive_grenade@[] concussive_grenades;
impact_bomb@[] impact_bombs;
mine@[] mines;
dictionary mine_locs;
missile@[] missiles;
motion_bomb@[] motion_bombs;
nuclear_bomb@[] nuclear_bombs;
remgun@[] remguns;
remote_timebomb@[] remote_timebombs;
security_bomb@[] security_bombs;
sound_grenade@[] sound_grenades;
stun_grenade@[] stun_grenades;
smoke_grenade@[] smoke_grenades;
timebomb@[] timebombs;
ultrabomb@[] ultrabombs;
wirebomb@[] wirebombs;
corpse@[] corpses;
fire@[] fires;
hittable@[] hobjs;
msound@[] msounds;
obj@[] objs;
player@[] players;
onlinequiz@[] quiz;
Robot@[] robots;
shipment@[] shipments;
amb@[] ambs;
splash@[] splashs;
store_coordinate@[] store_coordinates;
vehicle@[] vs;
vending_machine[] vending_machines;
weapon@[] weapons;

void loop()
{
active_pv = this.players.length + this.active_vehicles;
if (active_pv > 0)
{
if (this.spawntimer.elapsed >= 50)
{
this.spawntimer.force(0);
int mapgateslength = this.mapgates.length;
for (uint j = 0; j < mapgateslength; j++)
{
maptile@ mg = this.mapgates[j];
switch (mg.mode)
{
case GATE_CLOSE:
{
if (mg.opentime == 0) continue;
if (mg.walkingtimer.elapsed < abs(mg.opentime)) continue;
if (mg.opentime > 0) mg.walkingtimer.force(0);
if (mg.openreadytime < 0)
{
if (mg.is_on_tile(this)) continue;
}
mg.mode = GATE_OPENING;
mg.walkingtimer.force(0);
sendmap("play_3ds " + mg.open_sound + " " + mg.oldminx + " " + mg.oldmaxx + " " + mg.oldminy + " " + mg.oldmaxy + " " + mg.oldminz + " " + mg.oldmaxz, this, 4);
}
break; case GATE_CLOSING:
{
if (mg.walkingtimer.elapsed < abs(mg.closereadytime)) continue;
mg.walkingtimer.force(0);
mg.mode = GATE_CLOSE;
mg.gate_update(this);
}
break; case GATE_OPEN:
{
if (mg.closetime == 0) continue;
if (mg.walkingtimer.elapsed < abs(mg.closetime)) continue;
if (mg.closetime > 0) mg.walkingtimer.force(0);
if (mg.closereadytime < 0)
{
if (mg.is_on_tile(this)) continue;
}
mg.mode = GATE_CLOSING;
mg.walkingtimer.force(0);
sendmap("play_3ds " + mg.close_sound + " " + mg.oldminx + " " + mg.oldmaxx + " " + mg.oldminy + " " + mg.oldmaxy + " " + mg.oldminz + " " + mg.oldmaxz, this, 4);
}
break; case GATE_OPENING:
{
if (mg.walkingtimer.elapsed < abs(mg.openreadytime)) continue;
mg.walkingtimer.force(0);
mg.mode = GATE_OPEN;
mg.gate_update(this);
}
break;
}
}
int mapispawnslength = this.mapispawns.length;
for (uint j = 0; j < mapispawnslength; j++)
{
mapispawn@ mis = this.mapispawns[j];
if (mis.limit > 0)
{
if (mis.limittimer.elapsed >= mis.limittime)
{
mis.limittimer.force(0);
if ((mis.reset_cycle ? mis.limited.size == mis.mapobjs.length : true)) mis.limited.delete_all();
}
}
if (mis.mapispawntimer.elapsed < round(mis.mapispawntime / (mis.adjustable ? active_pv : 1), 0)) continue;
mis.mapispawntimer.force(0);
if (mis.curobjs >= (mis.maxobjs * (mis.adjustable ? active_pv : 1))) continue;
spawn_rand_obj(mis.minx, mis.maxx, mis.miny, mis.maxy, mis.minz, mis.maxz, this, mis.mapobjs, mis.mapiunspawntime, mis);
}
int rlist = this.maprspawns.length;
for (uint j = 0; j < rlist; j++)
{
maprspawn@ mro = this.maprspawns[j];
if (mro.spawntimer.elapsed < round(mro.spawntime / (mro.adjustable ? active_pv : 1), 0)) continue;
mro.spawntimer.force(0);
if (mro.currobots >= (mro.maxrobots * (mro.adjustable ? active_pv : 1))) continue;
robot_spawn(mro.list[random(0, (mro.list.length - 1))], random(mro.minx, mro.maxx), random(mro.miny, mro.maxy), random(mro.minz, mro.maxz), this, mro.group, mro.tile, mro);
}
}
}
if (!this.msounds.is_empty()) msoundloop(this);
if (!this.is_vehicle)
{
this.active_vehicles = 0;
if (!this.vs.is_empty()) vloop(this);
}
if (!this.weapons.is_empty()) weaponloop(this);
if (!this.bomb_crackers.is_empty()) bomb_crackerloop(this);
if (!this.canisters.is_empty()) canisterloop(this);
if (!this.carrier_missiles.is_empty()) cmloop(this);
if (!this.concussive_grenades.is_empty()) concussive_grenadeloop(this);
if (!this.impact_bombs.is_empty()) impact_bombloop(this);
if (!this.mines.is_empty()) mineloop(this);
if (!this.missiles.is_empty()) missileloop(this);
if (!this.motion_bombs.is_empty()) motion_bombloop(this);
if (!this.nuclear_bombs.is_empty()) nuclear_bombloop(this);
if (!this.remguns.is_empty()) remgunloop(this);
if (!this.remote_timebombs.is_empty()) remote_timebombloop(this);
if (!this.security_bombs.is_empty()) sbombloop(this);
if (!this.sound_grenades.is_empty()) sound_grenadeloop(this);
if (!this.stun_grenades.is_empty()) stun_grenadeloop(this);
if (!this.smoke_grenades.is_empty()) smoke_grenadeloop(this);
if (!this.timebombs.is_empty()) timebombloop(this);
if (!this.ultrabombs.is_empty()) ultrabombloop(this);
if (!this.wirebombs.is_empty()) wirebombloop(this);
if (!this.corpses.is_empty()) corpseloop(this);
if (!this.fires.is_empty()) fireloop(this);
if (!this.hobjs.is_empty()) hobjloop(this);
if (!this.ambs.is_empty()) ambloop(this);
if (!this.objs.is_empty()) objloop(this);
if (!this.players.is_empty()) playerloop(this);
if (!this.robots.is_empty()) robotloop(this);
if (!this.shipments.is_empty()) shipmentloop(this);
if (!this.splashs.is_empty()) splashloop(this);
if (!this.vending_machines.is_empty()) vendingloop(this);
}
} // class.mapdata.

class ctf
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_ctf(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class maprspawn
{
int minx, maxx, miny, maxy, minz, maxz;
string[] list;
string tile;
uint group = 0;
timer spawntimer;
int spawntime = 0;
int currobots = 0, maxrobots = 0;
bool adjustable = false;
}

const int noitem_weapon = 1;
const int noitem_vehicle = 2;
const int noitem_snack = 4;
const int noitem_trap = 8;
const int noitem_ammo = 16;
const int noitem_explode = 32;
class mapnoitem
{
int minx, maxx, miny, maxy, minz, maxz;
dictionary items;
int flags = 0;
}

class mapdoor
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_door(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class maptravel
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_travelpoint(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class mapzone
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string text;
bool trackable = false;

bool& is_on_zone(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}

double distancecheck(double x, double y, double z)
{
double dx = abs(x - center_x) - size_x;
double dy = abs(y - center_y) - size_y;
double dz = abs(z - center_z) - size_z;
double final = 0.0;
if (dx > 0) final += (dx * dx);
if (dy > 0) final += (dy * dy);
if (dz > 0) final += (dz * dz);
return final ** 0.5;
}
}

class maptile
{
int minx, maxx, miny, maxy, minz, maxz;
int oldminx, oldmaxx, oldminy, oldmaxy, oldminz, oldmaxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string type;
bool is_wall = false;
int slidetime = 0;
int slidedir = -1;
int plus_x = 0, plus_y = 0, plus_z = 0;
string open_sound, close_sound;
int opentime = 0, closetime = 0;
int openreadytime = 0, closereadytime = 0;
timer walkingtimer;
int mode = GATE_NONE, attack_mode = 0;
bool hazard = false;
string gate_rawdata;

bool& is_on_tile(double x, double y, double z, bool staircase = false)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
if (staircase and minz == maxz) return false_t;
return true_t;
} // method.is_on_tile.

bool& is_on_tile(mapdata@ map)
{
int tminx = minx + plus_x;
int tmaxx = maxx + plus_x;
int tminy = miny + plus_y;
int tmaxy = maxy + plus_y;
int tminz = minz + plus_z;
int tmaxz = maxz + plus_z;
int playerslength = map.players.length;
for (uint x = 0; x < playerslength; x++)
{
player@ temp = map.players[x];
if (temp.health <= 0) continue;
if (temp.invinsible) continue;
if (temp.hidden) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.z < tminz) continue;
if (temp.z > tmaxz) continue;
return true_t;
}
int robotslength = map.robots.length;
for (uint r = 0; r < robotslength; r++)
{
Robot@ temp = map.robots[r];
if (temp.health <= 0) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.z < tminz) continue;
if (temp.z > tmaxz) continue;
return true_t;
}
int vslength = map.vs.length;
for (uint v = 0; v < vslength; v++)
{
vehicle@ temp = map.vs[v];
if (temp.health <= 0) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.rz < tminz) continue;
if (temp.rz > tmaxz) continue;
return true_t;
}
return false_t;
}

void gate_update(mapdata@ map)
{
string hb, hbv, hs;
switch (attack_mode)
{
case 2:
{
hb = "소거의 지뢰";
hbv = "소거의 지뢰";
hs = "minestep1";
}
break; case 1:
{
hb = "internal:trap";
hbv = "internal:trap_v";
hs = "quizno";
}
break; default:
break;
}
minx += plus_x;
maxx += plus_x;
center_x += plus_x;
miny += plus_y;
maxy += plus_y;
center_y += plus_y;
minz += plus_z;
maxz += plus_z;
center_z += plus_z;
plus_x *= -1;
plus_y *= -1;
plus_z *= -1;
int playerslength = map.players.length;
for (uint x = 0; x < playerslength; x++)
{
    player@ temp = map.players[x];
    temp.sendpacket("changetile " + gate_rawdata, 4);
    if (attack_mode == 0) continue;
    if (temp.health <= 0) continue;
    if (temp.invinsible) continue;
    if (temp.hidden) continue;
    if (temp.rx < minx) continue;
    if (temp.rx > maxx) continue;
    if (temp.ry < miny) continue;
    if (temp.ry > maxy) continue;
    if (temp.z < minz) continue;
    if (temp.z > maxz) continue;
    if (temp.rank != 5) {
        temp.death = true;
        temp.hitby = hb;
        temp.sendsound(hs);
        temp.should_subtract = true;
    }
}
int vslength = map.vs.length;
for (uint v = 0; v < vslength; v++)
{
vehicle@ temp = map.vs[v];
if (temp.inside !is null) sendmap("changevtile " + gate_rawdata, temp.inside, 4);
if (temp.health <= 0) continue;
if (temp.rx < minx) continue;
if (temp.rx > maxx) continue;
if (temp.ry < miny) continue;
if (temp.ry > maxy) continue;
if (temp.rz < minz) continue;
if (temp.rz > maxz) continue;
if (attack_mode == 0)
{
if (slidedir > -1)
{
if (temp.slidedir == -1) temp.slidetimer.force(0);
temp.ctile = type;
temp.slidetime = slidetime;
temp.slidedir = slidedir;
}
continue;
}
temp.health = -1000000000;
temp.hitby = hbv;
if (temp.inside !is null)
{
int inpl = temp.inside.players.length;
for (uint x = 0; x < inpl; x++)
{
    player@ inp = temp.inside.players[x];
    if (inp.invinsible) continue;
    if (inp.hidden) continue;
    if (inp.rank != 5) {
        inp.death = true;
        inp.hitby = hb;
        inp.sendsound(hs);
        inp.should_subtract = true;
    }
}
}
}
int robotslength = map.robots.length;
for (uint r = 0; r < robotslength; r++)
{
Robot@ temp = map.robots[r];
if (temp.health <= 0) continue;
if (temp.rx < minx) continue;
if (temp.rx > maxx) continue;
if (temp.ry < miny) continue;
if (temp.ry > maxy) continue;
if (temp.z < minz) continue;
if (temp.z > maxz) continue;
if (attack_mode == 0)
{
if (slidedir > -1)
{
if (temp.slidedir == -1) temp.slidetimer.force(0);
temp.slidetime = slidetime;
temp.slidedir = slidedir;
}
continue;
}
temp.health = -1000000000;
}
if (attack_mode > 0)
{
int hobjslength = map.hobjs.length;
for (uint i2 = 0; i2 < hobjslength; i2++)
{
hittable@ temp = map.hobjs[i2];
if (temp.health <= 0) continue;
if (temp.x < minx) continue;
if (temp.x > maxx) continue;
if (temp.y < miny) continue;
if (temp.y > maxy) continue;
if (temp.z < minz) continue;
if (temp.z > maxz) continue;
temp.health = -1000000000;
temp.hitby = hbv;
}
}
gate_rawdata = this.minx + " " + this.maxx + " " + this.miny + " " + this.maxy + " " + this.minz + " " + this.maxz + " " + this.type + " " + this.plus_x + " " + this.plus_y + " " + this.plus_z + " " + this.slidetime + " " + this.slidedir + (this.hazard ? " hazard" : empty);
}
} // class.maptile.

void press_switch(int minx, int maxx, int miny, int maxy, int minz, int maxz, mapdata@ map)
{
double center_x = (minx + maxx) * 0.5;
double size_x = abs(center_x - minx);
double center_y = (miny + maxy) * 0.5;
double size_y = abs(center_y - miny);
double center_z = (minz + maxz) * 0.5;
double size_z = abs(center_z - minz);
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (abs(temp.center_x - center_x) > (temp.size_x + size_x)) continue;
if (abs(temp.center_y - center_y) > (temp.size_y + size_y)) continue;
if (abs(temp.center_z - center_z) > (temp.size_z + size_z)) continue;
switch (temp.mode)
{
case GATE_OPEN:
{
if (temp.closereadytime < 0)
{
if (temp.is_on_tile(map)) continue;
}
temp.mode = GATE_CLOSING;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.close_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_OPENING:
{
temp.mode = GATE_CLOSE;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.close_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_CLOSE:
{
if (temp.openreadytime < 0)
{
if (temp.is_on_tile(map)) continue;
}
temp.mode = GATE_OPENING;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.open_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_CLOSING:
{
temp.mode = GATE_OPEN;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.open_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break;
}
}
}

class mapispawn
{
int minx, maxx, miny, maxy, minz, maxz;
string[] mapobjs;
timer mapispawntimer;
int mapispawntime, mapiunspawntime;
int curobjs = 0, maxobjs = 1;
int limit = 0, limittime = 0;
bool limit_all = false;
timer limittimer;
dictionary limited;
bool reset_cycle = false;
bool adjustable = false;

int get_limit(player@ temp)
{
if (!limited.exists(temp.name)) return 0;
int current = 0;
if (!limited.get(temp.name, current))
{
limited.delete(temp.name);
return 0;
}
return current;
}

int get_limit_all(const string& in name)
{
if (!limited.exists(name)) return 0;
int current = 0;
if (!limited.get(name, current))
{
limited.delete(name);
return 0;
}
return current;
}
} // class.ispawn.

class str_collision
{
double x_length = 0.0;
double y_length = 0.0;
double z_length = 0.0;
double top_z = 0.0;
double bottom_z = 0.0;
double time = -1.0;
maptile@ handle;
hittable@ handle_hit;
}

str_collision@ get_collision_handle_parabola(double x, double y, double z, mapdata@ map, double speed, double accel, double x_y_deg, double z_deg, double origin_length, int floor_z = 0, const string &in name = empty)
{
str_collision new;
int name_size = name.size;
int search_mode = 0;
if (name_size > 0)
{
search_mode = 1;
if (name == "/") search_mode = 2;
}
double rise_time = 0.0, sink_time = 0.0, real_rise_time = 0.0;
new.z_length = sine(z_deg * pi180) * speed;
new.x_length = sine(x_y_deg * pi180) * speed * cosine(z_deg * pi180);
new.y_length = cosine(x_y_deg * pi180) * speed * cosine(z_deg * pi180);
bool rise = false;
double start_time = 0.0;
double find_size = 0.0;
double rise_top_z = 0.0;
if (new.z_length > 0.0)
{
rise = true;
rise_time = new.z_length / accel;
real_rise_time = rise_time;
rise_top_z = z + (0.5 * accel * rise_time * rise_time);
if (rise_time > origin_length)
{
double distance = rise_time - origin_length;
new.top_z = rise_top_z - (0.5 * accel * distance * distance);
rise_time = origin_length;
}
else
{
new.top_z = rise_top_z;
sink_time = origin_length - rise_time;
}
new.bottom_z = new.top_z - (0.5 * accel * sink_time * sink_time);
find_size = 1 / ((rise_time > sink_time ? rise_time : sink_time) * accel);
}
else
{
start_time = abs(new.z_length / accel);
sink_time = origin_length + start_time;
new.top_z = z + 0.5 * accel * start_time * start_time;
new.bottom_z = new.top_z - (0.5 * accel * sink_time * sink_time);
find_size = 1 / (sink_time * accel);
}
double minimum_size = accel / (speed > 1 ? speed : 1);
if (find_size > minimum_size) find_size = minimum_size;
int max_z = (rise ?  round(new.top_z, 0) : round(z, 0));
int min_z = (z < new.bottom_z ? round(z, 0) : round(new.bottom_z, 0));
int real_z = round(z, 0);
double start_x = (rise ? x + (new.x_length * rise_time) : x - (new.x_length * start_time));
double start_y = (rise ? y + (new.y_length * rise_time) : y - (new.y_length * start_time));
double end_x = x + (new.x_length * origin_length);
double end_y = y + (new.y_length * origin_length);
int real_x = (x < end_x ? round(x, 0) : round(end_x, 0));
int real_y = (y < end_y ? round(y, 0) : round(end_y, 0));
int real_end_x = (x > end_x ? round(x, 0) : round(end_x, 0));
int real_end_y = (y > end_y ? round(y, 0) : round(end_y, 0));
double center_x = (real_x + real_end_x) * 0.5;
double center_y = (real_y + real_end_y) * 0.5;
double center_z = (min_z + max_z) * 0.5;
double size_x = abs(real_x - center_x);
double size_y = abs(real_y - center_y);
double size_z = abs(min_z - center_z);
maptile[]@ mg = map.mapgates, mt = map.maptiles;
int mgl = mg.length;
int mtl = mt.length;
for (int j = (mtl + mgl) -1; j > -1; j--)
{
maptile@ temp = (j >= mtl ? mg : mt)[j - (j >= mtl ? mtl : 0)];
if (search_mode == 0)
{
if (!temp.is_wall)
{
if (new.time == -1.0)
{
if (real_x >= temp.minx and real_end_x <= temp.maxx and real_y >= temp.miny and real_end_y <= temp.maxy and min_z >= temp.minz and max_z <= temp.maxz)
{
new.time = origin_length;
return new;
}
}
continue;
}
}
else if (search_mode == 1)
{
if (string_left(temp.type, name_size) != name) continue;
}
if (abs(center_x - temp.center_x) > (size_x + temp.size_x)) continue;
if (abs(center_y - temp.center_y) > (size_y + temp.size_y)) continue;
if (abs(center_z - temp.center_z) > (size_z + temp.size_z)) continue;
bool found = false;
if (rise and temp.maxz >= real_z)
{
double start_position = 0;
double end_position = new.top_z - z;
double final_position = -1;
for (; (end_position - start_position) >= find_size; )
{
double central_position = (start_position + end_position) * 0.5;
int central_z = round(z + central_position, 0);
if (temp.minz > central_z)
{
start_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
end_position = central_position;
continue;
}
double time = real_rise_time - (2 * abs(rise_top_z - (z + central_position)) / accel) ** 0.5;
int central_x = round(x + (new.x_length * time), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(y + (new.y_length * time), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
if (final_position > -1)
{
double central_z = z + final_position;
double time = real_rise_time - (2 * abs(rise_top_z - central_z) / accel) ** 0.5;
if (new.time == -1.0 or new.time > time)
{
new.time = time;
@ new.handle = temp;
found = true;
}
}
}
if (found) continue;
if (rise)
{
if (new.time >= 0.0 and new.time <= rise_time) continue;
if (real_rise_time >= origin_length) continue;
}
double start_position = (rise ? 0 : new.top_z - z);
double end_position = new.top_z - new.bottom_z;
double final_position = -1;
for (; (end_position - start_position) >= find_size; )
{
double central_position = (start_position + end_position) * 0.5;
int central_z = round(new.top_z - central_position, 0);
if (temp.minz > central_z)
{
end_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
start_position = central_position;
continue;
}
double time = (2 * abs(central_position) / accel) ** 0.5;
int central_x = round(start_x + (new.x_length * time), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(start_y + (new.y_length * time), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
if (final_position > -1)
{
double central_z = new.top_z - final_position;
double time = (2 * abs(new.top_z - central_z) / accel) ** 0.5 + (rise ? rise_time : -start_time);
if (new.time == -1.0 or new.time > time)
{
new.time = time;
@ new.handle = temp;
}
}
}
if (new.time == -1.0)
{
double length = new.top_z - floor_z;
if (length < 0)
{
new.time = -1.0;
return new;
}
double length2 = z - floor_z;
if (length2 < 0)
{
new.time = (rise ? real_rise_time - (2 * (rise_top_z - floor_z) / accel) ** 0.5 : -1.0);
return new;
}
new.time = (2 * length / accel) ** 0.5 + (rise ? rise_time : -start_time);
return new;
}
if (new.handle_hit !is null and new.handle !is null) @ new.handle_hit = null;
return new;
}

str_collision@ get_collision_handle_straight(double x, double y, double z, mapdata@ map, double origin_length, double x_y_deg, double z_deg, int floor_z = 0, bool check_hittable = true, const string &in name = empty)
{
str_collision new;
int name_size = name.size;
int search_mode = 0;
if (name_size > 0)
{
search_mode = 1;
if (name == "/") search_mode = 2;
}
new.z_length = sine(z_deg * pi180);
new.x_length = sine(x_y_deg * pi180) * cosine(z_deg * pi180);
new.y_length = cosine(x_y_deg * pi180) * cosine(z_deg * pi180);
double end_x = x + (new.x_length * origin_length);
double end_y = y + (new.y_length * origin_length);
double end_z = z + (new.z_length * origin_length);
int real_x = (x < end_x ? round(x, 0) : round(end_x, 0));
int real_y = (y < end_y ? round(y, 0) : round(end_y, 0));
int real_z = (z < end_z ? round(z, 0) : round(end_z, 0));
int real_end_x = (x > end_x ? round(x, 0) : round(end_x, 0));
int real_end_y = (y > end_y ? round(y, 0) : round(end_y, 0));
int real_end_z = (z > end_z ? round(z, 0) : round(end_z, 0));
double center_x = (real_x + real_end_x) * 0.5;
double center_y = (real_y + real_end_y) * 0.5;
double center_z = (real_z + real_end_z) * 0.5;
double size_x = abs(real_x - center_x);
double size_y = abs(real_y - center_y);
double size_z = abs(real_z - center_z);
if (check_hittable)
{
for (int i = map.hobjs.length-1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if ((search_mode == 0 ? !temp.is_wall : search_mode == 1 ? string_left(temp.tile, name_size) != name : false)) continue;
double length = (new.x_length > 0.0 ? abs(abs(temp.x - x) / new.x_length) : new.y_length > 0.0 ? abs(abs(temp.y - y) / new.y_length) : abs(abs(temp.z - z) / new.z_length));
if (temp.x != round(x + (new.x_length * length), 0)) continue;
if (temp.y != round(y + (new.y_length * length), 0)) continue;
if (temp.z != round(z + (new.z_length * length), 0)) continue;
if (round(length, 0) == 0.0)
{
new.time = 0.0;
@ new.handle_hit = temp;
return new;
}
if (new.time > -1.0 and new.time <= length) continue;
new.time = length;
@ new.handle_hit = temp;
}
}
maptile[]@ mg = map.mapgates, mt = map.maptiles;
int mgl = mg.length;
int mtl = mt.length;
for (int j = (mtl + mgl) -1; j > -1; j--)
{
maptile@ temp = (j >= mtl ? mg : mt)[j - (j >= mtl ? mtl : 0)];
if (search_mode == 0)
{
if (!temp.is_wall)
{
if (new.time == -1.0)
{
if (real_x >= temp.minx and real_end_x <= temp.maxx and real_y >= temp.miny and real_end_y <= temp.maxy and real_z >= temp.minz and real_end_z <= temp.maxz)
{
new.time = origin_length;
return new;
}
}
continue;
}
}
else if (search_mode == 1)
{
if (string_left(temp.type, name_size) != name) continue;
}
if (abs(center_x - temp.center_x) > (size_x + temp.size_x)) continue;
if (abs(center_y - temp.center_y) > (size_y + temp.size_y)) continue;
if (abs(center_z - temp.center_z) > (size_z + temp.size_z)) continue;
int start_position = 0;
int end_position = origin_length;
int final_position = -1;
for (; (end_position - start_position) > 1; )
{
int central_position = (start_position + end_position) >> 1;
int central_x = round(x + (new.x_length * central_position), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(y + (new.y_length * central_position), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_z = round(z + (new.z_length * central_position), 0);
if (temp.minz > central_z)
{
new.z_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
new.z_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
for (uint i = end_position; i >= start_position; i--)
{
int central_x = round(x + (new.x_length * i), 0);
if (temp.minx > central_x) continue;
if (temp.maxx < central_x) continue;
int central_y = round(y + (new.y_length * i), 0);
if (temp.miny > central_y) continue;
if (temp.maxy < central_y) continue;
int central_z = round(z + (new.z_length * i), 0);
if (temp.minz > central_z) continue;
if (temp.maxz < central_z) continue;
if (final_position == -1 or final_position > i) final_position = i;
}
if (final_position < 0) continue;
if (final_position == 0)
{
new.time = 0.0;
@ new.handle_hit = null;
@ new.handle = temp;
return new;
}
if (new.time > -1.0 and new.time <= final_position) continue;
new.time = final_position;
@ new.handle = temp;
}
if (new.time == -1.0)
{
double temp_length = round(z - floor_z, 0);
if (temp_length < 1)
{
new.time = -1.0;
return new;
}
double max_z = z + (origin_length * new.z_length);
if (floor_z > max_z)
{
new.time = (z - floor_z) / abs(new.z_length);
return new;
}
new.time = origin_length;
return new;
}
if (new.handle_hit !is null and new.handle !is null) @ new.handle_hit = null;
return new;
}

const string& get_tile_at(int x, int y, int z, mapdata@ map, bool check_obj = true)
{
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (temp.x != x) continue;
if (temp.y != y) continue;
if (temp.z != z) continue;
ref_string = temp.tile;
return ref_string;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
if (map.mapgates[i].is_on_tile(x, y, z))
{
ref_string = map.mapgates[i].type;
return ref_string;
}
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
if (map.maptiles[i].is_on_tile(x, y, z))
{
ref_string = map.maptiles[i].type;
return ref_string;
}
}
return empty;
}

maptile@ get_tile_handle_at(int x, int y, int z, mapdata@ map, bool check_obj = true)
{
bool fallable = false;
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (temp.z > z) continue;
if (temp.x != x) continue;
if (temp.y != y) continue;
fallable = true;
if (temp.z != z) continue;
maptile new;
new.type = temp.tile;
new.is_wall = temp.is_wall;
return new;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
maptile@ temp = map.maptiles[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
return fallable ? maptile() : null;
}

bool& is_fallable(double x, double y, double z, mapdata@ map, bool check_obj = true)
{
x = round(x, 0);
y = round(y, 0);
z = round(z, 0);
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (x != temp.x) continue;
if (y != temp.y) continue;
if (z == temp.z) return false_t;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
return false_t;
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
maptile@ temp = map.maptiles[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
return false_t;
}
return true_t;
}

bool& is_no_item(double x, double y, int z, mapdata@ map, const string& in name = empty)
{
bool noname = name.is_empty();
x = round(x, 0);
y = round(y, 0);
for (int i = map.mapnoitems.length - 1; i > -1; i--)
{
mapnoitem@ temp = map.mapnoitems[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (noname) return true_t;
if (temp.items.exists(name)) return true_t;
if (temp.flags & noitem_weapon > 0)
{
if (weapon_list.exists(name)) return true_t;
}
if (temp.flags & noitem_vehicle > 0)
{
if (vehicledict.exists(name)) return true_t;
}
if (temp.flags & noitem_snack > 0)
{
if (snackitems.exists(name)) return true_t;
}
if (temp.flags & noitem_trap > 0)
{
if (trapitems.exists(name)) return true_t;
}
if (temp.flags & noitem_ammo > 0)
{
if (ammolist.exists(name)) return true_t;
}
if (temp.flags & noitem_explode > 0)
{
if (splash_list.exists(name)) return true_t;
}
}
return false_t;
}

const string& get_zone_at(int x, int y, int z, mapdata@ map)
{
for (int i = map.mapzones.length - 1; i > -1; i--)
{
if (map.mapzones[i].is_on_zone(x, y, z))
{
ref_string = map.mapzones[i].text;
return ref_string;
}
}
return "미확인 지역";
}

const string& get_map_data(mapdata@ map, const string& in data)
{
string[]@ mdata = string_split(map.rawdata, "\r\n", true);
int mdatalength = mdata.length;
for (uint i = 0; i < mdatalength; i++)
{
string[]@ p = string_split(mdata[i], ":", true);
if (p[0] == data)
{
ref_string = string_replace(mdata[i], data + ":", empty, false);
return ref_string;
}
}
return empty;
}

void init_mapsystem()
{
maps.resize(0);
string[]@ mapfiles = find_files("./maps/*.map");
int mapfileslength = mapfiles.length;
for (uint i = 0; i < mapfileslength; i++)
{
create_map(string_replace(mapfiles[i], ".map", empty, true));
}
}

mapdata@ create_map(const string& in name, bool is_file = true)
{
mapdata temp;
temp.internal_load(name, is_file, false);
maps.insert_last(temp);
map_list.set(name, @ temp);
return temp;
}

mapdata@ get_map_handle(const string& in name)
{
if (!map_list.exists(name)) return null;
mapdata@ temp;
map_list.get(name, @ temp);
return temp;
}

bool& is_editable_map(mapdata@ map, player@ this)
{
if (map.is_vehicle) return false_t;
if (map.remove) return false_t;
if (map.public == 1) return true_t;
if (this.rank > 0) return true_t;
if (map.owner.exists(this.name)) return true_t;
return false_t;
}

bool& is_tile_water(int x, int y, int z, mapdata@ map)
{
string tilecheck = get_tile_at(x, y, z, map);
if (tilecheck.is_empty()) return false_t;
int watertileslength = watertiles.length;
for (uint i = 0; i < watertileslength; i++)
{
if (string_contains(tilecheck, watertiles[i], 1) > -1) return true_t;
}
return false_t;
}

int get_tile_type (int x, int y, int z, mapdata@ map)
{
string tid = get_tile_at(x, y, z, map);
if (tid.is_empty()) return TILE_NONE;
if (string_left(tid, 4) == "wall") return TILE_WALL;
return TILE_TILE;
}

bool& is_travelpoint(int x, int y, int z, mapdata@ map)
{
int mplength = map.maptravels.length;
for (uint i = 0; i < mplength; i++)
{
if (map.maptravels[i].is_on_travelpoint(x, y, z)) return true_t;
}
return false_t;
}

void add_map_line(mapdata@ this, const string& in option, const string& in old, const string& in new)
{
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":" + old + "\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + option + ":" + new + "\r\n";
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

void save_map_toggle(mapdata@ this, const string& in option, int toggle)
{
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":0\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":1\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":2\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + option + ":" + toggle + "\r\n";
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

void save_map_starting(mapdata@ this, int x, int y, int z)
{
this.rawdata = string_replace(this.rawdata, "\r\nstartingx:" + this.starting.x + "\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\nstartingy:" + this.starting.y + "\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\nstartingz:" + this.starting.z + "\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + "startingx:" + x + "\r\nstartingy:" + y + "\r\nstartingz:" + z + "\r\n";
this.starting.x = x;
this.starting.y = y;
this.starting.z = z;
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

int save_map_owner(mapdata@ this, string username)
{
int result = 1;
if (this.owner.exists(username))
{
if (this.owner.size == 1) return 0;
this.owner.delete(username);
result = 2;
}
else
{
if (!file_exists("./chars/" + username + ".usr")) return 0;
this.owner.set(username, 0);
}
if (!this.owner_rd.is_empty()) this.rawdata = string_replace(this.rawdata, this.owner_rd, "\r\n", true);
this.owner_rd = "owner:" + array_to_string(this.owner.keys, ",") + "\r\n";
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + this.owner_rd;
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
return result;
}

void mapupdate(const string& in map)
{
mapdata@ mi = get_map_handle(map);
if (mi is null) return;
mi.internal_load(mi.name, true);
string mess;
int gateslength = mi.mapgates.length;
for (uint i = 0; i < gateslength; i++)
{
maptile@ temp = mi.mapgates[i];
mess += temp.gate_rawdata + "[]";
}
int playerslength = mi.players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = mi.players[i];
temp.sendpacket("m_data x:" + temp.x + "\r\ny:" + temp.y + "\r\nz:" + temp.z + "\r\n" + mi.rawdata + "\r\n");
temp.sendpacket("resizegate", 4);
if (!mess.is_empty()) temp.sendpacket("spawngate " + mess, 4);
}
int vslength = mi.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = mi.vs[i];
if (temp.inside is null) continue;
sendmap("vdata " + mi.rawdata, temp.inside, 0);
sendmap("resizegate_v", temp.inside, 4);
if (!mess.is_empty()) sendmap("spawngate_v " + mess, temp.inside, 4);
}
}

void save_public_maps()
{
string text;
int plength = public_maps.length;
for (uint i = 0; i < plength; i++)
{
if (i > 0) text += "\r\n";
text += public_maps[i].name;
}
fl.open("./prefs/save.map", "wb");
fl.write(text);
fl.close();
}

void load_public_maps()
{
fl.open("./prefs/save.map", "rb");
string[]@ items = string_split(fl.read(), "\r\n", true);
fl.close();
int plength = items.length;
for (uint i = 0; i < plength; i++)
{
mapdata@ temp = get_map_handle(items[i]);
if (temp !is null) public_maps.insert_last(temp);
}
}

string check_mapdata_errors(string message, player@ this, mapdata@ map)
{
string[]@ lines = string_split(message, "\r\n", true);
string dt, dt2, colon = ":";
int lineslength = lines.length;
for (uint i = 0; i < lineslength; i++)
{
string[]@ params = string_split(lines[i], colon, false);
if (params[0] == "travelpoint")
{
if (params.length < 12) continue;
if (map.name != params[7])
{
mapdata@ index = get_map_handle(params[7]);
if (index is null)
{
this.alert("없는 맵으로 포탈을 뚫을 순 없습니다.");
return empty;
}
if (this.rank < 1)
{
if (map.survival != index.survival)
{
this.alert("서바이벌 맵과 일반 맵 사이에 포탈을 뚫을 수는 없습니다.");
return empty;
}
if (!index.owner.exists(this.name))
{
this.alert("포탈의 도착 맵의 개발자 목록에 등록되어있지 않아 작업을 계속할 수 없습니다. 먼저 해당 맵의 개발자 권한을 얻으시기 바랍니다.");
return empty;
}
}
}
}
else if (params[0] == "ispawn")
{
if (this.rank > 0) continue;
int pl = params.length;
if (pl < 13) continue;
int am = string_to_number(params[7]);
if (am > 5)
{
this.alert("그렇게 많이 소환할 수는 없습니다.");
return empty;
}
if (am < -5)
{
this.alert("그렇게 많이 소환할 수는 없습니다.");
return empty;
}
if (map.survival == 1) continue;
if (pl == 13)
{
if (params[12] == "s_flag") continue;
if (params[12] == "r_flag") continue;
}
dt.resize(0);
dt2.resize(0);
for (uint j = 12; j < pl; j++)
{
if (j > 12)
{
dt += colon;
dt2 += colon;
}
dt += params[j] + "_";
dt2 += params[j];
}
message = string_replace(message, dt2, dt, false);
}
}
return message;
}

funcdef void map_hash(string[]@ parsed, mapdata@ this, bool is_add = false);
dictionary map_handles;

void install_map_hash()
{
map_handles.set("tile", @ map_hash_tile);
map_handles.set("gate", @ map_hash_gate);
map_handles.set("zone", @ map_hash_zone);
map_handles.set("vending_machine", @ map_hash_vending_machine);
map_handles.set("door", @ map_hash_door);
map_handles.set("ispawn", @ map_hash_ispawn);
map_handles.set("noitem", @ map_hash_noitem);
map_handles.set("mapname", @ map_hash_mapname);
map_handles.set("owner", @ map_hash_owner);
map_handles.set("maxx", @ map_hash_maxx);
map_handles.set("maxy", @ map_hash_maxy);
map_handles.set("startingx", @ map_hash_startingx);
map_handles.set("startingy", @ map_hash_startingy);
map_handles.set("startingz", @ map_hash_startingz);
map_handles.set("fightingstate", @ map_hash_fightingstate);
map_handles.set("travelpoint", @ map_hash_travelpoint);
map_handles.set("robots", @ map_hash_robots);
map_handles.set("no_teamhit", @ map_hash_no_teamhit);
map_handles.set("public", @ map_hash_public);
map_handles.set("no_coord", @ map_hash_no_coord);
map_handles.set("no_seethrough", @ map_hash_no_seethrough);
map_handles.set("no_chat", @ map_hash_no_chat);
map_handles.set("no_teleport", @ map_hash_no_teleport);
map_handles.set("no_recall", @ map_hash_no_recall);
map_handles.set("ctf", @ map_hash_ctf);
map_handles.set("enter_sound", @ map_hash_enter_sound);
map_handles.set("leave_sound", @ map_hash_leave_sound);
map_handles.set("move_start_sound", @ map_hash_move_start_sound);
map_handles.set("move_end_sound", @ map_hash_move_end_sound);
map_handles.set("limit", @ map_hash_limit);
map_handles.set("pan", @ map_hash_pan_step);
map_handles.set("no_tracking", @ map_hash_no_tracking);
map_handles.set("no_corpse", @ map_hash_no_corpse);
map_handles.set("tunnel_sight", @ map_hash_tunnel_sight);
map_handles.set("respawn", @ map_hash_respawn_mode);
map_handles.set("respawn_z", @ map_hash_respawn_z);
map_handles.set("survival", @ map_hash_survival);
map_handles.set("starting_items", @ map_hash_starting_items);
map_handles.set("bd", @ map_hash_bd);
}

void map_hash_tile(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
maptile temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = parsed[7];
temp.is_wall = (string_left(temp.type, 4) == "wall");
if (parsed.length > 9)
{
temp.slidedir = string_to_number(parsed[8]);
temp.slidetime = string_to_number(parsed[9]);
}
if (this.max.z < temp.maxz) this.max.z = temp.maxz;
if (this.min.z > temp.minz) this.min.z = temp.minz;
this.maptiles.insert_last(temp);
}
void map_hash_gate(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 17) return;
maptile temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = parsed[7];
temp.is_wall = (string_left(temp.type, 4) == "wall");
temp.attack_mode = (temp.type == "mine" ? 2 : temp.is_wall ? 1 : 0);
temp.open_sound = parsed[10];
temp.close_sound = parsed[13];
temp.opentime = string_to_number(parsed[8]);
temp.closetime = string_to_number(parsed[11]);
temp.openreadytime = string_to_number(parsed[9]);
temp.closereadytime = string_to_number(parsed[12]);
temp.plus_x = string_to_number(parsed[14]);
temp.plus_y = string_to_number(parsed[15]);
temp.plus_z = string_to_number(parsed[16]);
temp.mode = GATE_CLOSE;
temp.oldminx = temp.minx;
temp.oldmaxx = temp.maxx;
temp.oldminy = temp.miny;
temp.oldmaxy = temp.maxy;
temp.oldminz = temp.minz;
temp.oldmaxz = temp.maxz;
if (parsed.length > 18)
{
temp.slidedir = string_to_number(parsed[17]);
temp.slidetime = string_to_number(parsed[18]);
}
temp.hazard = (parsed.length == 20 or parsed.length == 18);
temp.gate_rawdata = temp.minx + " " + temp.maxx + " " + temp.miny + " " + temp.maxy + " " + temp.minz + " " + temp.maxz + " " + temp.type + " " + temp.plus_x + " " + temp.plus_y + " " + temp.plus_z + " " + temp.slidetime + " " + temp.slidedir + (temp.hazard ? " hazard" : empty);
if (is_add)
{
sendmap("spawngate " + temp.gate_rawdata, this, 4);
int vslength = this.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = this.vs[i];
if (v.inside is null) continue;
sendmap("spawngate_v " + temp.gate_rawdata, v.inside, 4);
}
}
this.mapgates.insert_last(temp);
}
void map_hash_zone(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
mapzone temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.text = parsed[7];
temp.trackable = (parsed.length >= 8);
this.mapzones.insert_last(temp);
}
void map_hash_travelpoint(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 13) return;
maptravel temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
this.maptravels.insert_last(temp);
}
void map_hash_vending_machine(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 6) return;
spawn_vending_machine(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), this, parsed[4], parsed[5]);
}
void map_hash_starting_items(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 2) return;
this.starting_items = text_to_dictionary(parsed[1], ",", VALUE_DOUBLE, ";");
}
void map_hash_door(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 14) return;
mapdoor temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
this.mapdoors.insert_last(temp);
}
void map_hash_ispawn(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 13) return;
mapispawn temp;
temp.minx = string_to_number(parsed[1]);
temp.maxx = string_to_number(parsed[2]);
temp.miny = string_to_number(parsed[3]);
temp.maxy = string_to_number(parsed[4]);
temp.minz = string_to_number(parsed[5]);
temp.maxz = string_to_number(parsed[6]);
temp.maxobjs = string_to_number(parsed[7]);
if (temp.maxobjs < 0)
{
temp.adjustable = true;
temp.maxobjs = abs(temp.maxobjs);
}
temp.mapispawntime = string_to_number(parsed[8]);
temp.mapiunspawntime = string_to_number(parsed[9]);
temp.limit = string_to_number(parsed[10]);
if (parsed[10] == "a")
{
temp.reset_cycle = true;
temp.limit = -1;
}
temp.limit_all = (temp.limit < 0);
temp.limit = abs(temp.limit);
temp.limittime = string_to_number(parsed[11]);
int pl = parsed.length - 1;
temp.mapobjs.reserve(pl - 10);
for (uint x = pl; x > 11; x--)
{
temp.mapobjs.insert_last(parsed[x]);
}
this.mapispawns.insert_last(temp);
}
void map_hash_robots(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 10) return;
maprspawn new;
new.minx = string_to_number(parsed[1]);
new.maxx = string_to_number(parsed[2]);
new.miny = string_to_number(parsed[3]);
new.maxy = string_to_number(parsed[4]);
new.minz = string_to_number(parsed[5]);
new.maxz = string_to_number(parsed[6]);
new.maxrobots = string_to_number(parsed[7]);
if (new.maxrobots < 0)
{
new.adjustable = true;
new.maxrobots = abs(new.maxrobots);
}
new.spawntime = string_to_number(parsed[8]);
new.list = string_split(parsed[9], ",", true);
if (parsed.length > 10) new.tile = parsed[10];
if (new.tile == ".") new.tile.resize(0);
if (parsed.length > 11) new.group = string_to_number(parsed[11]);
this.maprspawns.insert_last(new);
}
void map_hash_noitem(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
mapnoitem new;
new.minx = string_to_number(parsed[1]);
new.maxx = string_to_number(parsed[2]);
new.miny = string_to_number(parsed[3]);
new.maxy = string_to_number(parsed[4]);
new.minz = string_to_number(parsed[5]);
new.maxz = string_to_number(parsed[6]);
int pl = parsed.length;
for (uint x = 7; x < pl; x++) new.items.set(parsed[x], 0);
if (new.items.exists("무기")) new.flags += noitem_weapon;
if (new.items.exists("차량")) new.flags += noitem_vehicle;
if (new.items.exists("식음료")) new.flags += noitem_snack;
if (new.items.exists("함정")) new.flags += noitem_trap;
if (new.items.exists("탄약")) new.flags += noitem_ammo;
if (new.items.exists("폭발물")) new.flags += noitem_explode;
this.mapnoitems.insert_last(new);
}
void map_hash_mapname(string[]@ parsed, mapdata@ this, bool is_add = false) {this.name = parsed[1]; }
void map_hash_owner(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.owner_rd = "owner:" + parsed[1] + "\r\n";
this.owner = array_to_dictionary(string_split(parsed[1], ",", false));
}
void map_hash_maxx(string[]@ parsed, mapdata@ this, bool is_add = false) {this.max.x = string_to_number(parsed[1]); }
void map_hash_maxy(string[]@ parsed, mapdata@ this, bool is_add = false) {this.max.y = string_to_number(parsed[1]); }
void map_hash_startingx(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.x = string_to_number(parsed[1]); }
void map_hash_startingy(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.y = string_to_number(parsed[1]); }
void map_hash_startingz(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.z = string_to_number(parsed[1]); }
void map_hash_fightingstate(string[]@ parsed, mapdata@ this, bool is_add = false) {this.fighting = string_to_number(parsed[1]); }
void map_hash_public(string[]@ parsed, mapdata@ this, bool is_add = false) {this.public = string_to_number(parsed[1]); }
void map_hash_no_tracking(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_tracking = string_to_number(parsed[1]); }
void map_hash_no_corpse(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_corpse = string_to_number(parsed[1]); }
void map_hash_respawn_mode(string[]@ parsed, mapdata@ this, bool is_add = false) {this.respawn_mode = string_to_number(parsed[1]); }
void map_hash_respawn_z(string[]@ parsed, mapdata@ this, bool is_add = false) {this.respawn_z = string_to_number(parsed[1]); }
void map_hash_survival(string[]@ parsed, mapdata@ this, bool is_add = false) {this.survival = string_to_number(parsed[1]); }
void map_hash_tunnel_sight(string[]@ parsed, mapdata@ this, bool is_add = false) {this.tunnel_sight = string_to_number(parsed[1]); }
void map_hash_no_teamhit(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_teamhit = string_to_number(parsed[1]); }
void map_hash_no_coord(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_coord = string_to_number(parsed[1]); }
void map_hash_no_seethrough(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_seethrough = string_to_number(parsed[1]); }
void map_hash_no_chat(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_chat = string_to_number(parsed[1]); }
void map_hash_no_teleport(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_teleport = string_to_number(parsed[1]); }
void map_hash_no_recall(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_recall = string_to_number(parsed[1]); }
void map_hash_ctf(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
ctf temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
int type = string_to_number(parsed[7]);
switch (type)
{
case 1:
this.ctf_sdest.insert_last(temp);
break;
case 2:
this.ctf_rdest.insert_last(temp);
break;
}
}
void map_hash_enter_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.enter_sound = parsed[1]; }
void map_hash_leave_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.leave_sound = parsed[1]; }
void map_hash_move_start_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.move_start_sound = parsed[1]; }
void map_hash_move_end_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.move_end_sound = parsed[1]; }
void map_hash_limit(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.limit.resize(0);
int pl = parsed.length;
for (uint i = 1; i < pl; i++)
{
if (i > 1) this.limit += " ";
this.limit += parsed[i];
}
}
void map_hash_pan_step(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.pan_step = string_to_number(parsed[1]);
if (this.pan_step < 0.01) this.pan_step = 0.01;
}
void map_hash_bd(string[]@ parsed, mapdata@ this, bool is_add = false) {this.boundary_volume = string_to_number(parsed[1]); }

funcdef void maporder_hash(string[]@ parsed, mapdata@ temp, player@ this);
dictionary maporder_handles;

void install_maporder_hash()
{
maporder_handles.set("이", @ maporder_hash_name);
maporder_handles.set("이름", @ maporder_hash_name);
maporder_handles.set("시", @ maporder_hash_sp);
maporder_handles.set("시작", @ maporder_hash_sp);
maporder_handles.set("시작점", @ maporder_hash_sp);
maporder_handles.set("입", @ maporder_hash_es);
maporder_handles.set("입장", @ maporder_hash_es);
maporder_handles.set("퇴", @ maporder_hash_ls);
maporder_handles.set("퇴장", @ maporder_hash_ls);
maporder_handles.set("이동시", @ maporder_hash_mss);
maporder_handles.set("이동시작", @ maporder_hash_mss);
maporder_handles.set("이동끝", @ maporder_hash_mes);
maporder_handles.set("개", @ maporder_hash_owner);
maporder_handles.set("개발", @ maporder_hash_owner);
maporder_handles.set("개발자", @ maporder_hash_owner);
maporder_handles.set("전", @ maporder_hash_fighting);
maporder_handles.set("전투", @ maporder_hash_fighting);
maporder_handles.set("팀", @ maporder_hash_no_teamhit);
maporder_handles.set("팀조", @ maporder_hash_no_teamhit);
maporder_handles.set("팀조준", @ maporder_hash_no_teamhit);
maporder_handles.set("공", @ maporder_hash_open);
maporder_handles.set("공개", @ maporder_hash_open);
maporder_handles.set("공개맵", @ maporder_hash_open);
maporder_handles.set("공개편", @ maporder_hash_public);
maporder_handles.set("공개편집", @ maporder_hash_public);
maporder_handles.set("투", @ maporder_hash_no_seethrough);
maporder_handles.set("투시", @ maporder_hash_no_seethrough);
maporder_handles.set("투시금", @ maporder_hash_no_seethrough);
maporder_handles.set("투시금지", @ maporder_hash_no_seethrough);
maporder_handles.set("좌", @ maporder_hash_no_coord);
maporder_handles.set("좌표", @ maporder_hash_no_coord);
maporder_handles.set("좌표금", @ maporder_hash_no_coord);
maporder_handles.set("좌표금지", @ maporder_hash_no_coord);
maporder_handles.set("채", @ maporder_hash_no_chat);
maporder_handles.set("채팅", @ maporder_hash_no_chat);
maporder_handles.set("채팅금", @ maporder_hash_no_chat);
maporder_handles.set("채팅금지", @ maporder_hash_no_chat);
maporder_handles.set("순", @ maporder_hash_no_teleport);
maporder_handles.set("순간", @ maporder_hash_no_teleport);
maporder_handles.set("순간이", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동금", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동금지", @ maporder_hash_no_teleport);
maporder_handles.set("귀", @ maporder_hash_no_recall);
maporder_handles.set("귀환", @ maporder_hash_no_recall);
maporder_handles.set("귀환금", @ maporder_hash_no_recall);
maporder_handles.set("귀환금지", @ maporder_hash_no_recall);
maporder_handles.set("입장제", @ maporder_hash_limit);
maporder_handles.set("입장제한", @ maporder_hash_limit);
maporder_handles.set("패", @ maporder_hash_pan_step);
maporder_handles.set("패닝", @ maporder_hash_pan_step);
maporder_handles.set("부", @ maporder_hash_respawn);
maporder_handles.set("부활", @ maporder_hash_respawn);
maporder_handles.set("부활고", @ maporder_hash_respawn_z);
maporder_handles.set("부활고도", @ maporder_hash_respawn_z);
maporder_handles.set("추", @ maporder_hash_no_tracking);
maporder_handles.set("추적", @ maporder_hash_no_tracking);
maporder_handles.set("추적금", @ maporder_hash_no_tracking);
maporder_handles.set("추적금지", @ maporder_hash_no_tracking);
maporder_handles.set("시", @ maporder_hash_no_corpse);
maporder_handles.set("시체", @ maporder_hash_no_corpse);
maporder_handles.set("시체금", @ maporder_hash_no_corpse);
maporder_handles.set("시체금지", @ maporder_hash_no_corpse);
maporder_handles.set("터", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널시", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널시야", @ maporder_hash_tunnel_sight);
maporder_handles.set("시작아", @ maporder_hash_starting_items);
maporder_handles.set("시작아이", @ maporder_hash_starting_items);
maporder_handles.set("시작아이템", @ maporder_hash_starting_items);
maporder_handles.set("경", @ maporder_hash_bd);
maporder_handles.set("경계", @ maporder_hash_bd);
maporder_handles.set("경계볼", @ maporder_hash_bd);
maporder_handles.set("경계볼륨", @ maporder_hash_bd);
}

void maporder_hash_name(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.name, true);
return;
}
if (map_list.exists(parsed[3]))
{
this.alert("이미 존재하는 맵 이름입니다.");
return;
}
string oldname = temp.name;
map_list.delete(oldname);
file_delete("./maps/" + oldname + ".map");
temp.name = parsed[3];
temp.rawdata = string_replace(temp.rawdata, "name:" + oldname + "\r\n", "name:" + temp.name + "\r\n", false);
string[]@ lines = string_split(temp.rawdata, "\r\n", true);
string tp = "travelpoint";
string colon = ":";
int lineslength = lines.length;
for (uint i = 0; i < lineslength; i++)
{
if (string_left(lines[i], 11) != tp) continue;
temp.rawdata = string_replace(temp.rawdata, lines[i], string_replace(lines[i], colon + oldname + colon, colon + temp.name + colon, false), false);
}
fl.open("./maps/" + temp.name + ".map", "wb");
fl.write(temp.rawdata);
fl.close();
map_list.set(temp.name, @ temp);
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data " + temp.rawdata);
int vslength = temp.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = temp.vs[i];
if (v.inside is null) continue;
sendmap("vdata " + temp.rawdata, v.inside, 0);
}
this.alert("업데이트되었습니다.");
}
void maporder_hash_open(string[]@ parsed, mapdata@ temp, player@ this)
{
int index = public_maps.find_by_reference(temp);
if (index < 0)
{
if (temp.no_recall == 1)
{
this.alert("당신은 그림의 떡을 만들려 합니다.");
return;
}
public_maps.insert_last(temp);
this.alert("공개맵 목록에 올렸습니다.");
}
else
{
public_maps.remove_at(index);
this.alert("공개맵 목록에서 내렸습니다.");
}
}
void maporder_hash_sp(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 6) return;
save_map_starting(temp, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]));
this.alert("시작점이 바뀌었습니다.");
}
void maporder_hash_owner(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
if (!temp.owner.is_empty()) this.alert(array_to_string(temp.owner.keys, ", "), true);
return;
}
switch (save_map_owner(temp, parsed[3]))
{
case 1: this.alert(parsed[3] + "님을 개발자 목록에 추가했습니다.");
break; case 2: this.alert(parsed[3] + "님을 개발자 목록에서 제거했습니다.");
break; default: this.alert("알 수 없는 오류가 발생했습니다.");
}
}
void maporder_hash_es(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.enter_sound, true);
return;
}
add_map_line(temp, "enter_sound", temp.enter_sound, parsed[3]);
temp.enter_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_ls(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.leave_sound, true);
return;
}
add_map_line(temp, "leave_sound", temp.leave_sound, parsed[3]);
temp.leave_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_mss(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.move_start_sound, true);
return;
}
add_map_line(temp, "move_start_sound", temp.move_start_sound, parsed[3]);
temp.move_start_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_mes(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.move_end_sound, true);
return;
}
add_map_line(temp, "move_end_sound", temp.move_end_sound, parsed[3]);
temp.move_end_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_limit(string[]@ parsed, mapdata@ temp, player@ this)
{
int pl = parsed.length;
if (pl < 4 or pl > 20)
{
this.alert(temp.limit, true);
return;
}
string data;
for (uint i = 3; i < pl; i++)
{
if (i > 3) data += " ";
data += parsed[i];
}
add_map_line(temp, "limit", temp.limit, data);
temp.limit = data;
this.alert("업데이트되었습니다.");
}
void maporder_hash_pan_step(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.pan_step, true);
return;
}
double pan_step = string_to_number(parsed[3]);
if (temp.pan_step < 0.01) pan_step = 0.01;
add_map_line(temp, "pan", temp.pan_step, pan_step);
temp.pan_step = pan_step;
sendmap("panupdate " + parsed[3], temp, 0);
this.alert("업데이트되었습니다.");
}
void maporder_hash_tunnel_sight(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.tunnel_sight, true);
return;
}
int tunnel_sight = string_to_number(parsed[3]);
if (tunnel_sight < 0) tunnel_sight = 0;
if (tunnel_sight >= 180) tunnel_sight = 180;
add_map_line(temp, "tunnel_sight", temp.tunnel_sight, tunnel_sight);
temp.tunnel_sight = tunnel_sight;
this.alert("업데이트되었습니다.");
}
void maporder_hash_starting_items(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(dictionary_to_text(temp.starting_items, ",", true, ";"), true);
return;
}
add_map_line(temp, "starting_items", dictionary_to_text(temp.starting_items, ",", true, ";"), parsed[3]);
temp.starting_items = text_to_dictionary(parsed[3], ",", VALUE_DOUBLE, ";");
this.alert("업데이트되었습니다.");
}
void maporder_hash_no_tracking(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_tracking ^= 1;
save_map_toggle(temp, "no_tracking", temp.no_tracking);
this.alert("추적금지를 " + (temp.no_tracking == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_corpse(string[]@ parsed, mapdata@ temp, player@ this)
{
if (temp.survival == 0)
{
this.alert("서바이벌 맵에서만 설정할 수 있습니다.");
return;
}
temp.no_corpse ^= 1;
save_map_toggle(temp, "no_corpse", temp.no_corpse);
this.alert("시체금지를 " + (temp.no_corpse == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_seethrough(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_seethrough ^= 1;
save_map_toggle(temp, "no_seethrough", temp.no_seethrough);
this.alert((temp.no_seethrough == 1 ? "이제 카메라로 벽 너머를 투시할 수 없습니다." : "이제 카메라로 벽 너머를 투시할 수 있습니다."));
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nno_seethrough:" + temp.no_seethrough);
}
void maporder_hash_bd(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.boundary_volume, true);
return;
}
double bd = string_to_number(parsed[3]);
add_map_line(temp, "bd", temp.boundary_volume, bd);
temp.boundary_volume = bd;
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nbd:" + temp.boundary_volume);
this.alert("업데이트되었습니다.");
}
void maporder_hash_respawn(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.respawn_mode = (temp.respawn_mode == 0 ? 1 : 0);
save_map_toggle(temp, "respawn", temp.respawn_mode);
this.alert("이제부터 죽으면 " + (temp.respawn_mode == 1 ? "맵의 시작점에서 부활합니다." : "맵 내의 임의의 지역에서 부활합니다."));
}
void maporder_hash_respawn_z(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.respawn_z, true);
return;
}
int respawn_z = string_to_number(parsed[3]);
add_map_line(temp, "respawn_z", temp.respawn_z, respawn_z);
temp.respawn_z = respawn_z;
this.alert("업데이트되었습니다.");
}
void maporder_hash_fighting(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.fighting ^= 1;
save_map_toggle(temp, "fightingstate", temp.fighting);
this.alert("전투 가능을 " + (temp.fighting == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_teamhit(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_teamhit ^= 1;
save_map_toggle(temp, "no_teamhit", temp.no_teamhit);
this.alert("이제 팀원을 조준할 수 " + (temp.no_teamhit == 1 ? "없습니다." : "있습니다."));
}
void maporder_hash_public(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.public ^= 1;
save_map_toggle(temp, "public", temp.public);
this.alert("맵 개발권을 " + (temp.public == 1 ? "개방합니다." : "폐쇄합니다."));
}
void maporder_hash_no_coord(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_coord ^= 1;
save_map_toggle(temp, "no_coord", temp.no_coord);
this.alert("좌표 조회를 " + (temp.no_coord == 0 ? "허용합니다." : "금지합니다."));
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nno_coord:" + temp.no_coord);
int vslength = temp.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = temp.vs[i];
if (v.inside is null) continue;
sendmap("vdata_add \r\nno_coord:" + temp.no_coord, v.inside, 0);
}
}
void maporder_hash_no_chat(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_chat ^= 1;
save_map_toggle(temp, "no_chat", temp.no_chat);
this.alert("맵 내 채팅을 " + (temp.no_chat == 0 ? "허용합니다." : "금지합니다."));
}
void maporder_hash_no_teleport(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_teleport ^= 1;
save_map_toggle(temp, "no_teleport", temp.no_teleport);
this.alert("해당 맵에서 순간이동으로 나가는 것을 " + (temp.no_teleport == 0 ? "허용합니다." : "금지합니다."));
}
void maporder_hash_no_recall(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_recall ^= 1;
save_map_toggle(temp, "no_recall", temp.no_recall);
this.alert("해당 맵에 순간이동해 들어오는 것을 " + (temp.no_recall == 0 ? "허용합니다." : "금지합니다."));
}