// map.bgt서버 소스코드
// 지하철 타일 생성 코드
class subway
{
    int x; // x 좌표
    int y; // y 좌표
    int z; // z 좌표
    int speed; // 속도

    void subway(int x, int y, int z, int speed)
    {
        // 생성자 메소드
        this.x = x;
        this.y = y;
        this.z = z;
        this.speed = speed;
        create_tiles(); // 타일 생성 메소드 호출
    }

    void create_tiles()
    {
        // 31 x 31 크기의 타일 생성
        for(int i=0; i<31; i++)
        {
            for(int j=0; j<31; j++)
            {
                // 타일 객체 생성
                map_tile tile(this.x + i, this.x + i + 1, this.y + j, this.y + j + 1, this.z, this.z + 1);
                // 타일 유형은 TILE_TILE로 설정
                tile.type = "TILE_TILE";
                // 타일 이름은 metal5로 설정
                tile.name = "metal5";
                // 타일에 지하철 객체를 참조하는 subway 속성 추가
                tile.subway = this;
                // 맵데이터 객체에 타일 추가
                map_data.add_tile(tile);
            }
        }
    }

    void move()
    {
        // 지하철 움직임 메소드
        // 속도에 따라 x 좌표를 변경
        this.x += this.speed;
        // x 좌표가 맵의 범위를 벗어나면 반대 방향으로 속도 변경
        if(this.x < 0 || this.x > map_data.maxx)
        {
            this.speed = -this.speed;
        }
        // 타일들의 위치도 변경
        for(int i=0; i<map_data.tiles.length; i++)
        {
            map_tile tile = map_data.tiles[i];
            if(tile.subway == this)
            {
                tile.x += this.speed;
                tile.minx += this.speed;
                tile.maxx += this.speed;
                // 타일 위에 있는 객체들의 위치도 변경
                for(int j=0; j<map_data.objects.length; j++)
                {
                    object obj = map_data.objects[j];
                    if(obj.is_on_tile(tile))
                    {
                        obj.x += this.speed;
                    }
                }
            }
        }
    }
}

// 매 프레임마다 지하철 움직임 메소드 호출 예시
void loop()
{
    for(int i=0; i<2; i++)
    {
        subway s = get_global_var("subway" + str(i+1));
        s.move();
    }
}



string[] watertiles = {"shallow", "water", "spring", "snow", "ice"};
enum TILETYPE
{
TILE_NONE, TILE_TILE, TILE_WALL
}
enum gatemodes
{
GATE_NONE, GATE_OPEN, GATE_OPENING, GATE_CLOSE, GATE_CLOSING
}
mapdata@[] maps(0);
mapdata@[] public_maps(0);
dictionary map_list;
string default_leave_sound = "unspawn";
string default_enter_sound = "move";

class mapdata
{
bool remove = false;
string name;
string owner_rd;
dictionary owner;
timer playerstimer;
int loadtime = 0;
string rawdata;
vector min, max, starting;
mapispawn[] mapispawns;
maprspawn[] maprspawns;
maptile[] maptiles, mapgates;
maptravel@[] maptravels;
mapdoor@[] mapdoors;
mapzone@[] mapzones;
bool event_on = false;
bool is_vehicle = false;
vehicle@ vhc;
int fighting = 1;
int no_teamhit = 0;
int public = 1;
int no_coord = 0;
int no_chat = 0;
int no_teleport = 0, no_recall = 0;
ctf@[] ctf_sdest, ctf_rdest;
uint ctf_slife = 0, ctf_rlife = 0;
bool ctf_run = false;
mapnoitem[] mapnoitems;
string enter_sound = default_enter_sound;
string leave_sound = default_leave_sound;
string move_start_sound = default_leave_sound;
string move_end_sound = default_enter_sound;
string limit;
double pan_step = 1;
int respawn_mode = 1, respawn_z = 0;
int no_tracking = 0;
int no_seethrough = 0;
int no_corpse = 0;
int tunnel_sight = 0;
int survival = 0;
int boundary_volume = 50;
timer spawntimer;
dictionary starting_items;
int active_vehicles = 0;
int active_pv = 0;
dictionary lastman_standing;

void internal_load(const string& in loadname, bool is_file = true, bool init = true)
{
timer loadtimer;
if (init)
{
name.resize(0);
owner.delete_all();
owner_rd.resize(0);
move_start_sound = default_leave_sound;
move_end_sound = default_enter_sound;
leave_sound = default_leave_sound;
enter_sound = default_enter_sound;
min.z = 0;
max.x = 0; max.y = 0; max.z = 0;
starting.x = 0; starting.y = 0; starting.z = 0;
respawn_z = 0;
respawn_mode = 1;
pan_step = 1;
maprspawns.resize(0);
mapispawns.resize(0);
mapnoitems.resize(0);
maptiles.resize(0);
mapgates.resize(0);
maptravels.resize(0);
mapdoors.resize(0);
mapzones.resize(0);
ctf_sdest.resize(0);
ctf_rdest.resize(0);
fighting = 1;
no_teamhit = 0;
public = 1;
no_coord = 0;
no_tracking = 0;
no_seethrough = 0;
no_chat = 0;
no_teleport = 0;
no_recall = 0;
no_seethrough = 0;
no_corpse = 0;
tunnel_sight = 0;
survival = 0;
boundary_volume = 50;
limit.resize(0);
starting_items.delete_all();
vending_machines.resize(0);
}
if (is_file)
{
fl.open("./maps/" + loadname + ".map", "rb");
rawdata = fl.read();
fl.close();
} // if.is_file.
else rawdata = loadname;
string[]@ map = string_split(rawdata, "\r\n", true);
int maplength = map.length;
for (uint i = 0; i < maplength; i++)
{
string[]@ parsed = string_split(map[i], ":", false);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed, this, false);
}
if (!name.is_empty() and !is_file and !is_vehicle)
{
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}
this.loadtime = loadtimer.elapsed;
} // method.

void add_rawdata(const string& in new_rawdata)
{
rawdata += new_rawdata;
fl.open("./maps/" + this.name + ".map", "ab");
fl.write(new_rawdata);
fl.close();
string[]@ map = string_split(new_rawdata, "\r\n", true);
int maplength = map.length;
for (uint i = 0; i < maplength; i++)
{
string[]@ parsed = string_split(map[i], ":", false);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed, this, true);
}
sendmap("m_data_add " + new_rawdata, this, 0);
int vslength = this.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = this.vs[i];
if (temp.inside is null) continue;
sendmap("vdata_add " + new_rawdata, temp.inside, 0);
}
}

// map objects
bomb_cracker@[] bomb_crackers;
canister@[] canisters;
carrier_missile@[] carrier_missiles;
concussive_grenade@[] concussive_grenades;
impact_bomb@[] impact_bombs;
mine@[] mines;
dictionary mine_locs;
missile@[] missiles;
motion_bomb@[] motion_bombs;
nuclear_bomb@[] nuclear_bombs;
remgun@[] remguns;
remote_timebomb@[] remote_timebombs;
security_bomb@[] security_bombs;
sound_grenade@[] sound_grenades;
stun_grenade@[] stun_grenades;
smoke_grenade@[] smoke_grenades;
timebomb@[] timebombs;
ultrabomb@[] ultrabombs;
wirebomb@[] wirebombs;
corpse@[] corpses;
fire@[] fires;
hittable@[] hobjs;
msound@[] msounds;
obj@[] objs;
player@[] players;
onlinequiz@[] quiz;
Robot@[] robots;
shipment@[] shipments;
amb@[] ambs;
splash@[] splashs;
store_coordinate@[] store_coordinates;
vehicle@[] vs;
vending_machine[] vending_machines;
weapon@[] weapons;

void loop()
{
active_pv = this.players.length + this.active_vehicles;
if (active_pv > 0)
{
if (this.spawntimer.elapsed >= 50)
{
this.spawntimer.force(0);
int mapgateslength = this.mapgates.length;
for (uint j = 0; j < mapgateslength; j++)
{
maptile@ mg = this.mapgates[j];
switch (mg.mode)
{
case GATE_CLOSE:
{
if (mg.opentime == 0) continue;
if (mg.walkingtimer.elapsed < abs(mg.opentime)) continue;
if (mg.opentime > 0) mg.walkingtimer.force(0);
if (mg.openreadytime < 0)
{
if (mg.is_on_tile(this)) continue;
}
mg.mode = GATE_OPENING;
mg.walkingtimer.force(0);
sendmap("play_3ds " + mg.open_sound + " " + mg.oldminx + " " + mg.oldmaxx + " " + mg.oldminy + " " + mg.oldmaxy + " " + mg.oldminz + " " + mg.oldmaxz, this, 4);
}
break; case GATE_CLOSING:
{
if (mg.walkingtimer.elapsed < abs(mg.closereadytime)) continue;
mg.walkingtimer.force(0);
mg.mode = GATE_CLOSE;
mg.gate_update(this);
}
break; case GATE_OPEN:
{
if (mg.closetime == 0) continue;
if (mg.walkingtimer.elapsed < abs(mg.closetime)) continue;
if (mg.closetime > 0) mg.walkingtimer.force(0);
if (mg.closereadytime < 0)
{
if (mg.is_on_tile(this)) continue;
}
mg.mode = GATE_CLOSING;
mg.walkingtimer.force(0);
sendmap("play_3ds " + mg.close_sound + " " + mg.oldminx + " " + mg.oldmaxx + " " + mg.oldminy + " " + mg.oldmaxy + " " + mg.oldminz + " " + mg.oldmaxz, this, 4);
}
break; case GATE_OPENING:
{
if (mg.walkingtimer.elapsed < abs(mg.openreadytime)) continue;
mg.walkingtimer.force(0);
mg.mode = GATE_OPEN;
mg.gate_update(this);
}
break;
}
}
int mapispawnslength = this.mapispawns.length;
for (uint j = 0; j < mapispawnslength; j++)
{
mapispawn@ mis = this.mapispawns[j];
if (mis.limit > 0)
{
if (mis.limittimer.elapsed >= mis.limittime)
{
mis.limittimer.force(0);
if ((mis.reset_cycle ? mis.limited.size == mis.mapobjs.length : true)) mis.limited.delete_all();
}
}
if (mis.mapispawntimer.elapsed < round(mis.mapispawntime / (mis.adjustable ? active_pv : 1), 0)) continue;
mis.mapispawntimer.force(0);
if (mis.curobjs >= (mis.maxobjs * (mis.adjustable ? active_pv : 1))) continue;
spawn_rand_obj(mis.minx, mis.maxx, mis.miny, mis.maxy, mis.minz, mis.maxz, this, mis.mapobjs, mis.mapiunspawntime, mis);
}
int rlist = this.maprspawns.length;
for (uint j = 0; j < rlist; j++)
{
maprspawn@ mro = this.maprspawns[j];
if (mro.spawntimer.elapsed < round(mro.spawntime / (mro.adjustable ? active_pv : 1), 0)) continue;
mro.spawntimer.force(0);
if (mro.currobots >= (mro.maxrobots * (mro.adjustable ? active_pv : 1))) continue;
robot_spawn(mro.list[random(0, (mro.list.length - 1))], random(mro.minx, mro.maxx), random(mro.miny, mro.maxy), random(mro.minz, mro.maxz), this, mro.group, mro.tile, mro);
}
}
}
if (!this.msounds.is_empty()) msoundloop(this);
if (!this.is_vehicle)
{
this.active_vehicles = 0;
if (!this.vs.is_empty()) vloop(this);
}
if (!this.weapons.is_empty()) weaponloop(this);
if (!this.bomb_crackers.is_empty()) bomb_crackerloop(this);
if (!this.canisters.is_empty()) canisterloop(this);
if (!this.carrier_missiles.is_empty()) cmloop(this);
if (!this.concussive_grenades.is_empty()) concussive_grenadeloop(this);
if (!this.impact_bombs.is_empty()) impact_bombloop(this);
if (!this.mines.is_empty()) mineloop(this);
if (!this.missiles.is_empty()) missileloop(this);
if (!this.motion_bombs.is_empty()) motion_bombloop(this);
if (!this.nuclear_bombs.is_empty()) nuclear_bombloop(this);
if (!this.remguns.is_empty()) remgunloop(this);
if (!this.remote_timebombs.is_empty()) remote_timebombloop(this);
if (!this.security_bombs.is_empty()) sbombloop(this);
if (!this.sound_grenades.is_empty()) sound_grenadeloop(this);
if (!this.stun_grenades.is_empty()) stun_grenadeloop(this);
if (!this.smoke_grenades.is_empty()) smoke_grenadeloop(this);
if (!this.timebombs.is_empty()) timebombloop(this);
if (!this.ultrabombs.is_empty()) ultrabombloop(this);
if (!this.wirebombs.is_empty()) wirebombloop(this);
if (!this.corpses.is_empty()) corpseloop(this);
if (!this.fires.is_empty()) fireloop(this);
if (!this.hobjs.is_empty()) hobjloop(this);
if (!this.ambs.is_empty()) ambloop(this);
if (!this.objs.is_empty()) objloop(this);
if (!this.players.is_empty()) playerloop(this);
if (!this.robots.is_empty()) robotloop(this);
if (!this.shipments.is_empty()) shipmentloop(this);
if (!this.splashs.is_empty()) splashloop(this);
if (!this.vending_machines.is_empty()) vendingloop(this);
}
} // class.mapdata.

class ctf
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_ctf(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class maprspawn
{
int minx, maxx, miny, maxy, minz, maxz;
string[] list;
string tile;
uint group = 0;
timer spawntimer;
int spawntime = 0;
int currobots = 0, maxrobots = 0;
bool adjustable = false;
}

const int noitem_weapon = 1;
const int noitem_vehicle = 2;
const int noitem_snack = 4;
const int noitem_trap = 8;
const int noitem_ammo = 16;
const int noitem_explode = 32;
class mapnoitem
{
int minx, maxx, miny, maxy, minz, maxz;
dictionary items;
int flags = 0;
}

class mapdoor
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_door(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class maptravel
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;

bool& is_on_travelpoint(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}
}

class mapzone
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string text;
bool trackable = false;

bool& is_on_zone(double x, double y, double z)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
return true_t;
}

double distancecheck(double x, double y, double z)
{
double dx = abs(x - center_x) - size_x;
double dy = abs(y - center_y) - size_y;
double dz = abs(z - center_z) - size_z;
double final = 0.0;
if (dx > 0) final += (dx * dx);
if (dy > 0) final += (dy * dy);
if (dz > 0) final += (dz * dz);
return final ** 0.5;
}
}

class maptile
{
int minx, maxx, miny, maxy, minz, maxz;
int oldminx, oldmaxx, oldminy, oldmaxy, oldminz, oldmaxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string type;
bool is_wall = false;
int slidetime = 0;
int slidedir = -1;
int plus_x = 0, plus_y = 0, plus_z = 0;
string open_sound, close_sound;
int opentime = 0, closetime = 0;
int openreadytime = 0, closereadytime = 0;
timer walkingtimer;
int mode = GATE_NONE, attack_mode = 0;
bool hazard = false;
string gate_rawdata;

bool& is_on_tile(double x, double y, double z, bool staircase = false)
{
if (minx > x) return false_t;
if (maxx < x) return false_t;
if (miny > y) return false_t;
if (maxy < y) return false_t;
if (minz > z) return false_t;
if (maxz < z) return false_t;
if (staircase and minz == maxz) return false_t;
return true_t;
} // method.is_on_tile.

bool& is_on_tile(mapdata@ map)
{
int tminx = minx + plus_x;
int tmaxx = maxx + plus_x;
int tminy = miny + plus_y;
int tmaxy = maxy + plus_y;
int tminz = minz + plus_z;
int tmaxz = maxz + plus_z;
int playerslength = map.players.length;
for (uint x = 0; x < playerslength; x++)
{
player@ temp = map.players[x];
if (temp.health <= 0) continue;
if (temp.invinsible) continue;
if (temp.hidden) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.z < tminz) continue;
if (temp.z > tmaxz) continue;
return true_t;
}
int robotslength = map.robots.length;
for (uint r = 0; r < robotslength; r++)
{
Robot@ temp = map.robots[r];
if (temp.health <= 0) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.z < tminz) continue;
if (temp.z > tmaxz) continue;
return true_t;
}
int vslength = map.vs.length;
for (uint v = 0; v < vslength; v++)
{
vehicle@ temp = map.vs[v];
if (temp.health <= 0) continue;
if (temp.rx < tminx) continue;
if (temp.rx > tmaxx) continue;
if (temp.ry < tminy) continue;
if (temp.ry > tmaxy) continue;
if (temp.rz < tminz) continue;
if (temp.rz > tmaxz) continue;
return true_t;
}
return false_t;
}

void gate_update(mapdata@ map)
{
string hb, hbv, hs;
switch (attack_mode)
{
case 2:
{
hb = "소거의 지뢰";
hbv = "소거의 지뢰";
hs = "minestep1";
}
break; case 1:
{
hb = "internal:trap";
hbv = "internal:trap_v";
hs = "quizno";
}
break; default:
break;
}
minx += plus_x;
maxx += plus_x;
center_x += plus_x;
miny += plus_y;
maxy += plus_y;
center_y += plus_y;
minz += plus_z;
maxz += plus_z;
center_z += plus_z;
plus_x *= -1;
plus_y *= -1;
plus_z *= -1;
int playerslength = map.players.length;
for (uint x = 0; x < playerslength; x++)
{
    player@ temp = map.players[x];
    temp.sendpacket("changetile " + gate_rawdata, 4);
    if (attack_mode == 0) continue;
    if (temp.health <= 0) continue;
    if (temp.invinsible) continue;
    if (temp.hidden) continue;
    if (temp.rx < minx) continue;
    if (temp.rx > maxx) continue;
    if (temp.ry < miny) continue;
    if (temp.ry > maxy) continue;
    if (temp.z < minz) continue;
    if (temp.z > maxz) continue;
    if (temp.rank != 5) {
        temp.death = true;
        temp.hitby = hb;
        temp.sendsound(hs);
        temp.should_subtract = true;
    }
}
int vslength = map.vs.length;
for (uint v = 0; v < vslength; v++)
{
vehicle@ temp = map.vs[v];
if (temp.inside !is null) sendmap("changevtile " + gate_rawdata, temp.inside, 4);
if (temp.health <= 0) continue;
if (temp.rx < minx) continue;
if (temp.rx > maxx) continue;
if (temp.ry < miny) continue;
if (temp.ry > maxy) continue;
if (temp.rz < minz) continue;
if (temp.rz > maxz) continue;
if (attack_mode == 0)
{
if (slidedir > -1)
{
if (temp.slidedir == -1) temp.slidetimer.force(0);
temp.ctile = type;
temp.slidetime = slidetime;
temp.slidedir = slidedir;
}
continue;
}
temp.health = -1000000000;
temp.hitby = hbv;
if (temp.inside !is null)
{
int inpl = temp.inside.players.length;
for (uint x = 0; x < inpl; x++)
{
    player@ inp = temp.inside.players[x];
    if (inp.invinsible) continue;
    if (inp.hidden) continue;
    if (inp.rank != 5) {
        inp.death = true;
        inp.hitby = hb;
        inp.sendsound(hs);
        inp.should_subtract = true;
    }
}
}
}
int robotslength = map.robots.length;
for (uint r = 0; r < robotslength; r++)
{
Robot@ temp = map.robots[r];
if (temp.health <= 0) continue;
if (temp.rx < minx) continue;
if (temp.rx > maxx) continue;
if (temp.ry < miny) continue;
if (temp.ry > maxy) continue;
if (temp.z < minz) continue;
if (temp.z > maxz) continue;
if (attack_mode == 0)
{
if (slidedir > -1)
{
if (temp.slidedir == -1) temp.slidetimer.force(0);
temp.slidetime = slidetime;
temp.slidedir = slidedir;
}
continue;
}
temp.health = -1000000000;
}
if (attack_mode > 0)
{
int hobjslength = map.hobjs.length;
for (uint i2 = 0; i2 < hobjslength; i2++)
{
hittable@ temp = map.hobjs[i2];
if (temp.health <= 0) continue;
if (temp.x < minx) continue;
if (temp.x > maxx) continue;
if (temp.y < miny) continue;
if (temp.y > maxy) continue;
if (temp.z < minz) continue;
if (temp.z > maxz) continue;
temp.health = -1000000000;
temp.hitby = hbv;
}
}
gate_rawdata = this.minx + " " + this.maxx + " " + this.miny + " " + this.maxy + " " + this.minz + " " + this.maxz + " " + this.type + " " + this.plus_x + " " + this.plus_y + " " + this.plus_z + " " + this.slidetime + " " + this.slidedir + (this.hazard ? " hazard" : empty);
}
} // class.maptile.

void press_switch(int minx, int maxx, int miny, int maxy, int minz, int maxz, mapdata@ map)
{
double center_x = (minx + maxx) * 0.5;
double size_x = abs(center_x - minx);
double center_y = (miny + maxy) * 0.5;
double size_y = abs(center_y - miny);
double center_z = (minz + maxz) * 0.5;
double size_z = abs(center_z - minz);
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (abs(temp.center_x - center_x) > (temp.size_x + size_x)) continue;
if (abs(temp.center_y - center_y) > (temp.size_y + size_y)) continue;
if (abs(temp.center_z - center_z) > (temp.size_z + size_z)) continue;
switch (temp.mode)
{
case GATE_OPEN:
{
if (temp.closereadytime < 0)
{
if (temp.is_on_tile(map)) continue;
}
temp.mode = GATE_CLOSING;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.close_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_OPENING:
{
temp.mode = GATE_CLOSE;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.close_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_CLOSE:
{
if (temp.openreadytime < 0)
{
if (temp.is_on_tile(map)) continue;
}
temp.mode = GATE_OPENING;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.open_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break; case GATE_CLOSING:
{
temp.mode = GATE_OPEN;
temp.walkingtimer.force(0);
sendmap("play_3ds " + temp.open_sound + " " + temp.oldminx + " " + temp.oldmaxx + " " + temp.oldminy + " " + temp.oldmaxy + " " + temp.oldminz + " " + temp.oldmaxz, map, 4);
}
break;
}
}
}

class mapispawn
{
int minx, maxx, miny, maxy, minz, maxz;
string[] mapobjs;
timer mapispawntimer;
int mapispawntime, mapiunspawntime;
int curobjs = 0, maxobjs = 1;
int limit = 0, limittime = 0;
bool limit_all = false;
timer limittimer;
dictionary limited;
bool reset_cycle = false;
bool adjustable = false;

int get_limit(player@ temp)
{
if (!limited.exists(temp.name)) return 0;
int current = 0;
if (!limited.get(temp.name, current))
{
limited.delete(temp.name);
return 0;
}
return current;
}

int get_limit_all(const string& in name)
{
if (!limited.exists(name)) return 0;
int current = 0;
if (!limited.get(name, current))
{
limited.delete(name);
return 0;
}
return current;
}
} // class.ispawn.

class str_collision
{
double x_length = 0.0;
double y_length = 0.0;
double z_length = 0.0;
double top_z = 0.0;
double bottom_z = 0.0;
double time = -1.0;
maptile@ handle;
hittable@ handle_hit;
}

str_collision@ get_collision_handle_parabola(double x, double y, double z, mapdata@ map, double speed, double accel, double x_y_deg, double z_deg, double origin_length, int floor_z = 0, const string &in name = empty)
{
str_collision new;
int name_size = name.size;
int search_mode = 0;
if (name_size > 0)
{
search_mode = 1;
if (name == "/") search_mode = 2;
}
double rise_time = 0.0, sink_time = 0.0, real_rise_time = 0.0;
new.z_length = sine(z_deg * pi180) * speed;
new.x_length = sine(x_y_deg * pi180) * speed * cosine(z_deg * pi180);
new.y_length = cosine(x_y_deg * pi180) * speed * cosine(z_deg * pi180);
bool rise = false;
double start_time = 0.0;
double find_size = 0.0;
double rise_top_z = 0.0;
if (new.z_length > 0.0)
{
rise = true;
rise_time = new.z_length / accel;
real_rise_time = rise_time;
rise_top_z = z + (0.5 * accel * rise_time * rise_time);
if (rise_time > origin_length)
{
double distance = rise_time - origin_length;
new.top_z = rise_top_z - (0.5 * accel * distance * distance);
rise_time = origin_length;
}
else
{
new.top_z = rise_top_z;
sink_time = origin_length - rise_time;
}
new.bottom_z = new.top_z - (0.5 * accel * sink_time * sink_time);
find_size = 1 / ((rise_time > sink_time ? rise_time : sink_time) * accel);
}
else
{
start_time = abs(new.z_length / accel);
sink_time = origin_length + start_time;
new.top_z = z + 0.5 * accel * start_time * start_time;
new.bottom_z = new.top_z - (0.5 * accel * sink_time * sink_time);
find_size = 1 / (sink_time * accel);
}
double minimum_size = accel / (speed > 1 ? speed : 1);
if (find_size > minimum_size) find_size = minimum_size;
int max_z = (rise ?  round(new.top_z, 0) : round(z, 0));
int min_z = (z < new.bottom_z ? round(z, 0) : round(new.bottom_z, 0));
int real_z = round(z, 0);
double start_x = (rise ? x + (new.x_length * rise_time) : x - (new.x_length * start_time));
double start_y = (rise ? y + (new.y_length * rise_time) : y - (new.y_length * start_time));
double end_x = x + (new.x_length * origin_length);
double end_y = y + (new.y_length * origin_length);
int real_x = (x < end_x ? round(x, 0) : round(end_x, 0));
int real_y = (y < end_y ? round(y, 0) : round(end_y, 0));
int real_end_x = (x > end_x ? round(x, 0) : round(end_x, 0));
int real_end_y = (y > end_y ? round(y, 0) : round(end_y, 0));
double center_x = (real_x + real_end_x) * 0.5;
double center_y = (real_y + real_end_y) * 0.5;
double center_z = (min_z + max_z) * 0.5;
double size_x = abs(real_x - center_x);
double size_y = abs(real_y - center_y);
double size_z = abs(min_z - center_z);
maptile[]@ mg = map.mapgates, mt = map.maptiles;
int mgl = mg.length;
int mtl = mt.length;
for (int j = (mtl + mgl) -1; j > -1; j--)
{
maptile@ temp = (j >= mtl ? mg : mt)[j - (j >= mtl ? mtl : 0)];
if (search_mode == 0)
{
if (!temp.is_wall)
{
if (new.time == -1.0)
{
if (real_x >= temp.minx and real_end_x <= temp.maxx and real_y >= temp.miny and real_end_y <= temp.maxy and min_z >= temp.minz and max_z <= temp.maxz)
{
new.time = origin_length;
return new;
}
}
continue;
}
}
else if (search_mode == 1)
{
if (string_left(temp.type, name_size) != name) continue;
}
if (abs(center_x - temp.center_x) > (size_x + temp.size_x)) continue;
if (abs(center_y - temp.center_y) > (size_y + temp.size_y)) continue;
if (abs(center_z - temp.center_z) > (size_z + temp.size_z)) continue;
bool found = false;
if (rise and temp.maxz >= real_z)
{
double start_position = 0;
double end_position = new.top_z - z;
double final_position = -1;
for (; (end_position - start_position) >= find_size; )
{
double central_position = (start_position + end_position) * 0.5;
int central_z = round(z + central_position, 0);
if (temp.minz > central_z)
{
start_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
end_position = central_position;
continue;
}
double time = real_rise_time - (2 * abs(rise_top_z - (z + central_position)) / accel) ** 0.5;
int central_x = round(x + (new.x_length * time), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(y + (new.y_length * time), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
if (final_position > -1)
{
double central_z = z + final_position;
double time = real_rise_time - (2 * abs(rise_top_z - central_z) / accel) ** 0.5;
if (new.time == -1.0 or new.time > time)
{
new.time = time;
@ new.handle = temp;
found = true;
}
}
}
if (found) continue;
if (rise)
{
if (new.time >= 0.0 and new.time <= rise_time) continue;
if (real_rise_time >= origin_length) continue;
}
double start_position = (rise ? 0 : new.top_z - z);
double end_position = new.top_z - new.bottom_z;
double final_position = -1;
for (; (end_position - start_position) >= find_size; )
{
double central_position = (start_position + end_position) * 0.5;
int central_z = round(new.top_z - central_position, 0);
if (temp.minz > central_z)
{
end_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
start_position = central_position;
continue;
}
double time = (2 * abs(central_position) / accel) ** 0.5;
int central_x = round(start_x + (new.x_length * time), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(start_y + (new.y_length * time), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
if (final_position > -1)
{
double central_z = new.top_z - final_position;
double time = (2 * abs(new.top_z - central_z) / accel) ** 0.5 + (rise ? rise_time : -start_time);
if (new.time == -1.0 or new.time > time)
{
new.time = time;
@ new.handle = temp;
}
}
}
if (new.time == -1.0)
{
double length = new.top_z - floor_z;
if (length < 0)
{
new.time = -1.0;
return new;
}
double length2 = z - floor_z;
if (length2 < 0)
{
new.time = (rise ? real_rise_time - (2 * (rise_top_z - floor_z) / accel) ** 0.5 : -1.0);
return new;
}
new.time = (2 * length / accel) ** 0.5 + (rise ? rise_time : -start_time);
return new;
}
if (new.handle_hit !is null and new.handle !is null) @ new.handle_hit = null;
return new;
}

str_collision@ get_collision_handle_straight(double x, double y, double z, mapdata@ map, double origin_length, double x_y_deg, double z_deg, int floor_z = 0, bool check_hittable = true, const string &in name = empty)
{
str_collision new;
int name_size = name.size;
int search_mode = 0;
if (name_size > 0)
{
search_mode = 1;
if (name == "/") search_mode = 2;
}
new.z_length = sine(z_deg * pi180);
new.x_length = sine(x_y_deg * pi180) * cosine(z_deg * pi180);
new.y_length = cosine(x_y_deg * pi180) * cosine(z_deg * pi180);
double end_x = x + (new.x_length * origin_length);
double end_y = y + (new.y_length * origin_length);
double end_z = z + (new.z_length * origin_length);
int real_x = (x < end_x ? round(x, 0) : round(end_x, 0));
int real_y = (y < end_y ? round(y, 0) : round(end_y, 0));
int real_z = (z < end_z ? round(z, 0) : round(end_z, 0));
int real_end_x = (x > end_x ? round(x, 0) : round(end_x, 0));
int real_end_y = (y > end_y ? round(y, 0) : round(end_y, 0));
int real_end_z = (z > end_z ? round(z, 0) : round(end_z, 0));
double center_x = (real_x + real_end_x) * 0.5;
double center_y = (real_y + real_end_y) * 0.5;
double center_z = (real_z + real_end_z) * 0.5;
double size_x = abs(real_x - center_x);
double size_y = abs(real_y - center_y);
double size_z = abs(real_z - center_z);
if (check_hittable)
{
for (int i = map.hobjs.length-1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if ((search_mode == 0 ? !temp.is_wall : search_mode == 1 ? string_left(temp.tile, name_size) != name : false)) continue;
double length = (new.x_length > 0.0 ? abs(abs(temp.x - x) / new.x_length) : new.y_length > 0.0 ? abs(abs(temp.y - y) / new.y_length) : abs(abs(temp.z - z) / new.z_length));
if (temp.x != round(x + (new.x_length * length), 0)) continue;
if (temp.y != round(y + (new.y_length * length), 0)) continue;
if (temp.z != round(z + (new.z_length * length), 0)) continue;
if (round(length, 0) == 0.0)
{
new.time = 0.0;
@ new.handle_hit = temp;
return new;
}
if (new.time > -1.0 and new.time <= length) continue;
new.time = length;
@ new.handle_hit = temp;
}
}
maptile[]@ mg = map.mapgates, mt = map.maptiles;
int mgl = mg.length;
int mtl = mt.length;
for (int j = (mtl + mgl) -1; j > -1; j--)
{
maptile@ temp = (j >= mtl ? mg : mt)[j - (j >= mtl ? mtl : 0)];
if (search_mode == 0)
{
if (!temp.is_wall)
{
if (new.time == -1.0)
{
if (real_x >= temp.minx and real_end_x <= temp.maxx and real_y >= temp.miny and real_end_y <= temp.maxy and real_z >= temp.minz and real_end_z <= temp.maxz)
{
new.time = origin_length;
return new;
}
}
continue;
}
}
else if (search_mode == 1)
{
if (string_left(temp.type, name_size) != name) continue;
}
if (abs(center_x - temp.center_x) > (size_x + temp.size_x)) continue;
if (abs(center_y - temp.center_y) > (size_y + temp.size_y)) continue;
if (abs(center_z - temp.center_z) > (size_z + temp.size_z)) continue;
int start_position = 0;
int end_position = origin_length;
int final_position = -1;
for (; (end_position - start_position) > 1; )
{
int central_position = (start_position + end_position) >> 1;
int central_x = round(x + (new.x_length * central_position), 0);
if (temp.minx > central_x)
{
new.x_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxx < central_x)
{
new.x_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_y = round(y + (new.y_length * central_position), 0);
if (temp.miny > central_y)
{
new.y_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxy < central_y)
{
new.y_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
int central_z = round(z + (new.z_length * central_position), 0);
if (temp.minz > central_z)
{
new.z_length >= 0 ? start_position = central_position : end_position = central_position;
continue;
}
if (temp.maxz < central_z)
{
new.z_length >= 0 ? end_position = central_position : start_position = central_position;
continue;
}
end_position = central_position;
if (final_position == -1 or final_position > central_position) final_position = central_position;
}
for (uint i = end_position; i >= start_position; i--)
{
int central_x = round(x + (new.x_length * i), 0);
if (temp.minx > central_x) continue;
if (temp.maxx < central_x) continue;
int central_y = round(y + (new.y_length * i), 0);
if (temp.miny > central_y) continue;
if (temp.maxy < central_y) continue;
int central_z = round(z + (new.z_length * i), 0);
if (temp.minz > central_z) continue;
if (temp.maxz < central_z) continue;
if (final_position == -1 or final_position > i) final_position = i;
}
if (final_position < 0) continue;
if (final_position == 0)
{
new.time = 0.0;
@ new.handle_hit = null;
@ new.handle = temp;
return new;
}
if (new.time > -1.0 and new.time <= final_position) continue;
new.time = final_position;
@ new.handle = temp;
}
if (new.time == -1.0)
{
double temp_length = round(z - floor_z, 0);
if (temp_length < 1)
{
new.time = -1.0;
return new;
}
double max_z = z + (origin_length * new.z_length);
if (floor_z > max_z)
{
new.time = (z - floor_z) / abs(new.z_length);
return new;
}
new.time = origin_length;
return new;
}
if (new.handle_hit !is null and new.handle !is null) @ new.handle_hit = null;
return new;
}

const string& get_tile_at(int x, int y, int z, mapdata@ map, bool check_obj = true)
{
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (temp.x != x) continue;
if (temp.y != y) continue;
if (temp.z != z) continue;
ref_string = temp.tile;
return ref_string;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
if (map.mapgates[i].is_on_tile(x, y, z))
{
ref_string = map.mapgates[i].type;
return ref_string;
}
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
if (map.maptiles[i].is_on_tile(x, y, z))
{
ref_string = map.maptiles[i].type;
return ref_string;
}
}
return empty;
}

maptile@ get_tile_handle_at(int x, int y, int z, mapdata@ map, bool check_obj = true)
{
bool fallable = false;
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (temp.z > z) continue;
if (temp.x != x) continue;
if (temp.y != y) continue;
fallable = true;
if (temp.z != z) continue;
maptile new;
new.type = temp.tile;
new.is_wall = temp.is_wall;
return new;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
maptile@ temp = map.maptiles[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
return fallable ? maptile() : null;
}

bool& is_fallable(double x, double y, double z, mapdata@ map, bool check_obj = true)
{
x = round(x, 0);
y = round(y, 0);
z = round(z, 0);
if (check_obj)
{
for (int i = map.hobjs.length - 1; i > -1; i--)
{
hittable@ temp = map.hobjs[i];
if (temp.tile.is_empty()) continue;
if (x != temp.x) continue;
if (y != temp.y) continue;
if (z == temp.z) return false_t;
}
}
for (int i = map.mapgates.length - 1; i > -1; i--)
{
maptile@ temp = map.mapgates[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
return false_t;
}
for (int i = map.maptiles.length - 1; i > -1; i--)
{
maptile@ temp = map.maptiles[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
return false_t;
}
return true_t;
}

bool& is_no_item(double x, double y, int z, mapdata@ map, const string& in name = empty)
{
bool noname = name.is_empty();
x = round(x, 0);
y = round(y, 0);
for (int i = map.mapnoitems.length - 1; i > -1; i--)
{
mapnoitem@ temp = map.mapnoitems[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (noname) return true_t;
if (temp.items.exists(name)) return true_t;
if (temp.flags & noitem_weapon > 0)
{
if (weapon_list.exists(name)) return true_t;
}
if (temp.flags & noitem_vehicle > 0)
{
if (vehicledict.exists(name)) return true_t;
}
if (temp.flags & noitem_snack > 0)
{
if (snackitems.exists(name)) return true_t;
}
if (temp.flags & noitem_trap > 0)
{
if (trapitems.exists(name)) return true_t;
}
if (temp.flags & noitem_ammo > 0)
{
if (ammolist.exists(name)) return true_t;
}
if (temp.flags & noitem_explode > 0)
{
if (splash_list.exists(name)) return true_t;
}
}
return false_t;
}

const string& get_zone_at(int x, int y, int z, mapdata@ map)
{
for (int i = map.mapzones.length - 1; i > -1; i--)
{
if (map.mapzones[i].is_on_zone(x, y, z))
{
ref_string = map.mapzones[i].text;
return ref_string;
}
}
return "미확인 지역";
}

const string& get_map_data(mapdata@ map, const string& in data)
{
string[]@ mdata = string_split(map.rawdata, "\r\n", true);
int mdatalength = mdata.length;
for (uint i = 0; i < mdatalength; i++)
{
string[]@ p = string_split(mdata[i], ":", true);
if (p[0] == data)
{
ref_string = string_replace(mdata[i], data + ":", empty, false);
return ref_string;
}
}
return empty;
}

void init_mapsystem()
{
maps.resize(0);
string[]@ mapfiles = find_files("./maps/*.map");
int mapfileslength = mapfiles.length;
for (uint i = 0; i < mapfileslength; i++)
{
create_map(string_replace(mapfiles[i], ".map", empty, true));
}
}

mapdata@ create_map(const string& in name, bool is_file = true)
{
mapdata temp;
temp.internal_load(name, is_file, false);
maps.insert_last(temp);
map_list.set(name, @ temp);
return temp;
}

mapdata@ get_map_handle(const string& in name)
{
if (!map_list.exists(name)) return null;
mapdata@ temp;
map_list.get(name, @ temp);
return temp;
}

bool& is_editable_map(mapdata@ map, player@ this)
{
if (map.is_vehicle) return false_t;
if (map.remove) return false_t;
if (map.public == 1) return true_t;
if (this.rank > 0) return true_t;
if (map.owner.exists(this.name)) return true_t;
return false_t;
}

bool& is_tile_water(int x, int y, int z, mapdata@ map)
{
string tilecheck = get_tile_at(x, y, z, map);
if (tilecheck.is_empty()) return false_t;
int watertileslength = watertiles.length;
for (uint i = 0; i < watertileslength; i++)
{
if (string_contains(tilecheck, watertiles[i], 1) > -1) return true_t;
}
return false_t;
}

int get_tile_type (int x, int y, int z, mapdata@ map)
{
string tid = get_tile_at(x, y, z, map);
if (tid.is_empty()) return TILE_NONE;
if (string_left(tid, 4) == "wall") return TILE_WALL;
return TILE_TILE;
}

bool& is_travelpoint(int x, int y, int z, mapdata@ map)
{
int mplength = map.maptravels.length;
for (uint i = 0; i < mplength; i++)
{
if (map.maptravels[i].is_on_travelpoint(x, y, z)) return true_t;
}
return false_t;
}

void add_map_line(mapdata@ this, const string& in option, const string& in old, const string& in new)
{
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":" + old + "\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + option + ":" + new + "\r\n";
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

void save_map_toggle(mapdata@ this, const string& in option, int toggle)
{
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":0\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":1\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\n" + option + ":2\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + option + ":" + toggle + "\r\n";
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

void save_map_starting(mapdata@ this, int x, int y, int z)
{
this.rawdata = string_replace(this.rawdata, "\r\nstartingx:" + this.starting.x + "\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\nstartingy:" + this.starting.y + "\r\n", "\r\n", true);
this.rawdata = string_replace(this.rawdata, "\r\nstartingz:" + this.starting.z + "\r\n", "\r\n", true);
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + "startingx:" + x + "\r\nstartingy:" + y + "\r\nstartingz:" + z + "\r\n";
this.starting.x = x;
this.starting.y = y;
this.starting.z = z;
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
}

int save_map_owner(mapdata@ this, string username)
{
int result = 1;
if (this.owner.exists(username))
{
if (this.owner.size == 1) return 0;
this.owner.delete(username);
result = 2;
}
else
{
if (!file_exists("./chars/" + username + ".usr")) return 0;
this.owner.set(username, 0);
}
if (!this.owner_rd.is_empty()) this.rawdata = string_replace(this.rawdata, this.owner_rd, "\r\n", true);
this.owner_rd = "owner:" + array_to_string(this.owner.keys, ",") + "\r\n";
this.rawdata += (string_right(this.rawdata, 2) == "\r\n" ? empty : "\r\n") + this.owner_rd;
fl.open("./maps/" + this.name + ".map", "wb");
fl.write(this.rawdata);
fl.close();
return result;
}

void mapupdate(const string& in map)
{
mapdata@ mi = get_map_handle(map);
if (mi is null) return;
mi.internal_load(mi.name, true);
string mess;
int gateslength = mi.mapgates.length;
for (uint i = 0; i < gateslength; i++)
{
maptile@ temp = mi.mapgates[i];
mess += temp.gate_rawdata + "[]";
}
int playerslength = mi.players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = mi.players[i];
temp.sendpacket("m_data x:" + temp.x + "\r\ny:" + temp.y + "\r\nz:" + temp.z + "\r\n" + mi.rawdata + "\r\n");
temp.sendpacket("resizegate", 4);
if (!mess.is_empty()) temp.sendpacket("spawngate " + mess, 4);
}
int vslength = mi.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = mi.vs[i];
if (temp.inside is null) continue;
sendmap("vdata " + mi.rawdata, temp.inside, 0);
sendmap("resizegate_v", temp.inside, 4);
if (!mess.is_empty()) sendmap("spawngate_v " + mess, temp.inside, 4);
}
}

void save_public_maps()
{
string text;
int plength = public_maps.length;
for (uint i = 0; i < plength; i++)
{
if (i > 0) text += "\r\n";
text += public_maps[i].name;
}
fl.open("./prefs/save.map", "wb");
fl.write(text);
fl.close();
}

void load_public_maps()
{
fl.open("./prefs/save.map", "rb");
string[]@ items = string_split(fl.read(), "\r\n", true);
fl.close();
int plength = items.length;
for (uint i = 0; i < plength; i++)
{
mapdata@ temp = get_map_handle(items[i]);
if (temp !is null) public_maps.insert_last(temp);
}
}

string check_mapdata_errors(string message, player@ this, mapdata@ map)
{
string[]@ lines = string_split(message, "\r\n", true);
string dt, dt2, colon = ":";
int lineslength = lines.length;
for (uint i = 0; i < lineslength; i++)
{
string[]@ params = string_split(lines[i], colon, false);
if (params[0] == "travelpoint")
{
if (params.length < 12) continue;
if (map.name != params[7])
{
mapdata@ index = get_map_handle(params[7]);
if (index is null)
{
this.alert("없는 맵으로 포탈을 뚫을 순 없습니다.");
return empty;
}
if (this.rank < 1)
{
if (map.survival != index.survival)
{
this.alert("서바이벌 맵과 일반 맵 사이에 포탈을 뚫을 수는 없습니다.");
return empty;
}
if (!index.owner.exists(this.name))
{
this.alert("포탈의 도착 맵의 개발자 목록에 등록되어있지 않아 작업을 계속할 수 없습니다. 먼저 해당 맵의 개발자 권한을 얻으시기 바랍니다.");
return empty;
}
}
}
}
else if (params[0] == "ispawn")
{
if (this.rank > 0) continue;
int pl = params.length;
if (pl < 13) continue;
int am = string_to_number(params[7]);
if (am > 5)
{
this.alert("그렇게 많이 소환할 수는 없습니다.");
return empty;
}
if (am < -5)
{
this.alert("그렇게 많이 소환할 수는 없습니다.");
return empty;
}
if (map.survival == 1) continue;
if (pl == 13)
{
if (params[12] == "s_flag") continue;
if (params[12] == "r_flag") continue;
}
dt.resize(0);
dt2.resize(0);
for (uint j = 12; j < pl; j++)
{
if (j > 12)
{
dt += colon;
dt2 += colon;
}
dt += params[j] + "_";
dt2 += params[j];
}
message = string_replace(message, dt2, dt, false);
}
}
return message;
}

funcdef void map_hash(string[]@ parsed, mapdata@ this, bool is_add = false);
dictionary map_handles;

void install_map_hash()
{
map_handles.set("tile", @ map_hash_tile);
map_handles.set("gate", @ map_hash_gate);
map_handles.set("zone", @ map_hash_zone);
map_handles.set("vending_machine", @ map_hash_vending_machine);
map_handles.set("door", @ map_hash_door);
map_handles.set("ispawn", @ map_hash_ispawn);
map_handles.set("noitem", @ map_hash_noitem);
map_handles.set("mapname", @ map_hash_mapname);
map_handles.set("owner", @ map_hash_owner);
map_handles.set("maxx", @ map_hash_maxx);
map_handles.set("maxy", @ map_hash_maxy);
map_handles.set("startingx", @ map_hash_startingx);
map_handles.set("startingy", @ map_hash_startingy);
map_handles.set("startingz", @ map_hash_startingz);
map_handles.set("fightingstate", @ map_hash_fightingstate);
map_handles.set("travelpoint", @ map_hash_travelpoint);
map_handles.set("robots", @ map_hash_robots);
map_handles.set("no_teamhit", @ map_hash_no_teamhit);
map_handles.set("public", @ map_hash_public);
map_handles.set("no_coord", @ map_hash_no_coord);
map_handles.set("no_seethrough", @ map_hash_no_seethrough);
map_handles.set("no_chat", @ map_hash_no_chat);
map_handles.set("no_teleport", @ map_hash_no_teleport);
map_handles.set("no_recall", @ map_hash_no_recall);
map_handles.set("ctf", @ map_hash_ctf);
map_handles.set("enter_sound", @ map_hash_enter_sound);
map_handles.set("leave_sound", @ map_hash_leave_sound);
map_handles.set("move_start_sound", @ map_hash_move_start_sound);
map_handles.set("move_end_sound", @ map_hash_move_end_sound);
map_handles.set("limit", @ map_hash_limit);
map_handles.set("pan", @ map_hash_pan_step);
map_handles.set("no_tracking", @ map_hash_no_tracking);
map_handles.set("no_corpse", @ map_hash_no_corpse);
map_handles.set("tunnel_sight", @ map_hash_tunnel_sight);
map_handles.set("respawn", @ map_hash_respawn_mode);
map_handles.set("respawn_z", @ map_hash_respawn_z);
map_handles.set("survival", @ map_hash_survival);
map_handles.set("starting_items", @ map_hash_starting_items);
map_handles.set("bd", @ map_hash_bd);
}

void map_hash_tile(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
maptile temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = parsed[7];
temp.is_wall = (string_left(temp.type, 4) == "wall");
if (parsed.length > 9)
{
temp.slidedir = string_to_number(parsed[8]);
temp.slidetime = string_to_number(parsed[9]);
}
if (this.max.z < temp.maxz) this.max.z = temp.maxz;
if (this.min.z > temp.minz) this.min.z = temp.minz;
this.maptiles.insert_last(temp);
}
void map_hash_gate(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 17) return;
maptile temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = parsed[7];
temp.is_wall = (string_left(temp.type, 4) == "wall");
temp.attack_mode = (temp.type == "mine" ? 2 : temp.is_wall ? 1 : 0);
temp.open_sound = parsed[10];
temp.close_sound = parsed[13];
temp.opentime = string_to_number(parsed[8]);
temp.closetime = string_to_number(parsed[11]);
temp.openreadytime = string_to_number(parsed[9]);
temp.closereadytime = string_to_number(parsed[12]);
temp.plus_x = string_to_number(parsed[14]);
temp.plus_y = string_to_number(parsed[15]);
temp.plus_z = string_to_number(parsed[16]);
temp.mode = GATE_CLOSE;
temp.oldminx = temp.minx;
temp.oldmaxx = temp.maxx;
temp.oldminy = temp.miny;
temp.oldmaxy = temp.maxy;
temp.oldminz = temp.minz;
temp.oldmaxz = temp.maxz;
if (parsed.length > 18)
{
temp.slidedir = string_to_number(parsed[17]);
temp.slidetime = string_to_number(parsed[18]);
}
temp.hazard = (parsed.length == 20 or parsed.length == 18);
temp.gate_rawdata = temp.minx + " " + temp.maxx + " " + temp.miny + " " + temp.maxy + " " + temp.minz + " " + temp.maxz + " " + temp.type + " " + temp.plus_x + " " + temp.plus_y + " " + temp.plus_z + " " + temp.slidetime + " " + temp.slidedir + (temp.hazard ? " hazard" : empty);
if (is_add)
{
sendmap("spawngate " + temp.gate_rawdata, this, 4);
int vslength = this.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = this.vs[i];
if (v.inside is null) continue;
sendmap("spawngate_v " + temp.gate_rawdata, v.inside, 4);
}
}
this.mapgates.insert_last(temp);
}
void map_hash_zone(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
mapzone temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.text = parsed[7];
temp.trackable = (parsed.length >= 8);
this.mapzones.insert_last(temp);
}
void map_hash_travelpoint(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 13) return;
maptravel temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
this.maptravels.insert_last(temp);
}
void map_hash_vending_machine(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 6) return;
spawn_vending_machine(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), this, parsed[4], parsed[5]);
}
void map_hash_starting_items(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 2) return;
this.starting_items = text_to_dictionary(parsed[1], ",", VALUE_DOUBLE, ";");
}
void map_hash_door(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 14) return;
mapdoor temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
this.mapdoors.insert_last(temp);
}
void map_hash_ispawn(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 13) return;
mapispawn temp;
temp.minx = string_to_number(parsed[1]);
temp.maxx = string_to_number(parsed[2]);
temp.miny = string_to_number(parsed[3]);
temp.maxy = string_to_number(parsed[4]);
temp.minz = string_to_number(parsed[5]);
temp.maxz = string_to_number(parsed[6]);
temp.maxobjs = string_to_number(parsed[7]);
if (temp.maxobjs < 0)
{
temp.adjustable = true;
temp.maxobjs = abs(temp.maxobjs);
}
temp.mapispawntime = string_to_number(parsed[8]);
temp.mapiunspawntime = string_to_number(parsed[9]);
temp.limit = string_to_number(parsed[10]);
if (parsed[10] == "a")
{
temp.reset_cycle = true;
temp.limit = -1;
}
temp.limit_all = (temp.limit < 0);
temp.limit = abs(temp.limit);
temp.limittime = string_to_number(parsed[11]);
int pl = parsed.length - 1;
temp.mapobjs.reserve(pl - 10);
for (uint x = pl; x > 11; x--)
{
temp.mapobjs.insert_last(parsed[x]);
}
this.mapispawns.insert_last(temp);
}
void map_hash_robots(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 10) return;
maprspawn new;
new.minx = string_to_number(parsed[1]);
new.maxx = string_to_number(parsed[2]);
new.miny = string_to_number(parsed[3]);
new.maxy = string_to_number(parsed[4]);
new.minz = string_to_number(parsed[5]);
new.maxz = string_to_number(parsed[6]);
new.maxrobots = string_to_number(parsed[7]);
if (new.maxrobots < 0)
{
new.adjustable = true;
new.maxrobots = abs(new.maxrobots);
}
new.spawntime = string_to_number(parsed[8]);
new.list = string_split(parsed[9], ",", true);
if (parsed.length > 10) new.tile = parsed[10];
if (new.tile == ".") new.tile.resize(0);
if (parsed.length > 11) new.group = string_to_number(parsed[11]);
this.maprspawns.insert_last(new);
}
void map_hash_noitem(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
mapnoitem new;
new.minx = string_to_number(parsed[1]);
new.maxx = string_to_number(parsed[2]);
new.miny = string_to_number(parsed[3]);
new.maxy = string_to_number(parsed[4]);
new.minz = string_to_number(parsed[5]);
new.maxz = string_to_number(parsed[6]);
int pl = parsed.length;
for (uint x = 7; x < pl; x++) new.items.set(parsed[x], 0);
if (new.items.exists("무기")) new.flags += noitem_weapon;
if (new.items.exists("차량")) new.flags += noitem_vehicle;
if (new.items.exists("식음료")) new.flags += noitem_snack;
if (new.items.exists("함정")) new.flags += noitem_trap;
if (new.items.exists("탄약")) new.flags += noitem_ammo;
if (new.items.exists("폭발물")) new.flags += noitem_explode;
this.mapnoitems.insert_last(new);
}
void map_hash_mapname(string[]@ parsed, mapdata@ this, bool is_add = false) {this.name = parsed[1]; }
void map_hash_owner(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.owner_rd = "owner:" + parsed[1] + "\r\n";
this.owner = array_to_dictionary(string_split(parsed[1], ",", false));
}
void map_hash_maxx(string[]@ parsed, mapdata@ this, bool is_add = false) {this.max.x = string_to_number(parsed[1]); }
void map_hash_maxy(string[]@ parsed, mapdata@ this, bool is_add = false) {this.max.y = string_to_number(parsed[1]); }
void map_hash_startingx(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.x = string_to_number(parsed[1]); }
void map_hash_startingy(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.y = string_to_number(parsed[1]); }
void map_hash_startingz(string[]@ parsed, mapdata@ this, bool is_add = false) {this.starting.z = string_to_number(parsed[1]); }
void map_hash_fightingstate(string[]@ parsed, mapdata@ this, bool is_add = false) {this.fighting = string_to_number(parsed[1]); }
void map_hash_public(string[]@ parsed, mapdata@ this, bool is_add = false) {this.public = string_to_number(parsed[1]); }
void map_hash_no_tracking(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_tracking = string_to_number(parsed[1]); }
void map_hash_no_corpse(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_corpse = string_to_number(parsed[1]); }
void map_hash_respawn_mode(string[]@ parsed, mapdata@ this, bool is_add = false) {this.respawn_mode = string_to_number(parsed[1]); }
void map_hash_respawn_z(string[]@ parsed, mapdata@ this, bool is_add = false) {this.respawn_z = string_to_number(parsed[1]); }
void map_hash_survival(string[]@ parsed, mapdata@ this, bool is_add = false) {this.survival = string_to_number(parsed[1]); }
void map_hash_tunnel_sight(string[]@ parsed, mapdata@ this, bool is_add = false) {this.tunnel_sight = string_to_number(parsed[1]); }
void map_hash_no_teamhit(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_teamhit = string_to_number(parsed[1]); }
void map_hash_no_coord(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_coord = string_to_number(parsed[1]); }
void map_hash_no_seethrough(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_seethrough = string_to_number(parsed[1]); }
void map_hash_no_chat(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_chat = string_to_number(parsed[1]); }
void map_hash_no_teleport(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_teleport = string_to_number(parsed[1]); }
void map_hash_no_recall(string[]@ parsed, mapdata@ this, bool is_add = false) {this.no_recall = string_to_number(parsed[1]); }
void map_hash_ctf(string[]@ parsed, mapdata@ this, bool is_add = false)
{
if (parsed.length < 8) return;
ctf temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
int type = string_to_number(parsed[7]);
switch (type)
{
case 1:
this.ctf_sdest.insert_last(temp);
break;
case 2:
this.ctf_rdest.insert_last(temp);
break;
}
}
void map_hash_enter_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.enter_sound = parsed[1]; }
void map_hash_leave_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.leave_sound = parsed[1]; }
void map_hash_move_start_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.move_start_sound = parsed[1]; }
void map_hash_move_end_sound(string[]@ parsed, mapdata@ this, bool is_add = false) {this.move_end_sound = parsed[1]; }
void map_hash_limit(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.limit.resize(0);
int pl = parsed.length;
for (uint i = 1; i < pl; i++)
{
if (i > 1) this.limit += " ";
this.limit += parsed[i];
}
}
void map_hash_pan_step(string[]@ parsed, mapdata@ this, bool is_add = false)
{
this.pan_step = string_to_number(parsed[1]);
if (this.pan_step < 0.01) this.pan_step = 0.01;
}
void map_hash_bd(string[]@ parsed, mapdata@ this, bool is_add = false) {this.boundary_volume = string_to_number(parsed[1]); }

funcdef void maporder_hash(string[]@ parsed, mapdata@ temp, player@ this);
dictionary maporder_handles;

void install_maporder_hash()
{
maporder_handles.set("이", @ maporder_hash_name);
maporder_handles.set("이름", @ maporder_hash_name);
maporder_handles.set("시", @ maporder_hash_sp);
maporder_handles.set("시작", @ maporder_hash_sp);
maporder_handles.set("시작점", @ maporder_hash_sp);
maporder_handles.set("입", @ maporder_hash_es);
maporder_handles.set("입장", @ maporder_hash_es);
maporder_handles.set("퇴", @ maporder_hash_ls);
maporder_handles.set("퇴장", @ maporder_hash_ls);
maporder_handles.set("이동시", @ maporder_hash_mss);
maporder_handles.set("이동시작", @ maporder_hash_mss);
maporder_handles.set("이동끝", @ maporder_hash_mes);
maporder_handles.set("개", @ maporder_hash_owner);
maporder_handles.set("개발", @ maporder_hash_owner);
maporder_handles.set("개발자", @ maporder_hash_owner);
maporder_handles.set("전", @ maporder_hash_fighting);
maporder_handles.set("전투", @ maporder_hash_fighting);
maporder_handles.set("팀", @ maporder_hash_no_teamhit);
maporder_handles.set("팀조", @ maporder_hash_no_teamhit);
maporder_handles.set("팀조준", @ maporder_hash_no_teamhit);
maporder_handles.set("공", @ maporder_hash_open);
maporder_handles.set("공개", @ maporder_hash_open);
maporder_handles.set("공개맵", @ maporder_hash_open);
maporder_handles.set("공개편", @ maporder_hash_public);
maporder_handles.set("공개편집", @ maporder_hash_public);
maporder_handles.set("투", @ maporder_hash_no_seethrough);
maporder_handles.set("투시", @ maporder_hash_no_seethrough);
maporder_handles.set("투시금", @ maporder_hash_no_seethrough);
maporder_handles.set("투시금지", @ maporder_hash_no_seethrough);
maporder_handles.set("좌", @ maporder_hash_no_coord);
maporder_handles.set("좌표", @ maporder_hash_no_coord);
maporder_handles.set("좌표금", @ maporder_hash_no_coord);
maporder_handles.set("좌표금지", @ maporder_hash_no_coord);
maporder_handles.set("채", @ maporder_hash_no_chat);
maporder_handles.set("채팅", @ maporder_hash_no_chat);
maporder_handles.set("채팅금", @ maporder_hash_no_chat);
maporder_handles.set("채팅금지", @ maporder_hash_no_chat);
maporder_handles.set("순", @ maporder_hash_no_teleport);
maporder_handles.set("순간", @ maporder_hash_no_teleport);
maporder_handles.set("순간이", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동금", @ maporder_hash_no_teleport);
maporder_handles.set("순간이동금지", @ maporder_hash_no_teleport);
maporder_handles.set("귀", @ maporder_hash_no_recall);
maporder_handles.set("귀환", @ maporder_hash_no_recall);
maporder_handles.set("귀환금", @ maporder_hash_no_recall);
maporder_handles.set("귀환금지", @ maporder_hash_no_recall);
maporder_handles.set("입장제", @ maporder_hash_limit);
maporder_handles.set("입장제한", @ maporder_hash_limit);
maporder_handles.set("패", @ maporder_hash_pan_step);
maporder_handles.set("패닝", @ maporder_hash_pan_step);
maporder_handles.set("부", @ maporder_hash_respawn);
maporder_handles.set("부활", @ maporder_hash_respawn);
maporder_handles.set("부활고", @ maporder_hash_respawn_z);
maporder_handles.set("부활고도", @ maporder_hash_respawn_z);
maporder_handles.set("추", @ maporder_hash_no_tracking);
maporder_handles.set("추적", @ maporder_hash_no_tracking);
maporder_handles.set("추적금", @ maporder_hash_no_tracking);
maporder_handles.set("추적금지", @ maporder_hash_no_tracking);
maporder_handles.set("시", @ maporder_hash_no_corpse);
maporder_handles.set("시체", @ maporder_hash_no_corpse);
maporder_handles.set("시체금", @ maporder_hash_no_corpse);
maporder_handles.set("시체금지", @ maporder_hash_no_corpse);
maporder_handles.set("터", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널시", @ maporder_hash_tunnel_sight);
maporder_handles.set("터널시야", @ maporder_hash_tunnel_sight);
maporder_handles.set("시작아", @ maporder_hash_starting_items);
maporder_handles.set("시작아이", @ maporder_hash_starting_items);
maporder_handles.set("시작아이템", @ maporder_hash_starting_items);
maporder_handles.set("경", @ maporder_hash_bd);
maporder_handles.set("경계", @ maporder_hash_bd);
maporder_handles.set("경계볼", @ maporder_hash_bd);
maporder_handles.set("경계볼륨", @ maporder_hash_bd);
}

void maporder_hash_name(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.name, true);
return;
}
if (map_list.exists(parsed[3]))
{
this.alert("이미 존재하는 맵 이름입니다.");
return;
}
string oldname = temp.name;
map_list.delete(oldname);
file_delete("./maps/" + oldname + ".map");
temp.name = parsed[3];
temp.rawdata = string_replace(temp.rawdata, "name:" + oldname + "\r\n", "name:" + temp.name + "\r\n", false);
string[]@ lines = string_split(temp.rawdata, "\r\n", true);
string tp = "travelpoint";
string colon = ":";
int lineslength = lines.length;
for (uint i = 0; i < lineslength; i++)
{
if (string_left(lines[i], 11) != tp) continue;
temp.rawdata = string_replace(temp.rawdata, lines[i], string_replace(lines[i], colon + oldname + colon, colon + temp.name + colon, false), false);
}
fl.open("./maps/" + temp.name + ".map", "wb");
fl.write(temp.rawdata);
fl.close();
map_list.set(temp.name, @ temp);
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data " + temp.rawdata);
int vslength = temp.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = temp.vs[i];
if (v.inside is null) continue;
sendmap("vdata " + temp.rawdata, v.inside, 0);
}
this.alert("업데이트되었습니다.");
}
void maporder_hash_open(string[]@ parsed, mapdata@ temp, player@ this)
{
int index = public_maps.find_by_reference(temp);
if (index < 0)
{
if (temp.no_recall == 1)
{
this.alert("당신은 그림의 떡을 만들려 합니다.");
return;
}
public_maps.insert_last(temp);
this.alert("공개맵 목록에 올렸습니다.");
}
else
{
public_maps.remove_at(index);
this.alert("공개맵 목록에서 내렸습니다.");
}
}
void maporder_hash_sp(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 6) return;
save_map_starting(temp, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]));
this.alert("시작점이 바뀌었습니다.");
}
void maporder_hash_owner(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
if (!temp.owner.is_empty()) this.alert(array_to_string(temp.owner.keys, ", "), true);
return;
}
switch (save_map_owner(temp, parsed[3]))
{
case 1: this.alert(parsed[3] + "님을 개발자 목록에 추가했습니다.");
break; case 2: this.alert(parsed[3] + "님을 개발자 목록에서 제거했습니다.");
break; default: this.alert("알 수 없는 오류가 발생했습니다.");
}
}
void maporder_hash_es(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.enter_sound, true);
return;
}
add_map_line(temp, "enter_sound", temp.enter_sound, parsed[3]);
temp.enter_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_ls(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.leave_sound, true);
return;
}
add_map_line(temp, "leave_sound", temp.leave_sound, parsed[3]);
temp.leave_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_mss(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.move_start_sound, true);
return;
}
add_map_line(temp, "move_start_sound", temp.move_start_sound, parsed[3]);
temp.move_start_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_mes(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.move_end_sound, true);
return;
}
add_map_line(temp, "move_end_sound", temp.move_end_sound, parsed[3]);
temp.move_end_sound = parsed[3];
this.alert("업데이트되었습니다.");
}
void maporder_hash_limit(string[]@ parsed, mapdata@ temp, player@ this)
{
int pl = parsed.length;
if (pl < 4 or pl > 20)
{
this.alert(temp.limit, true);
return;
}
string data;
for (uint i = 3; i < pl; i++)
{
if (i > 3) data += " ";
data += parsed[i];
}
add_map_line(temp, "limit", temp.limit, data);
temp.limit = data;
this.alert("업데이트되었습니다.");
}
void maporder_hash_pan_step(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.pan_step, true);
return;
}
double pan_step = string_to_number(parsed[3]);
if (temp.pan_step < 0.01) pan_step = 0.01;
add_map_line(temp, "pan", temp.pan_step, pan_step);
temp.pan_step = pan_step;
sendmap("panupdate " + parsed[3], temp, 0);
this.alert("업데이트되었습니다.");
}
void maporder_hash_tunnel_sight(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.tunnel_sight, true);
return;
}
int tunnel_sight = string_to_number(parsed[3]);
if (tunnel_sight < 0) tunnel_sight = 0;
if (tunnel_sight >= 180) tunnel_sight = 180;
add_map_line(temp, "tunnel_sight", temp.tunnel_sight, tunnel_sight);
temp.tunnel_sight = tunnel_sight;
this.alert("업데이트되었습니다.");
}
void maporder_hash_starting_items(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(dictionary_to_text(temp.starting_items, ",", true, ";"), true);
return;
}
add_map_line(temp, "starting_items", dictionary_to_text(temp.starting_items, ",", true, ";"), parsed[3]);
temp.starting_items = text_to_dictionary(parsed[3], ",", VALUE_DOUBLE, ";");
this.alert("업데이트되었습니다.");
}
void maporder_hash_no_tracking(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_tracking ^= 1;
save_map_toggle(temp, "no_tracking", temp.no_tracking);
this.alert("추적금지를 " + (temp.no_tracking == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_corpse(string[]@ parsed, mapdata@ temp, player@ this)
{
if (temp.survival == 0)
{
this.alert("서바이벌 맵에서만 설정할 수 있습니다.");
return;
}
temp.no_corpse ^= 1;
save_map_toggle(temp, "no_corpse", temp.no_corpse);
this.alert("시체금지를 " + (temp.no_corpse == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_seethrough(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_seethrough ^= 1;
save_map_toggle(temp, "no_seethrough", temp.no_seethrough);
this.alert((temp.no_seethrough == 1 ? "이제 카메라로 벽 너머를 투시할 수 없습니다." : "이제 카메라로 벽 너머를 투시할 수 있습니다."));
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nno_seethrough:" + temp.no_seethrough);
}
void maporder_hash_bd(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.boundary_volume, true);
return;
}
double bd = string_to_number(parsed[3]);
add_map_line(temp, "bd", temp.boundary_volume, bd);
temp.boundary_volume = bd;
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nbd:" + temp.boundary_volume);
this.alert("업데이트되었습니다.");
}
void maporder_hash_respawn(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.respawn_mode = (temp.respawn_mode == 0 ? 1 : 0);
save_map_toggle(temp, "respawn", temp.respawn_mode);
this.alert("이제부터 죽으면 " + (temp.respawn_mode == 1 ? "맵의 시작점에서 부활합니다." : "맵 내의 임의의 지역에서 부활합니다."));
}
void maporder_hash_respawn_z(string[]@ parsed, mapdata@ temp, player@ this)
{
if (parsed.length < 4)
{
this.alert(temp.respawn_z, true);
return;
}
int respawn_z = string_to_number(parsed[3]);
add_map_line(temp, "respawn_z", temp.respawn_z, respawn_z);
temp.respawn_z = respawn_z;
this.alert("업데이트되었습니다.");
}
void maporder_hash_fighting(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.fighting ^= 1;
save_map_toggle(temp, "fightingstate", temp.fighting);
this.alert("전투 가능을 " + (temp.fighting == 1 ? "켭니다." : "끕니다."));
}
void maporder_hash_no_teamhit(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_teamhit ^= 1;
save_map_toggle(temp, "no_teamhit", temp.no_teamhit);
this.alert("이제 팀원을 조준할 수 " + (temp.no_teamhit == 1 ? "없습니다." : "있습니다."));
}
void maporder_hash_public(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.public ^= 1;
save_map_toggle(temp, "public", temp.public);
this.alert("맵 개발권을 " + (temp.public == 1 ? "개방합니다." : "폐쇄합니다."));
}
void maporder_hash_no_coord(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_coord ^= 1;
save_map_toggle(temp, "no_coord", temp.no_coord);
this.alert("좌표 조회를 " + (temp.no_coord == 0 ? "허용합니다." : "금지합니다."));
int playerslength = temp.players.length;
for (uint i = 0; i < playerslength; i++) temp.players[i].sendpacket("m_data_add \r\nno_coord:" + temp.no_coord);
int vslength = temp.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ v = temp.vs[i];
if (v.inside is null) continue;
sendmap("vdata_add \r\nno_coord:" + temp.no_coord, v.inside, 0);
}
}
void maporder_hash_no_chat(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_chat ^= 1;
save_map_toggle(temp, "no_chat", temp.no_chat);
this.alert("맵 내 채팅을 " + (temp.no_chat == 0 ? "허용합니다." : "금지합니다."));
}
void maporder_hash_no_teleport(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_teleport ^= 1;
save_map_toggle(temp, "no_teleport", temp.no_teleport);
this.alert("해당 맵에서 순간이동으로 나가는 것을 " + (temp.no_teleport == 0 ? "허용합니다." : "금지합니다."));
}
void maporder_hash_no_recall(string[]@ parsed, mapdata@ temp, player@ this)
{
temp.no_recall ^= 1;
save_map_toggle(temp, "no_recall", temp.no_recall);
this.alert("해당 맵에 순간이동해 들어오는 것을 " + (temp.no_recall == 0 ? "허용합니다." : "금지합니다."));
}
// player.bgt서버 소스코드
// scdflags
const int pc_registered = 1;
const int pc_no_save = 2;
const int pc_is_builder = 4;
const int pc_newb = 16;
const int pc_cheater = 32;
const int pc_beacon = 64;
const int pc_hidden = 128;
const int pc_voicechat = 256;
const int pc_tracksound = 512;
const int pc_autotrack_smoke = 1024;

// workflags
const int pc_stop = 0;
const int pc_sbombplacing = 1;
const int pc_ultrabombplacing = 2;
const int pc_lockerplacing = 3;
const int pc_robot_spawning = 4;
const int pc_remconnecting = 5;
const int pc_intercepting = 6;
const int pc_setting_parachute = 7;
const int pc_eat = 8;
const int pc_item_grabbing = 9;
const int pc_shielding = 10;
const int pc_shield_repairing = 11;
const int pc_street_drugging = 12;
const int pc_frequency_on = 13;

player@[] players(0);
dictionary player_list, pid_list, compid_list;
enum sightmodes
{
SIGHT_INSPECT, SIGHT_GET, SIGHT_SET
}
class player
{
timer deadtimer;
mapdata@ deadmap;
timer robotspawntimer;
string robotname;
string dropitem;
double exp = 0;
bool unstunplay = false;
int rating = 1500;
int sv_rating = 1500;
int pipper_rating = 1500;
double weaponsight = 1;
double x, y, z;
double oldx, oldy, oldz;
int rx, ry;
string version;
mapdata@ map, oldmap;
bool voicechat = false;
int remgunid = -1, remguncount = 0, remguntype = 0;
double air = 0;
string tempitem;
int tempamount;
int unstuntrys;
int stunagaintime = 0;
timer stunagaintimer;
timer unstuntrytimer;
timer spamtimer;
int spammedmsgs;
int stuntime;
int pmreceiving = 1;
double energy = 25000, oldenergy = 25000, maxenergy = 50000;
double energy_factor = 1;
int mask = 0;
int fps = 0;
timer fpstimer;
timer wingtimer;
bool no_save = false;
bool disconnected = false;
int reloading = 0;
bool underwater = false;
bool dmoving = false;
bool lowhealth = false;
bool antibioticed = false;
bool power_up = false;
timer power_up_timer;
bool active = false;
bool bleeding = false;
bool firing = false;
int sitting = 0;
int deathfreecards = 0;
timer deathfreetimer;
timer reloadtimer;
snack@ nextsnack;
timer energytimer;
timer airwarntimer;
timer airlifetimer;
timer airtimer;
timer firetimer;
timer cheatertimer;
timer newbtimer;
string langchan = "한국어1";
string shitem;
int cmmode = 0;
msound@ bleedsound, parachutesound, weapongatheringsound, grabsound;
dictionary ds;
dictionary trust;
timer invinsibilitytimer;
timer statchangetimer;
timer antibiotictimer, awarnouttimer;
bool hidden = false;
int cheater = 0;
int newb = 1;
int maxshields = 500;
timer playtimer;
timer sv_playtimer;
bool shielded = false;
int shieldshots = 0, nextshields = 0;
int invseconds = 6;
timer stunthrowtimer;
timer maptraveltimer;
dictionary muted;
dictionary a;
string ip;
int registered = 0;
timer mbombtimer;
string title;
string  ctext;
timer hurttimer;
timer missiletimer;
team@ gang;
double hurtlevel = 1;
string replyname;
int poisoned = 0;
timer poisontimer;
int kills, deaths;
bool invinsible = false, frequency = false, invinsibility_starting = false, is_builder = false, betatester = false, invisible = false;
int rank = 0;
int adminflag = 0;
int facing = 0, oldfacing = 0;
int zfacing = 0;
int health = 25000, oldhealth = 25000;
int maxhealth = 50000;
bool death = false;
double chats;
int beacon = 1;
timer beacontimer;
timer beaconvtimer;
int beacontime = 600;
string name;
uint name_hash = 0;
int peer_id;
string compid;
string hitby = "없음";
timer invisibilitytimer;
timer frequencyscramblertimer;
bool stunned = false;
timer stuntimer;
timer invusetimer;
timer stonetimer;
timer nucleartimer;
timer sound_grenadetimer;
timer stungrenadetimer;
timer concussivegrenadetimer;
bool should_subtract = false;
bool hit_head = false;
string warning;
uint8 warnlevel = 0;
timer warptimer;
bool warping = false;
uint warpstage = 0;
weapon_data@ weapon, main_weapon;
string last_weapon;
string weapon_group;
player@[] follower;
player@ following;
int workingtype = pc_stop;
timer workingtimer;
bool cremguns = false;
int accumulated_damage = 0;
uint tracking_type = 0;
dictionary tracking_target;
timer trackingtimer;
bool tracksound = false;
int trackx, tracky, trackz;
bool parachutist = false;
timer survivaltimer, survivalrewardtimer;
int survival_warning = 0;
double survivalreward = 0;
timer weapongatheringtimer, weaponchecktimer;
bool weapongathering = false;
msound@ xmsound, xmsoundplus;
dictionary wear, wear_text;
double origin_walktime = 166, bonus_walktime = 1, bonus_walktime_old = 1;
double origin_jump = 5, bonus_jump = 1, origin_jump_old = 5, bonus_jump_old = 1;
vehicle@ ride;
dictionary weapon_count, weapon_modes, weapon_modes_main;
int shot_count = 0;
bool in_smoke = false;
int defense = 0, overheattime = 0;
double overheat_level = 0.0, firetime_factor = 1;
timer smoketimer, overheattimer;
bool temp_invinsible = false;
timer temp_invinsibletimer;
player@ sightplayer;
vehicle@ sightvehicle;
timer zfacingwarntimer;
timer dopetimer;
int dope_withdrawal = 0;
bool autotrack_smoke = false;
dictionary checkpoints;
int voice = 1;
bool weaponping = false, weaponping_head = false, weaponping_team = false;
string death_sound;

bool& working()
{
if (warping) return true_t;
if (workingtype != pc_stop) return true_t;
return false_t;
}

vehicle@ get_vehicle()
{
if (this.map.is_vehicle) return this.map.vhc;
return this.ride;
}

bool& get_smoke()
{
if (this.in_smoke) return true_t;
if (!this.map.is_vehicle) return false_t;
if (this.map.vhc.in_smoke) return true_t;
return false_t;
}

weapon_data@ draw_weapon(string type, bool forced = false, bool same_class = false)
{
if (this.weapon !is null)
{
if (this.weapon.type == type) return null;
}
if (same_class)
{
if (this.main_weapon !is null)
{
if (this.main_weapon.type == type) return null;
}
}
if (!forced)
{
if (this.ds.exists("전투")) return null;
if (this.invinsible) return null;
if (this.stunned) return null;
if (this.hidden) return null;
if (this.warping) return null;
if (this.workingtype != pc_stop) return null;
if (this.overheat_level >= 100.0)
{
this.alert("기존 무기가 아직 완전히 냉각되지 않았습니다.");
return null;
}
}
if (type == "knife")
{
if (this.x == 150 and this.y == 250 and this.z == 200 and (this.map.name == "메인" or this.map.name == "서바이벌")) this.add_achievement("스카이랜드 정복", "1 ancient_wing", true);
}
weapon_data@ temp = get_weapon_handle(type, 1);
if (temp is null) return null;
bool mode_change = false;
if (this.main_weapon !is null)
{
if (temp.is_add_on)
{
if (!this.main_weapon.add_ons.exists(temp.type)) return null;
mode_change = true;
}
else if (temp is this.main_weapon) mode_change = true;
}
else
{
if (temp.is_add_on) return null;
}
weapon_data@ second_temp = temp;
if (!mode_change)
{
if (this.firetimer.elapsed < firetime_starter)
{
this.alert("그럴 겨를이 없습니다.");
return null;
}
if (this.weapon_modes.exists(type))
{
string type2;
this.weapon_modes.get(type, type2);
weapon_data@ temp2 = get_weapon_handle(type2, 1);
for (;;)
{
if (temp2 is null) break;
if (temp2.rank > this.rank) break;
if (!check_draw_req(temp2)) break;
@ temp = temp2;
type = type2;
break;
}
}
}
if (temp is second_temp)
{
if (temp.rank > this.rank) return null;
if (!check_draw_req(temp)) return null;
}
this.gathering_stop();
this.fire_stop();
bool contained = (mode_change ? string_left(temp.type, this.main_weapon.type.size) == this.main_weapon.type : string_left(temp.type, second_temp.type.size) == second_temp.type);
if (!mode_change)
{
this.playsound(second_temp is temp or temp.display_draw_sound ? temp.draw_sound : second_temp.draw_sound);
@ this.main_weapon = second_temp;
int stunlevel = temp.drawtime;
if (this.weapon !is null)
{
if (overheat_level >= 50.0)
{
stunlevel += this.weapon.overheattime;
if (this.weapon.overheat_type > 0) this.playsound("overheat_cooldown" + this.weapon.overheat_type);
}
}
this.firetimer.force(firetime_starter - stunlevel);
this.overheat_level = 0;
}
else
{
this.playsound(temp.display_draw_sound ? temp.draw_sound : "weaponmodechange");
if (contained)
{
if (weapon_modes_main.exists(this.main_weapon.type))
{
string old_weapon;
weapon_modes_main.get(this.main_weapon.type, old_weapon);
if (old_weapon != temp.type)
{
weapon_data@ old = get_weapon_handle(old_weapon);
if (old !is null)
{
if (old.max_ammo > 0 and temp.max_ammo > 0)
{
if (old.max_ammo != temp.max_ammo) this.unload(old, this.main_weapon, false);
}
if (!old.require_ammo.is_empty() and !temp.require_ammo.is_empty())
{
if (old.require_ammo != temp.require_ammo) this.unload(old, this.main_weapon, false);
}
}
}
}
}
}
this.weaponsight = temp.sight_range;
@ this.weapon = temp;
this.origin_walktime = temp.walktime;
this.origin_jump = temp.canjump;
this.firetime_factor = 1;
this.weapon_group = (contained ? this.main_weapon.type : this.weapon.type);
this.weapon_modes.set(this.main_weapon.type, this.weapon.type);
if (contained or main_weapon is weapon) this.weapon_modes_main.set(this.main_weapon.type, this.weapon.type);
this.sendpacket("weapondata " + this.main_weapon.type + " " + round(this.origin_walktime * this.bonus_walktime * ((this.maxenergy * 2) / (this.energy + this.maxenergy)), 0) + " " + round(temp.canjump * this.bonus_jump, 0) + " " + this.weaponsight + (mode_change ? " _" : empty));
return temp;
}

void gathering_stop(bool forced_stun = true, bool forced_sound = true)
{
if (this.weapongatheringsound is null) return;
this.weapongathering = false;
@ this.weapongatheringsound = this.weapongatheringsound.destroy();
if (this.weapon !is null)
{
if (!forced_sound)
{
if (this.weapongatheringtimer.elapsed >= this.weapon.gathering_min)
{
firing = true;
return;
}
}
if (this.weapon.stoptime != 0)
{
this.playsound(this.weapon.stop_sound);
if (forced_stun or this.weapon.stoptime > 0)
{
this.reloading = 4;
this.firetimer.force(this.firetimer.elapsed - abs(this.weapon.stoptime));
}
}
}
}

void fire_stop(bool forced_stun = true)
{
if (!this.firing) return;
this.firing = false;
if (this.weapon !is null)
{
if (this.weapon.stoptime != 0)
{
this.playsound(this.weapon.stop_sound);
if (forced_stun or this.weapon.stoptime > 0)
{
this.reloading = 4;
this.firetimer.force(this.firetimer.elapsed - abs(this.weapon.stoptime));
}
}
}
}

bool& check_draw_req(weapon_data@ ww)
{
if (ww.type == "fists") return true_t;
if (!ww.is_add_on and !inventory.exists(ww.type)) return false_t;
if (ww.requirements.is_empty()) return true_t;
int rlength = ww.requirements.length;
for (uint i = 0; i < rlength; i++)
{
if (!this.inventory.exists(ww.requirements[i])) return false_t;
}
return true_t;
}

bool& is_available(string[]@ parsed, int comment = 1)
{
string limit = parsed[0];
if (string_is_digits(limit))
{
if (this.exp >= string_to_number(limit)) return true_t;
switch(comment)
{
case 1: this.alert("그곳으로 가기엔 아직 너무 위험합니다.");
break; case 2: this.alert("아직 서툴러서 그 아이템을 쓸 수 없습니다.");
break; case 3: this.alert("그 스위치를 다루기엔 너무 미숙합니다.");
break; case 4: this.alert("당신에겐 아직 너무 위험한 제품입니다.");
break;
}
return false_t;
}
if (this.a.exists(limit)) return true_t;
int current = this.get_item_count(limit);
bool equipped = false;
if (this.wear_text.exists(limit))
{
current++;
equipped = true;
}
int amount = 1;
bool all_consume = false;
if (parsed.length > 1)
{
if (parsed[1] == "a") all_consume = true;
else amount = string_to_number(parsed[1]);
}
if (all_consume)
{
if (current > 0)
{
if (equipped and current == 1) this.remove_equipments(limit, false);
this.give(limit, -current);
return true_t;
}
}
else
{
if (amount == 0) amount = 1;
if (current >= abs(amount))
{
if (amount < 0)
{
if (current == abs(amount) and equipped) this.remove_equipments(limit, false);
this.give(limit, amount);
}
return true_t;
}
}
switch(comment)
{
case 1: this.alert("당신은 그곳에 입장할 자격이 없습니다.");
break; case 2: this.alert("당신은 그 아이템을 사용할 자질이 부족합니다.");
break; case 3: this.alert("스위치가 당신을 거부합니다.");
break; case 4: this.alert("그 제품은 특정 경력이 있어야 살 수 있습니다.");
break;
}
return false_t;
}

void survival_on(mapdata@ smap)
{
this.survivaltimer.force(0);
this.survival_warning = 0;
this.survivalreward = 0.0;
this.remove_equipments(empty, false, false);
this.delete_all_inv();
this.weapon_count.delete_all();
this.weapon_modes.delete_all();
this.kills = 0;
this.deaths = 0;
this.health = 25000;
this.maxhealth = 50000;
this.oldhealth = 25000;
this.shieldshots = 0;
this.maxshields = 500;
this.air = 0;
this.energy = 25000;
this.antibioticed = false;
this.shielded = false;
this.deathfreecards = 0;
this.a.delete_all();
this.draw_weapon("fists");
this.sendpacket("weaponlist " + wnames);
this.no_save = true;
if (smap !is null)
{
this.inventory = smap.starting_items;
@ this.itemnames = this.inventory.keys;
}
this.save();
}

bool& add_achievement(const string& in achievement, string reward = empty, bool public = false)
{
if (a.exists(achievement)) return false_t;
a.set(achievement, 0);
this.sendsound("achievement");
if (reward.is_empty())
{
if (achs.exists(achievement))
{
achs.get(achievement, reward);
}
if (reward.is_empty()) this.alert(achievement + " 임무를 완수했습니다.", true);
}
else this.alert(achievement + " 임무를 완수하여 " + reward + " 보상을 받았습니다.", true);
if (public)
{
send(this.peer_id, "play_s achievement_complete", 0, true);
send(this.peer_id, this.name + "님이 " + achievement + " 임무를 완수했습니다.", 2, true);
}
string[]@ rw = string_split(reward, " ", true);
if (rw.length > 1) this.give(rw[1], string_to_number(rw[0]));
return true_t;
}

void hit(int dam, const string& in hb)
{
// overloaded function
hit(dam, hb, this.should_subtract, false, false);
}
void hit(int dam, const string& in hb, bool subtract, bool super_hit = false, bool headshot = false)
{
if (!super_hit)
{
if (ride !is null)
{
if (ride.hit_percent >= random(1, 100)) return;
ride.rider_hit = true;
}
}
this.hitby = hb;
this.should_subtract = subtract;
this.hit_head = headshot;
if (antibioticed) dam *= 1.5625;
dam = (dam - defense) * hurtlevel;
if (this.invisible)
{
this.invisible = false;
this.invisibilitytimer.force(0);
this.playsound("invisibility_stop");
}
if (this.deathfreecards == 0)
{
if (this.health >= 12000 and this.health <= dam) 
{
string[]@ parsed_data = string_split(hb, "의 ", true);
player@ temp = get_player_handle(parsed_data[0]);
if (temp !is null and temp !is this) temp.add_achievement("원 샷 원 킬!", "1 nak_nk1000_decimater", true);
}
}
if (this.warping)
{
if (!this.stunned and this.warpstage == 0)
{
this.warptimer.force(20000);
this.sendpacket("startmoving");
this.playsound("wpfail");
this.warping = false;
}
}
this.accumulated_damage += dam;
}

void shieldhit(int dam)
{
if (this.temp_invinsible) return;
this.playsound("shieldhit" + random(1, 10));
this.shieldshots -= dam;
this.statchangetimer.force(0);
}

void unload(weapon_data@ temp = null, weapon_data@ main_temp = null, bool announce = true)
{
if (temp is null) @ temp = this.weapon;
if (temp is null) return;
if (main_temp is null) @ main_temp = this.main_weapon;
if (main_temp is null) return;
if (temp.max_ammo < 1) return;
string wg = temp.type;
if (string_left(temp.type, main_temp.type.size) == main_temp.type) wg = main_temp.type;
int amount = this.get_ammo_count(wg);
if (amount < 1)
{
if (announce) this.alert("이미 비었습니다.");
return;
}
this.ammo_give(wg, -amount);
if (!temp.require_ammo.is_empty())
{
this.ammo_set(temp.require_ammo, -amount);
this.give(temp.require_ammo, amount);
}
this.playsound(temp.unload_sound);
this.firetimer.force(firetime_starter - temp.unloadtime);
this.reloading = 3;
}

bool& move(int facing, int dir = north, int pace = 1, bool sound = true)
{
string tilecheck;
if (dir == Up)
{
str_collision@ temp = get_collision_handle_straight(this.x, this.y, this.z, this.map, pace, 0, 90);
if (temp.time >= 0.0 and temp.time < pace) return false_t;
string tilecheck = get_tile_at(round(this.x, 0), round(this.y, 0), this.z + pace, this.map);
if (string_left(tilecheck, 4) == "wall") return false_t;
this.z += pace;
}
else if (dir == Down)
{
str_collision@ temp = get_collision_handle_straight(this.x, this.y, this.z, this.map, pace, 0, 270);
if (temp.time >= 0.0 and temp.time < pace) return false_t;
string tilecheck = get_tile_at(round(this.x, 0), round(this.y, 0), this.z - pace, this.map);
if (string_left(tilecheck, 4) == "wall") return false_t;
this.z -= pace;
}
else
{
str_collision@ temp = get_collision_handle_straight(this.x, this.y, this.z, this.map, pace, this.facing, 0);
if (temp.time >= 0.0 and temp.time < pace) return false_t;
vector me = move_global(x, y, z, facing, (dir == Forward ? north : dir == Backward ? south : dir == Left ? west : dir == Right ? east : 0), 0, 0, pace);
me.x = (me.x < 0 ? 0 : me.x > max.x ? max.x : me.x);
me.y = (me.y < 0 ? 0 : me.y > max.y ? max.y : me.y);
string tilecheck = get_tile_at(round(me.x, 0), round(me.y, 0), this.z, this.map);
if (string_left(tilecheck, 4) == "wall") return false_t;
this.x = me.x;
this.y = me.y;
}
this.sendpacket("move " + this.x + " " + this.y + " " + this.z);
if (sound and !tilecheck.is_empty()) this.sendsound(tilecheck + "step" + random(1, 5));
this.moveact(sound, (tilecheck.is_empty() ? "air" : tilecheck));
return true_t;
}

void objcheck(int range = 4)
{
if (this.invinsible) return;
if (this.hidden) return;
string mess;
bool su = false;
int corpselength = map.corpses.length;
for (uint x = 0; x < corpselength; x++)
{
corpse@ temp = map.corpses[x];
if (temp.get) continue;
if (temp.take) continue;
if (this.distancecheck(temp.x, temp.y, temp.z) <= range)
{
play("objget", temp.x, temp.y, temp.z, temp.map);
objgrabs++;
temp.get = true;
temp.beeptimer.pause();
mess += temp.owner + "의 시체, ";
this.give("corpse_of_" + temp.owner + "_" + temp.id, 1, false);
su = true;
break;
}
}
int objslength = map.objs.length;
for (uint i = 0; i < objslength; i++)
{
obj@ temp = map.objs[i];
if (temp.distancecheck(this.x, this.y, this.z) <= range)
{
int limit_count = -1;
if (temp.mapi !is null)
{
if (temp.mapi.limit > 0)
{
limit_count = (temp.mapi.limit_all ? temp.mapi.get_limit_all(temp.name) : temp.mapi.get_limit(this));
if (limit_count >= temp.mapi.limit) continue;
}
}
if (!item_grab_hash.exists(temp.name))
{
mess += string_replace(temp.name, "_", " ", true) + " " + temp.amount + "개, ";
this.give(temp.name, temp.amount, false);
su = true;
}
else
{
item_grab_func@ func;
if (!item_grab_hash.get(temp.name, @ func)) continue;
string newmess = func(this, temp);
if (newmess.is_empty()) continue;
mess += newmess + ", ";
su = true;
}
if (limit_count >= 0) temp.mapi.limited.set((temp.mapi.limit_all ? temp.name : this.name), limit_count + 1);
play(temp.get_sound, temp.x, temp.y, temp.z, temp.map);
objgrabs++;
temp.breaking = true;
continue;
}
}
if (!mess.is_empty())
{
mess.resize(mess.size - 2);
this.alert(mess, true);
}
if (su) this.update_inv();
}

void moveact(bool playing = true, string gpt = empty, int falldist = 0)
{
if (!this.active) this.active = true;
if (this.y == 100 and this.z == 100)
{
if (this.map.name == "입문") this.add_achievement("입문자의 2번째 도전", "500000 coin", false);
}
if (this.invinsible) return;
if (this.dmoving) return;
this.objcheck();
if (gpt.is_empty()) gpt = get_tile_at(this.rx, this.ry, this.z, this.map);
if (gpt.is_empty()) return;
if (this.newb != 1) step_mine(this.x, this.y, this.z, this.map, this.name);
if (this.underwater)
{
if (string_contains(gpt, "underwater", 1) < 0)
{
this.airwarntimer.force(0);
this.airlifetimer.force(0);
this.underwater = false;
}
}
if (this.hidden) return;
if (falldist >= 15)
{
if (playing) this.playsound(gpt + "hardland", false);
if (falldist == 2147483647)
{
this.sitting = 1;
this.sendpacket("sitstart");
}
else
{
if (this.parachutist)
{
if (gpt != "electricity") this.stun(1000, false, false);
this.parachutist = false;
if (this.parachutesound !is null) @ this.parachutesound = this.parachutesound.destroy();
}
else
{
if (falldist > 120)
{
this.death = true;
this.hitby = "internal:gravity";
}
else
{
this.sitting = 1;
this.sendpacket("sitstart");
this.health -= falldist * 500;
this.should_subtract = false;
this.hitby = "internal:gravity";
if (this.health >= 5000) this.add_achievement("50% 이상 체력 남기고 살아남기", "1 antibiotic_pack");
}
}
}
}
else if (falldist > 0)
{
if (playing) this.playsound(gpt + "land", false);
if (this.parachutist)
{
this.parachutist = false;
if (this.parachutesound !is null) @ this.parachutesound = this.parachutesound.destroy();
}
}
else
{
if (playing) this.playsound(gpt + "step" + random(1, 5), false);
}
if (!this.underwater)
{
if (string_contains(gpt, "underwater", 1) > -1)
{
this.airwarntimer.force(0);
this.airlifetimer.force(0);
this.underwater = true;
}
}
if (gpt == "blade")
{
this.health >>= 1;
this.hitby = "검 함정";
}
else if (gpt == "electricity")
{
this.stun(30000, true, true, 0, true);
}
else if (gpt == "mine")
{
if (this.rank != 5)
{
this.death = true; 
        this.hitby = "소거의 지뢰"; 
    }
}
}
void eat(const string& in fooditem)
{
this.work(pc_eat);
snack@ temp;
if (!snackitems.get(fooditem, @ temp)) return;
@ this.nextsnack = temp;
this.playsound("eat" + fooditem);
}

dictionary ammo;
dictionary loaded_ammo;

int get_ammo_count(const string& in w)
{
int amount;
if (!ammo.get(w, amount)) return 0;
return amount;
}

int get_loaded_total(const string& in r)
{
int amount;
if (!loaded_ammo.get(r, amount)) return 0;
return amount;
}

bool& vehiclecheck()
{
int maplength = maps.length;
for (uint j = 0; j < maplength; j++)
{
mapdata@ mapt = maps[j];
int vslength = mapt.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = mapt.vs[i];
if (are_teamed(this.name, temp.owner, true)) return true_t;
}
}
return false_t;
}

double distancecheck(double xx, double yy, double zz)
{
return ((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z)) ** 0.5;
}

void respawn()
{
if (this.deadmap !is null)
{
if (!this.deadmap.lastman_standing.is_empty())
{
if (!this.deadmap.lastman_standing.exists(this.name))
{
this.go_to("세이프존", random(0, 20), random(0, 20), 0, true, true);
@ this.deadmap = null;
return;
}
}
vector t;
if (this.checkpoints.exists(this.deadmap.name))
{
if (this.checkpoints.get(this.deadmap.name, t))
{
this.go_to(this.deadmap, t.x, t.y, t.z, true, true);
@ this.deadmap = null;
return;
}
}
if (this.deadmap.respawn_mode == 1)
{
int tx = (this.deadmap.starting.x == -1 ? random(0, this.deadmap.max.x) : this.deadmap.starting.x);
int ty = (this.deadmap.starting.y == -1 ? random(0, this.deadmap.max.y) : this.deadmap.starting.y);
this.go_to(this.deadmap, tx, ty, this.deadmap.starting.z, true, true);
}
else this.go_to(this.deadmap, random(0, this.deadmap.max.x), random(0, this.deadmap.max.y), this.deadmap.respawn_z, true, true);
@ this.deadmap = null;
return;
}
this.go_to("세이프존", random(0, 20), random(0, 20), 0, true, true);
}

savedata@ sf;

void tempload(bool dc = false)
{
if (sf.d.exists("기존차량"))
{
string[]@ oldp = string_split(string_base64_decode(sf.read("기존차량")), " ", true);
if (oldp.length < 5) return;
this.facing = string_to_number(oldp[3]);
vehicle@ temp = get_vehicle_handle(oldp[4]);
if (temp !is null)
{
int ind = temp.followed_players.find_by_reference(this);
if (ind > -1) temp.followed_players.remove_at(ind);
if (dc)
{
@ this.map = temp.inside;
this.x = string_to_number(oldp[0]);
this.y = string_to_number(oldp[1]);
this.z = string_to_number(oldp[2]);
return;
}
this.go_to(temp.inside, string_to_number(oldp[0]), string_to_number(oldp[1]), string_to_number(oldp[2]), false);
return;
}
if (dc)
{
@ this.map = get_map_handle("세이프존");
this.x = 10;
this.y = 10;
this.z = 0;
return;
}
this.go_to("세이프존", 10, 10, 0, false);
this.save();
}
if (!sf.d.exists("기존맵")) return;
string[]@ oldp = string_split(string_base64_decode(sf.read("기존맵")), " ", true);
if (oldp.length < 5) return;
this.facing = string_to_number(oldp[3]);
if (dc)
{
@ this.map = get_map_handle(oldp[4]);
if (this.map is null)
{
@ this.map = get_map_handle("세이프존");
this.x = 10;
this.y = 10;
this.z = 0;
return;
}
this.x = string_to_number(oldp[0]);
this.y = string_to_number(oldp[1]);
this.z = string_to_number(oldp[2]);
return;
}
this.go_to(oldp[4], string_to_number(oldp[0]), string_to_number(oldp[1]), string_to_number(oldp[2]), false);
this.save();
}

void remove(bool got_kicked = false, bool save = true)
{
if (this.bleedsound !is null) @ this.bleedsound = this.bleedsound.destroy();
if (this.grabsound !is null) @ this.grabsound = this.grabsound.destroy();
if (this.parachutesound !is null) @ this.parachutesound = this.parachutesound.destroy();
if (this.weapongatheringsound !is null) @ this.weapongatheringsound = this.weapongatheringsound.destroy();
if (this.xmsound !is null) @ this.xmsound = this.xmsound.destroy();
if (this.xmsoundplus !is null) @ this.xmsoundplus = this.xmsoundplus.destroy();
if (this.gang !is null) this.gang.remove_member(name, false, false);
uint oldid = (this.disconnected ? 4294967294 : this.peer_id);
if (got_kicked)
{
string message = this.name + "님이 서버에서 쫓겨납니다.";
send(0, message, 2);
log("adminlog", message);
}
else
{
if (this.cheatercheck() or get_tile_at(round(this.x, 0), round(this.y, 0), this.z, this.map).is_empty())
{
this.cheater = 1;
log("system_message", this.name + "님이 불법 행위를 합니다.");
send(0, this.name + "님이 짱구를 굴려보지만, 망신만 당하고 도망칩니다.", 2);
}
}
if (ride !is null) ride.command("escape", this, true);
for (int fo = this.follower.length - 1; fo > -1; fo--)
{
player@ temp = this.follower[fo];
if (temp is null) continue;
temp.alert(this.name + "님이 로그아웃하여 관전을 중단합니다.");
temp.sendpacket("followstop");
if (temp.invinsible) temp.sendpacket("stopmoving");
@ temp.following = null;
temp.tempload();
}
if (this.following !is null)
{
int findex = this.following.follower.find_by_reference(this);
if (findex > -1) this.following.follower.remove_at(findex);
this.tempload(true);
}
int index = gnplayers.find_by_reference(this);
if (index > -1)
{
gnplayers.remove_at(index);
guessthenumber_guesses.remove_at(index);
}
if (this.map !is null)
{
mapdata@ smap = (this.map.is_vehicle ? this.map.vhc.map : this.map);
vehicle@ v = (this.map.is_vehicle ? this.map.vhc : null);
throw_flag(smap, v, this);
lastmanloop(smap, this, true);
}
string[]@ unload = this.loaded_ammo.keys;
int unloadlength = unload.length;
for (uint j = 0; j < unloadlength; j++)
{
int a = this.get_loaded_total(unload[j]);
this.give(unload[j], a, false);
}
this.update_inv();
if (save) this.save();
if (!this.hidden) send(0, "offline " + this.x + " " + this.y + " " + this.z + " " + this.name + " " + this.map.name, 0);
else
{
if (!this.disconnected) this.sendpacket("offline " + this.x + " " + this.y + " " + this.z + " " + this.name + " " + this.map.name);
}
if (oldid != 4294967294) send(oldid, "killclient", 0);
this.disconnected = true;
disconnections++;
}

void load(bool forced = false, bool reset_eq = false)
{
sf.load();
if (!forced)
{
if (sf.d.exists("손절")) this.muted = sf.readd("손절", true);
if (sf.d.exists("신뢰")) this.trust = sf.readd("신뢰", true);
if (sf.d.exists("금지")) this.ds = sf.readd("금지", true);
if (sf.d.exists("이름")) this.name = sf.read("이름");
if (sf.d.exists("타이틀")) this.title = sf.read("타이틀");
if (sf.d.exists("소속")) @ this.gang = get_team_handle(sf.read("소속"));
if (sf.d.exists("언어")) this.langchan = sf.read("언어");
if (sf.d.exists("누적채팅")) this.chats = sf.readn("누적채팅");
if (sf.d.exists("레이팅")) this.rating = sf.readn("레이팅");
if (sf.d.exists("피퍼레이팅")) this.pipper_rating = sf.readn("피퍼레이팅");
if (sf.d.exists("서바이벌레이팅")) this.sv_rating = sf.readn("서바이벌레이팅");
if (sf.d.exists("플레이시간")) this.playtimer.force(sf.readn("플레이시간"));
if (sf.d.exists("서바이벌시간")) this.survivalreward = sf.readn("서바이벌시간");
if (sf.d.exists("등급")) this.rank = sf.readn("등급");
if (sf.d.exists("입문자시간")) this.newbtimer.force(sf.readn("입문자시간"));
if (sf.d.exists("재행동시간")) this.statchangetimer.force(sf.readn("재행동시간"));
if (sf.d.exists("경고")) this.warning = sf.read("경고");
if (sf.d.exists("경고수준")) this.warnlevel = sf.readn("경고수준");
if (sf.d.exists("경험치")) this.exp = sf.readn("경험치");
if (sf.d.exists("음성")) this.voice = sf.readn("음성");
if (sf.d.exists("체크포인트")) this.checkpoints = text_to_dictionary(sf.read("체크포인트"), "\r\n", VALUE_VECTOR);
if (sf.d.exists("플래그"))
{
int tempflag = sf.readn("플래그");
this.voicechat = (tempflag & pc_voicechat > 0);
this.registered = (tempflag & pc_registered == 0 ? 0 : 1);
this.no_save = (tempflag & pc_no_save > 0);
this.is_builder = (tempflag & pc_is_builder > 0);
this.newb = (tempflag & pc_newb == 0 ? 0 : 1);
this.cheater = (tempflag & pc_cheater == 0 ? 0 : 1);
this.beacon = (tempflag & pc_beacon == 0 ? 0 : 1);
this.tracksound = (tempflag & pc_tracksound > 0);
this.hidden = (tempflag & pc_hidden == 1);
this.autotrack_smoke = (tempflag & pc_autotrack_smoke > 0);
}
}
if (this.no_save)
{
string tempmap = default_sv.name;
if (sf.d.exists("서바이벌맵")) tempmap = sf.read("서바이벌맵");
mapdata@ mh = get_map_handle(tempmap);
if (mh is null)
{
this.give("street_program_starter_kit", 1);
this.go_to(default_sv, random(0, 500), random(0, 500), 0, false);
return;
}
this.inventory = mh.starting_items;
@ this.itemnames = this.inventory.keys;
if (mh.respawn_mode == 1) this.go_to(mh, mh.starting.x, mh.starting.y, mh.starting.z, false);
else this.go_to(mh, random(0, mh.max.x), random(0, mh.max.y), 0, false);
return;
}
string tempmap = "메인";
string vid;
int tempx = 0;
int tempy = 0;
int tempz = 0;
if (sf.d.exists("맵")) tempmap = sf.read("맵");
if (sf.d.exists("차량")) vid = sf.read("차량");
if (sf.d.exists("x")) tempx = round(sf.readn("x"), 0);
if (sf.d.exists("y")) tempy = round(sf.readn("y"), 0);
if (sf.d.exists("z")) tempz = sf.readn("z");
if (sf.d.exists("킬")) this.kills = sf.readn("킬");
if (sf.d.exists("데스")) this.deaths = sf.readn("데스");
if (sf.d.exists("방향")) this.facing = sf.readn("방향");
if (sf.d.exists("체력")) this.health = sf.readn("체력");
if (sf.d.exists("최대체력")) this.maxhealth = sf.readn("최대체력");
if (sf.d.exists("실드내구도")) this.shieldshots = sf.readn("실드내구도");
if (sf.d.exists("최대실드내구도")) this.maxshields = sf.readn("최대실드내구도");
if (sf.d.exists("공기")) this.air = sf.readn("공기");
if (sf.d.exists("기력")) this.energy = sf.readn("기력");
if (sf.d.exists("최대기력")) this.maxenergy = sf.readn("최대기력");
if (sf.d.exists("공격받음")) this.hitby = sf.read("공격받음");
if (sf.d.exists("임무")) this.a = sf.readd("임무", true);
if (sf.d.exists("무기카운트")) this.weapon_count = sf.readd("무기카운트", true);
if (sf.d.exists("무기모드")) this.weapon_modes = sf.readd("무기모드", true);
if (!vid.is_empty())
{
vehicle@ temp = get_vehicle_handle(vid);
if (temp is null) this.go_to("세이프존", random(0, 20), random(0, 20), 0, false, true);
else this.go_to(temp.inside, tempx, tempy, tempz, false, true);
}
else
{
if (map_list.exists(tempmap)) this.go_to(tempmap, tempx, tempy, tempz, false, true);
else this.go_to("세이프존", random(0, 20), random(0, 20), 0, false, true);
}
if (forced) this.delete_all_inv();
this.load_inv();
if (sf.d.exists("장비"))
{
if (forced or reset_eq) this.remove_equipments(empty, false, false);
string[]@ wearlist = sf.readd("장비", true).keys;
bool fail = false;
int wearlistlength = wearlist.length;
for (uint i = 0; i < wearlistlength; i++)
{
equipment@ eq = get_equipment_handle(wearlist[i]);
if (eq is null) continue;
if (this.wear.exists(eq.region))
{
this.give(wearlist[i], 1, false);
fail = true;
continue;
}
if (!eq.handle(this, EQUIP_WEAR))
{
this.give(wearlist[i], 1, false);
fail = true;
continue;
}
eq.wear(this, false, true, false);
}
if (fail) this.update_inv();
}
this.sendpacket("walkmod " + round(this.origin_walktime * this.bonus_walktime * ((this.maxenergy * 2) / (this.energy + this.maxenergy)), 0));
this.sendpacket("jumpset " + round(this.origin_jump * this.bonus_jump, 0));
}

void load_inv()
{
if (!sf.d.exists("소유"))
{
if (locker_list.exists(this.name)) return;
if (this.newb == 0) return;
this.give("street_program_starter_kit", 1);
return;
}
inventory = sf.readd("소유", true);
if (inventory.is_empty())
{
if (locker_list.exists(this.name)) return;
if (this.newb == 0) return;
this.give("street_program_starter_kit", 1);
return;
}
@ itemnames = inventory.keys;
}

void save()
{
sf.add("손절", this.muted, true);
sf.add("신뢰", this.trust, true);
sf.add("금지", this.ds, true);
sf.add("컴퓨터ID", this.compid);
sf.add("이름", this.name);
sf.add("타이틀", this.title);
if (this.gang !is null) sf.add("소속", this.gang.teamname);
else sf.d.delete("소속");
sf.add("언어", this.langchan);
sf.add("누적채팅", this.chats);
sf.add("등급", this.rank);
sf.add("레이팅", this.rating);
sf.add("피퍼레이팅", this.pipper_rating);
sf.add("서바이벌레이팅", this.sv_rating);
sf.add("플레이시간", this.playtimer.elapsed);
sf.add("서바이벌시간", this.survivalreward);
sf.add("입문자시간", this.newbtimer.elapsed);
sf.add("재행동시간", this.statchangetimer.elapsed);
sf.add("경험치", this.exp);
sf.add("음성", this.voice);
sf.add("체크포인트", dictionary_to_text(this.checkpoints));
int tempflag = 0;
if (this.voicechat) tempflag += pc_voicechat;
if (this.registered == 1) tempflag += pc_registered;
if (this.no_save) tempflag += pc_no_save;
if (this.is_builder) tempflag += pc_is_builder;
if (this.newb == 1) tempflag += pc_newb;
if (this.cheater == 1) tempflag += pc_cheater;
if (this.beacon == 1) tempflag += pc_beacon;
if (this.tracksound) tempflag += pc_tracksound;
if (this.hidden) tempflag += pc_hidden;
if (this.autotrack_smoke) tempflag += pc_autotrack_smoke;
sf.add("플래그", tempflag);
sf.add("경고", this.warning);
sf.add("경고수준", this.warnlevel);
if (this.no_save)
{
sf.add("서바이벌맵", (this.map.is_vehicle ? this.map.vhc.map.name : this.map.name));
}
else
{
sf.add("소유", this.inventory, true);
sf.add("무기카운트", this.weapon_count, true);
sf.add("무기모드", this.weapon_modes, true);
sf.add("장비", this.wear_text, true);
sf.add("임무", this.a, true);
sf.add("킬", this.kills);
sf.add("데스", this.deaths);
if (this.map.is_vehicle)
{
vehicle@ v = this.map.vhc;
sf.add("맵", v.map.name);
sf.add("차량", v.id);
}
else
{
sf.add("맵", this.map.name);
sf.d.delete("차량");
}
sf.add("x", this.x);
sf.add("y", this.y);
sf.add("z", this.z);
sf.add("방향", this.facing);
sf.add("체력", this.health);
sf.add("최대체력", this.maxhealth);
sf.add("실드내구도", this.shieldshots);
sf.add("최대실드내구도", this.maxshields);
sf.add("공격받음", this.hitby);
sf.add("공기", this.air);
sf.add("기력", this.energy);
sf.add("최대기력", this.maxenergy);
}
sf.save();
}

void equip(const string& in message, bool return_item = true, bool announce = true)
{
equipment@ eq = get_equipment_handle(message);
if (eq is null) return;
if (!this.wear.exists(eq.region))
{
if (!eq.handle(this, EQUIP_WEAR)) return;
eq.wear(this, announce);
return;
}
equipment@ temp;
this.wear.get(eq.region, @ temp);
if (temp is eq)
{
if (!eq.handle(this, EQUIP_REMOVE)) return;
eq.remove(this, announce, true, return_item);
return;
}
if (!temp.handle(this, EQUIP_REMOVE)) return;
temp.remove(this, announce, true, return_item);
if (!eq.handle(this, EQUIP_WEAR)) return;
eq.wear(this, announce);
}

void remove_equipments(const string& in what = empty, bool announce = false, bool return_item = true)
{
if (!what.is_empty())
{
equipment@ temp;
if (!this.wear.get(what, @ temp)) return;
temp.handle(this, EQUIP_REMOVE);
temp.remove(this, announce, true, return_item);
return;
}
string[]@ wearlist = this.wear.keys;
int wearlength = this.wear.size;
for (uint i = 0; i < wearlength; i++)
{
equipment@ temp;
if (!this.wear.get(wearlist[i], @ temp)) continue;
temp.handle(this, EQUIP_REMOVE);
temp.remove(this, announce, false, return_item);
}
this.wear.delete_all();
this.wear_text.delete_all();
}

void give_exp(double new_exp = 0)
{
this.exp += new_exp;
if (this.exp > 4294967295) this.add_achievement("마스터 전직", "1 master_robot_card", true);
else if (this.exp > 999999999) this.add_achievement("4차 전직", "10000 robot_card", true);
else if (this.exp > 199999999) this.add_achievement("3차 전직", "2000 robot_card", true);
else if (this.exp > 39999999) this.add_achievement("2차 전직", "500 robot_card", true);
else if (this.exp > 7999999) this.add_achievement("1차 전직", "100 robot_card", true);
}

vector get_travel_data(int x, int y, int z, mapdata@ mid)
{
vector t;
bool su = this.checkpoints.exists(mid.name);
if (su) this.checkpoints.get(mid.name, t);
vector ret;
ret.x = (x == -2 ? (su ? t.x : mid.starting.x) : x < 0 ? random(0, mid.max.x) : x);
ret.y = (y == -2 ? (su ? t.y : mid.starting.y) : y < 0 ? random(0, mid.max.y) : y);
ret.z = (x == -2 and y == -2 and su ? t.z : z);
return ret;
}

void go_to(const string& in tmap, int x, int y, int z, bool sound = true, bool command = false, bool dead_move = false, bool travel = false)
{
// overloaded
go_to(get_map_handle(tmap), x, y, z, sound, command, dead_move, travel);
}
void go_to(mapdata@ tmap, int x, int y, int z, bool sound = true, bool command = false, bool dead_move = false, bool travel = false)
{
if (this.dmoving) return;
if (tmap is null) @ tmap = this.map;
if (!travel)
{
if (ride !is null) ride.command("escape", this, dead_move);
}
this.fire_stop();
if (this.hidden) sound = false;
if (this.invinsible) sound = false;
bool mapchanged = false;
if (!command) mapchanged = true;
if (tmap !is this.map) mapchanged = true;
if (!mapchanged)
{
if (sound) this.playsound(this.map.move_start_sound);
this.x = (x > tmap.max.x ? tmap.max.x : x < 0 ? 0 : x);
this.y = (y > tmap.max.y ? tmap.max.y : y < 0 ? 0 : y);
this.z = (z > tmap.max.z ? tmap.max.z : z < tmap.min.z ? tmap.min.z : z);
if (sound) this.playsound(this.map.move_end_sound);
}
else
{
if (sound) this.playsound(this.map.leave_sound);
if (this.map !is null)
{
bool in_map = (this.map.is_vehicle and this.map.vhc.map is tmap) or (tmap.is_vehicle and tmap.vhc.map is this.map);
if (!in_map)
{
mapdata@ smap = (this.map.is_vehicle ? this.map.vhc.map : this.map);
vehicle@ v = (this.map.is_vehicle ? this.map.vhc : null);
throw_flag(smap, v, this);
lastmanloop(smap, this);
}
if (this.map.is_vehicle)
{
this.sendpacket("veunspawn");
this.sendpacket("exitvehicle");
this.sendpacket("goodfuel");
this.playsound(this.map.vhc.type + "_unspawn", false);
}
if (tmap.is_vehicle) this.playsound(tmap.vhc.type + "_spawn", false);
}
if (tmap.is_vehicle)
{
vehicle@ tv = tmap.vhc;
this.sendpacket(tv.entervehicle());
this.sendpacket("vdata " + tv.map.rawdata);
}
@ this.map = tmap;
this.x = (x > tmap.max.x ? tmap.max.x : x < 0 ? 0 : x);
this.y = (y > tmap.max.y ? tmap.max.y : y < 0 ? 0 : y);
this.z = (z > tmap.max.z ? tmap.max.z : z < tmap.min.z ? tmap.min.z : z);
this.oldx = x;
this.oldy = y;
this.oldz = z;
this.rx = round(this.x, 0);
this.ry = round(this.y, 0);
if (!tmap.mapnoitems.is_empty())
{
string[]@ list = this.wear_text.keys;
int listlength = list.length;
for (uint i = 0; i < listlength; i++)
{
if (is_no_item(this.rx, this.ry, this.z, tmap, list[i])) this.equip(list[i]);
}
if (this.weapon !is null)
{
if (is_no_item(this.rx, this.ry, this.z, tmap, this.weapon.type)) this.draw_weapon("fists");
}
}
if (!this.follower.is_empty()) this.drag();
if (dead_move) return;
this.sendpacket("resizemsound", 4);
this.sendpacket("resizegate", 4);
this.sendpacket("resizegate_v", 4);
int msoundslength = tmap.msounds.length;
for (uint i = 0; i < msoundslength; i++)
{
msound@ mm = tmap.msounds[i];
if (this is mm.owner)
{
if (mm.stationary_mode == STATIONARY_OWNER) mm.send_stationary(this);
continue;
}
if (mm.stationary_mode == STATIONARY_ALL) mm.send_stationary(this);
else mm.send(this);
}
this.sendpacket("mapname " + tmap.name);
this.sendpacket("m_data " + tmap.rawdata);
if (this.bleedsound !is null) @ this.bleedsound = this.bleedsound.change_map(tmap, this.x, this.y, this.z);
if (this.grabsound !is null) @ this.grabsound = this.grabsound.change_map(tmap, this.x, this.y, this.z);
if (this.parachutesound !is null) @ this.parachutesound = this.parachutesound.change_map(tmap, this.x, this.y, this.z);
this.gathering_stop();
if (this.xmsound !is null) @ this.xmsound = this.xmsound.destroy();
if (this.xmsoundplus !is null) @ this.xmsoundplus = this.xmsoundplus.destroy();
string mess;
int ambslength = tmap.ambs.length;
for (uint i = 0; i < ambslength; i++)
{
amb@ mm = tmap.ambs[i];
if (name_hash == mm.owner_hash)
{
if (this.name == mm.owner) continue;
}
mess += mm.minx + " " + mm.maxx + " " + mm.miny + " " + mm.maxy + " " + mm.minz + " " + mm.maxz + " " + mm.soundloop + " " + mm.volume + " " + mm.id + "[]";
}
if (!mess.is_empty()) this.sendpacket("createamb " + mess, 4);
mess.resize(0);
int hobjslength = tmap.hobjs.length;
for (uint i = 0; i < hobjslength; i++)
{
hittable@ temp = tmap.hobjs[i];
if (temp.tile.is_empty()) continue;
mess += temp.x + " " + temp.y + " " + temp.z + " " + temp.sound + " " + temp.id + (temp.tile.is_empty() ? empty : " " + temp.tile) + "[]";
}
if (!mess.is_empty()) this.sendpacket("spawnsource " + mess, 4);
mess.resize(0);
int gateslength = tmap.mapgates.length;
for (uint i = 0; i < gateslength; i++)
{
maptile@ temp = tmap.mapgates[i];
mess += temp.gate_rawdata + "[]";
}
if (!mess.is_empty()) this.sendpacket("spawngate " + mess, 4);
if (tmap.is_vehicle)
{
mess.resize(0);
gateslength = tmap.vhc.map.mapgates.length;
for (uint i = 0; i < gateslength; i++)
{
maptile@ temp = tmap.vhc.map.mapgates[i];
mess += temp.gate_rawdata + "[]";
}
if (!mess.is_empty()) this.sendpacket("spawngate_v " + mess, 4);
}
max = tmap.max;
if (sound) this.playsound(this.map.enter_sound);
}
if (dead_move) return;
this.sendpacket("move " + this.x + " " + this.y + " " + this.z + " " + this.facing);
this.moveact();
}


void drag()
{
for (int fo = this.follower.length - 1; fo > -1; fo--)
{
player@ temp = this.follower[fo];
if (temp is null)
{
this.follower.remove_at(fo);
continue;
}
if (temp.disconnected)
{
this.follower.remove_at(fo);
continue;
}
if (temp.map !is this.map)
{
temp.go_to(this.map, this.x, this.y, this.z, false);
continue;
}
temp.x = this.x;
temp.y = this.y;
temp.z = this.z;
temp.facing = this.facing;
temp.sendpacket("move " + this.x + " " + this.y + " " + this.z + " " + this.facing);
}
}

int warpdist = 0;
int warpmoved = 0;
vector max, warp;

void warpcheck()
{
if (warpstage == 0)
{
if (warptimer.elapsed >= 2460)
{
this.sendpacket("freezestart");
this.playsound("wpvanish");
play_dist("wpvanishdist", x, y, z, map);
z += 10000000;
warpstage = 1;
warpdist = random(100, 150);
warp.x = x;
warp.y = y;
warp.z = z;
this.sendsound("wpmid");
warptimer.force(0);
}
}
if (warpstage == 1)
{
if (warpmoved < warpdist)
{
warp = move_global(warp.x, warp.y, this.z, facing);
warpmoved++;
bool failed = false;
if (warp.x > max.x)
{
warp.x = 0;
failed = true;
}
else if (warp.x < 0)
{
warp.x = max.x;
failed = true;
}
else if (warp.y > max.y)
{
warp.y = 0;
failed = true;
}
else if (warp.y < 0)
{
warp.y = max.y;
failed = true;
}
if (failed)
{
this.sendsound("wpfail");
this.health = 1;
this.shieldshots = 0;
invisibilitytimer.force(30000);
awarnouttimer.force(0);
}
return;
}
if (warptimer.elapsed >= 2000)
{
warpstage = 0;
warpdist = 0;
warpmoved = 0;
warping = false;
warp.x = round(warp.x, 0);
warp.y = round(warp.y, 0);
x = warp.x;
y = warp.y;
z -= 10000000;
this.sendpacket("move " + x + " " + y + " " + z);
this.sendpacket("freezestop");
this.sendpacket("startmoving");
this.playsound("wpappear");
play_dist("wpappeardist", x, y, z, map);
}
}
}

void sendpacket(const string& in packet, int chan = 0)
{
n.send_reliable(peer_id, string_encrypt(packet, pcps), chan);
}

void alert(const string& in packet, bool buffer = false)
{
n.send_reliable(peer_id, string_encrypt((buffer ? empty : spp) + packet, pcps), (buffer ? 2 : 0));
}

void playsound(const string& in sound, bool include_me = true)
{
int l = map.players.length;
int range = 75 / this.map.pan_step;
if (this.follower.is_empty())
{
if (include_me) n.send_reliable(this.peer_id, string_encrypt("play_s " + sound, pcps), 0);
if (l == 0) return;
string mess = string_encrypt("play_3ds " + sound + " " + x + " " + y + " " + z, pcps);
for (uint i = 0; i < l; i++)
{
player@ temp = map.players[i];
if (temp is this) continue;
if (temp.distancecheck(this.x, this.y, this.z) < (range / temp.weaponsight))
n.send_reliable(temp.peer_id, mess, 0);
}
}
else
{
string mess2 = string_encrypt("play_s " + sound, pcps);
if (include_me) n.send_reliable(this.peer_id, mess2, 0);
if (l == 0) return;
string mess = string_encrypt("play_3ds " + sound + " " + x + " " + y + " " + z, pcps);
for (uint i = 0; i < l; i++)
{
player@ temp = map.players[i];
if (temp is this) continue;
if (temp.following is this)
{
n.send_reliable(temp.peer_id, mess2, 0);
continue;
}
if (temp.distancecheck(this.x, this.y, this.z) < (range / temp.weaponsight))
n.send_reliable(temp.peer_id, mess, 0);
}
}
}

void sendsound(const string& in sound)
{
n.send_reliable(this.peer_id, string_encrypt("play_s " + sound, pcps), 0);
}

void ammo_give(const string& in we, int amount)
{
if (!ammo.exists(we))
{
if (amount < 1) return;
ammo.set(we, amount);
}
else
{
int a;
ammo.get(we, a);
int b = a + amount;
if (b <= 0) ammo.delete(we);
else ammo.set(we, b);
}
}

void ammo_set(const string& in rq, int amount)
{
if (!loaded_ammo.exists(rq))
{
if (amount < 1) return;
loaded_ammo.set(rq, amount);
}
else
{
int a;
loaded_ammo.get(rq, a);
int b = a + amount;
if (b <= 0) loaded_ammo.delete(rq);
else loaded_ammo.set(rq, b);
}
}

dictionary inventory;
string[]@ itemnames;

void chat(const string& in message, bool map_only = false)
{
if (this.spammedmsgs >= 10)
{
this.alert("너무 많은 메시지를 연속해서 보낼 수는 없습니다.");
return;
}
spammedmsgs++;
string mess = string_encrypt("chat " + message, pcps);
if (map_only)
{
int playerslength = this.map.players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = this.map.players[i];
if (temp.muted.exists(name)) continue;
n.send_reliable(temp.peer_id, mess, 1);
}
return;
}
int playerslength = players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = players[i];
if (temp.langchan != langchan) continue;
if (temp.muted.exists(name)) continue;
n.send_reliable(temp.peer_id, mess, 1);
}
}

void update_inv()
{
@ itemnames = inventory.keys;
}

void delete_all_inv()
{
inventory.delete_all();
@ itemnames = inventory.keys;
}

void give(const string& in item, int amount, bool update_now = true)
{
if (!inventory.exists(item))
{
if (amount < 1) return;
inventory.set(item, amount);
}
else
{
int a;
inventory.get(item, a);
int b = a + amount;
if (b < 1) inventory.delete(item);
else inventory.set(item, b);
}
if (update_now) update_inv();
}

void give_from_string(string data, bool is_filename = false)
{
if (data.is_empty()) return;
if (is_filename)
{
if (!fl.open(data, "rb")) return;
data = fl.read();
fl.close();
}
string[]@ invstuff = string_split(data, "\r\n", false);
int invstufflength = invstuff.length;
for (uint i = 0; i < invstufflength; i++)
{
string[]@ parsed2 = string_split(invstuff[i], "=", false);
if (parsed2.length == 2) give(parsed2[0], string_to_number(parsed2[1]), false);
}
this.update_inv();
}

void trackinfo(bool text = false)
{
if (this.get_smoke())
{
this.alert("자욱한 연기가 당신의 시야를 틀어막습니다.");
this.tracking_target.delete_all();
this.tracking_type = 0;
return;
}
bool major = (this.tracking_type != ascii_m);
int dir = this.facing;
double x = this.x;
double y = this.y;
double z = this.z;
if (this.map.is_vehicle)
{
vehicle@ vh = this.map.vhc;
dir += vh.facing;
x = vh.x;
y = vh.y;
z = vh.z;
}
if (dir > 359) dir -= 360;
bool success = true;
if (major) success = trackupdate();
if (success)
{
if (text)
{
mapdata@ tmap = this.map;
if (this.map.is_vehicle) @ tmap = this.map.vhc.map;
int tempflag = 0;
if ((tmap.no_coord == 0 and tmap.fighting == 0) or tmap is practice_room) tempflag++;
if (tmap.fighting == 1) tempflag += 2;
this.sendpacket("tracksend " + x + " " + y + " " + z + " " + trackx + " " + tracky + " " + trackz + " " + dir + " " + tempflag);
}
else this.sendpacket("trackplay " + x + " " + y + " " + z + " " + trackx + " " + tracky + " " + trackz + " " + dir);
return;
}
}

bool& trackupdate()
{
bool delete = true;
if (this.map.no_tracking == 0)
{
mapdata@ tmap = this.map;
if (this.map.is_vehicle) @ tmap = this.map.vhc.map;
switch (this.tracking_type)
{
case ascii_p:
{
player@ temp;
if (!this.tracking_target.get("target", @ temp))
{
this.alert("알 수 없는 오류가 발생했습니다.");
break;
}
if (temp.disconnected)
{
this.alert("대상이 게임을 나갔습니다.");
break;
}
if (temp.health <= 0)
{
this.alert("대상이 죽었습니다.");
break;
}
if (temp.hidden)
{
this.alert("대상은 숨겨진 상태입니다.");
break;
}
if (temp.invinsible)
{
this.alert("대상은 관전 중입니다.");
break;
}
if (temp.map !is tmap)
{
if (temp.map.is_vehicle)
{
vehicle@ vt = temp.map.vhc;
if (vt.map is tmap)
{
if (vt.in_smoke)
{
this.alert("대상이 있는 곳은 연기가 뿌예 정확한 위치를 볼 수 없습니다.");
if (autotrack_smoke)
{
smoke_grenade@ sg = get_nearest_smoke(vt.x, vt.y, vt.z, vt.map, this.name);
if (sg !is null)
{
delete = false;
tracking_target.delete_all();
tracking_type = ascii_m;
trackx = sg.x;
tracky = sg.y;
trackz = sg.z;
break;
}
}
break;
}
delete = false;
this.trackx = vt.x;
this.tracky = vt.y;
this.trackz = vt.z;
break;
}
}
this.alert("대상은 다른 맵에 있습니다.");
break;
}
if (temp.invisible)
{
this.alert("대상이 투명해져 감지되지 않습니다.");
break;
}
if (temp.warping and temp.warpstage == 1)
{
this.alert("대상이 갑자기 사라집니다.");
break;
}
if (temp.in_smoke)
{
this.alert("대상이 있는 곳은 연기가 뿌예 정확한 위치를 볼 수 없습니다.");
if (autotrack_smoke)
{
smoke_grenade@ sg = get_nearest_smoke(temp.x, temp.y, temp.z, tmap, this.name);
if (sg !is null)
{
delete = false;
tracking_target.delete_all();
tracking_type = ascii_m;
trackx = sg.x;
tracky = sg.y;
trackz = sg.z;
break;
}
}
break;
}
trackx = temp.x;
tracky = temp.y;
trackz = temp.z;
delete = false;
}
break; case ascii_v:
{
vehicle@ temp;
if (!this.tracking_target.get("target", @ temp))
{
this.alert("알 수 없는 오류가 발생했습니다.");
break;
}
if (temp.health <= 0)
{
this.alert("대상이 격파되었습니다.");
break;
}
if (temp.map !is tmap)
{
this.alert("대상은 다른 맵에 있습니다.");
break;
}
if (temp.in_smoke)
{
this.alert("대상이 있는 곳은 연기가 뿌예 정확한 위치를 볼 수 없습니다.");
if (autotrack_smoke)
{
smoke_grenade@ sg = get_nearest_smoke(temp.x, temp.y, temp.z, tmap, this.name);
if (sg !is null)
{
delete = false;
tracking_target.delete_all();
tracking_type = ascii_m;
trackx = sg.x;
tracky = sg.y;
trackz = sg.z;
break;
}
}
break;
}
if (temp.inside is this.map) break;
trackx = temp.x;
tracky = temp.y;
trackz = temp.z;
delete = false;
}
break; case ascii_r:
{
Robot@ temp;
if (!this.tracking_target.get("target", @ temp))
{
this.alert("알 수 없는 오류가 발생했습니다.");
break;
}
if (temp.health <= 0)
{
this.alert("대상이 격파되었습니다.");
break;
}
if (temp.in_smoke)
{
this.alert("대상이 있는 곳은 연기가 뿌예 정확한 위치를 볼 수 없습니다.");
if (autotrack_smoke)
{
smoke_grenade@ sg = get_nearest_smoke(temp.x, temp.y, temp.z, tmap, this.name);
if (sg !is null)
{
delete = false;
tracking_target.delete_all();
tracking_type = ascii_m;
trackx = sg.x;
tracky = sg.y;
trackz = sg.z;
break;
}
}
break;
}
if (temp.map !is tmap)
{
this.alert("대상은 다른 맵에 있습니다.");
break;
}
trackx = temp.x;
tracky = temp.y;
trackz = temp.z;
delete = false;
}
break;
default:
break;
}
}
if (delete)
{
this.tracking_target.delete_all();
this.tracking_type = 0;
return false_t;
}
return true_t;
}

void checksight(int order)
{
if (this.in_smoke)
{
this.alert("자욱한 연기가 당신의 시야를 방해합니다.");
return;
}
double real_range = 75 / weaponsight;
if (order == 0)
{
int totalp = 0, totalv = 0;
int playerslength = map.players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = map.players[i];
if (temp is this) continue;
if (temp.invisible) continue;
if (temp.in_smoke) continue;
if (temp.hidden) continue;
if (this.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, temp.x, temp.y, this.facing);
if (deg > this.map.tunnel_sight and deg < (360 - this.map.tunnel_sight)) continue;
}
if (rank == 0)
{
if (temp.invinsible) continue;
}
if (temp.distancecheck(x, y, z) > real_range) continue;
sm.add(temp.name, "p." + temp.name);
totalp++;
}
int vslength = map.vs.length;
for (uint i = 0; i < vslength; i++)
{
vehicle@ temp = map.vs[i];
if (temp.in_smoke) continue;
if (this.ride is temp) continue;
if (this.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, temp.x, temp.y, this.facing);
if (deg > this.map.tunnel_sight and deg < (360 - this.map.tunnel_sight)) continue;
}
if (temp.distancecheck(x, y, z) > real_range) continue;
sm.add(temp.owner + "님의 " + temp.type, "v." + temp.id);
totalv++;
}
sm.add("주시 중단", "stop");
sm.intro = totalp + "명의 사람과 " + totalv + "대의 차량이 눈에 띕니다. 무엇을 주시할까요?";
sm.initial_packet = "sight";
sm.send(this.peer_id);
sm.reset();
return;
}
string l;
bool can_view = false;
if (sightplayer !is null)
{
player@ temp = sightplayer;
if (temp.disconnected)
{
@ sightplayer = null;
this.alert("대상은 접속을 끊었습니다.");
return;
}
for (;;)
{
if (temp is this) break;
if (rank == 0)
{
if (temp.invinsible) break;
}
if (temp.hidden) break;
if (temp.map.is_vehicle)
{
vehicle@ tv = temp.map.vhc;
if (tv.in_smoke) break;
if (tv.map !is this.map) break;
if (tv.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, tv.x, tv.y, this.facing);
if (deg > tv.map.tunnel_sight and deg < (360 - tv.map.tunnel_sight)) break;
}
if (tv.distancecheck(x, y, z) > real_range) break;
}
else
{
if (temp.in_smoke) break;
if (temp.invisible) break;
if (temp.map !is this.map) break;
if (temp.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, temp.x, temp.y, this.facing);
if (deg > temp.map.tunnel_sight and deg < (360 - temp.map.tunnel_sight)) break;
}
if (temp.distancecheck(x, y, z) > real_range) break;
}
can_view = true;
break;
}
if (!can_view)
{
this.alert("지금은 보이지 않습니다.");
return;
}
if (temp.map.is_vehicle)
{
vehicle@ tv = temp.map.vhc;
if (order == 2)
{
this.alert(tv.owner + "님의_" + tv.type);
return;
}
l = tv.x + " " + tv.y + " " + tv.z;
}
else
{
if (order == 2)
{
string s = string_replace(calculate_x_y_string(calculate_x_y_angle(temp.x, temp.y, this.x, this.y, temp.facing)), " ", "_", true) + "방향을_바라보는_";
if (temp.ride !is null) s += temp.ride.type + "를_타고_있는_";
if (temp.shielded) s += "실드로_보호받는_";
if (temp.invinsible) s += "초자연의_";
if (temp.gang !is null) s += temp.gang.teamname + "_";
s += temp.name;
this.alert(s);
return;
}
l = temp.x + " " + temp.y + " " + temp.z;
}
}
else if (sightvehicle !is null)
{
vehicle@ temp = sightvehicle;
if (temp.health <= 0)
{
@ sightvehicle = null;
this.alert("그것은 이미 흔적도 없이 완파되었습니다.");
return;
}
for (;;)
{
if (temp.map !is this.map) break;
if (temp.in_smoke) break;
if (this.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, temp.x, temp.y, this.facing);
if (deg > this.map.tunnel_sight and deg < (360 - this.map.tunnel_sight)) break;
}
if (temp.distancecheck(x, y, z) > real_range) break;
can_view = true;
break;
}
if (!can_view)
{
this.alert("지금은 보이지 않습니다.");
return;
}
if (order == 2)
{
this.alert(temp.owner + "님의_" + temp.type);
return;
}
l = temp.x + " " + temp.y + " " + temp.z;
}
if (l.is_empty())
{
this.alert("아무것도 주시하고 있지 않습니다.");
return;
}
int tempflag = 0;
if (this.map.no_coord == 0 and this.map.fighting == 0) tempflag++;
if (this.map.fighting == 1) tempflag += 2;
this.sendpacket("tracksend " + this.x + " " + this.y + " " + this.z + " " + l + " " + this.facing + " " + tempflag);
}

int count_total_items()
{
int amount = 0;
int inventorylength = itemnames.length;
for (uint i = 0; i < inventorylength; i++)
{
int a;
inventory.get(itemnames[i], a);
amount += a;
}
return amount;
}

int get_item_count(const string& in item)
{
int amount = 0;
if (!inventory.get(item, amount)) return 0;
return amount;
}

void work(int index)
{
workingtype = index;
workingtimer.force(0);
if (!this.stunned) this.sendpacket("stopmoving");
}

void stun(int ms, bool playaf = false, bool fall = false, int cooldown = 0, bool add = false)
{
if (!add)
{
if (this.stunagaintimer.elapsed <= this.stunagaintime) return;
}
this.stunagaintime = 0;
this.stunagaintimer.force(0);
this.sendpacket("stopmoving");
stunned = true;
stuntime = (add ? stuntime + ms : ms);
stuntimer.force(0);
this.stunagaintime = stuntime + cooldown;
unstunplay = playaf;
if (fall)
{
spawn_bodyfall(x, y, z, map, 500, this);
this.invisible = false;
this.invisibilitytimer.force(0);
}
this.fire_stop(false);
this.gathering_stop(false);
}

bool& cheatercheck()
{
if (this.cheater == 1) return false_t; // server already caught it in reception of close
// early play cheater
if (this.statchangetimer.elapsed < 15000)
{
if ((this.map.is_vehicle and this.map.vhc.map.fighting == 1) or this.map.fighting == 1) return true_t;
}
// missile cheater
int missileslength = map.missiles.length;
for (uint i = 0; i < missileslength; i++)
{
missile@ temp = map.missiles[i];
if (this.name != temp.targetname) continue;
int missiledist = temp.distancecheck(this.x, this.y, this.z);
if (missiledist <= 50) return true_t;
}
// ultra bomb cheater
int ultrabombslength = map.ultrabombs.length;
for (uint i = 0; i < ultrabombslength; i++)
{
ultrabomb@ temp = map.ultrabombs[i];
if (!temp.d) continue;
int distance = temp.distancecheck(this.x, this.y, this.z);
if (distance < 80) return true_t;
}
return false_t;
}
}

void playerloop()
{
for (int i = players.length - 1; i > -1; i--)
{
player@ this = players[i];
if (this.rank == 5)
{
  // adminflag가 1일 때
  if (this.adminflag == 1)
  {
    // hidden을 true로 설정
    this.hidden = true;
  }
  // adminflag가 0일 때
  else if (this.adminflag == 0)
  {
    // hidden을 false로 설정
    this.hidden = false;
  }
}
// rank가 5가 아닐 때
else
{
  // 아무것도 하지 않음
}
if (this.disconnected)
{
players.remove_at(i);
continue;
}

int updated = 0;
if (this.facing != this.oldfacing)
{
this.oldfacing = this.facing;
updated = 1;
}
if (this.oldx != this.x)
{
this.oldx = this.x;
this.rx = round(this.x, 0);
updated = 2;
}
if (this.oldy != this.y)
{
this.oldy = this.y;
this.ry = round(this.y, 0);
updated = 2;
}
if (this.oldz != this.z)
{
this.oldz = this.z;
updated = 2;
}
if (this.map !is this.oldmap)
{
@ this.oldmap = this.map;
updated = 3;
}
if (updated > 0)
{
if (updated == 2)
{
if (this.bleedsound !is null) this.bleedsound.update(this.x, this.y, this.z);
if (this.grabsound !is null) this.grabsound.update(this.x, this.y, this.z);
if (this.parachutesound !is null) this.parachutesound.update(this.x, this.y, this.z);
if (this.weapongatheringsound !is null) this.weapongatheringsound.update(this.x, this.y, this.z);
}
if (!this.follower.is_empty()) this.drag();
}
if (this.spammedmsgs > 0)
{
if (this.spamtimer.elapsed > 5000)
{
this.spamtimer.force(0);
this.spammedmsgs = 0;
}
}
if (this.cheater == 1)
{
if (this.cheatertimer.elapsed >= 30000)
{
this.statchangetimer.force(0);
this.cheater = 0;
this.cheatertimer.force(0);
this.alert("이제 플레이 가능합니다.");
this.playsound("confirmation");
this.sendpacket("startmoving");
this.save();
}
}
if (!this.death and !this.invinsible and !this.hidden)
{
if (this.map is default_sv and this.map.players.length > 1)
{
if (this.survivalrewardtimer.elapsed >= 1000)
{
this.survivalrewardtimer.force(0);
this.survivalreward += ((this.map.players.length - 1) * 500);
}
}
}
if (this.fps > 0)
{
this.fps++;
if (this.fpstimer.elapsed > 999)
{
this.fpstimer.force(0);
this.alert("루프 속도 " + maintime + ", 업데이트 속도 " + this.fps + " FPS.", true);
this.fps = 0;
}
}
if (this.accumulated_damage > 0)
{
if (!this.temp_invinsible)
{
this.health -= this.accumulated_damage;
if (this.health > 0) this.playsound("hit" + this.voice + random(1, 5));
}
this.accumulated_damage = 0;
}
if (this.weapon !is null)
{
if (this.weaponchecktimer.elapsed >= 500)
{
this.weaponchecktimer.force(0);
if (!this.check_draw_req(this.weapon))
{
if (this.draw_weapon(this.main_weapon.type) is null) this.draw_weapon("fists");
}
if (is_no_item(this.rx, this.ry, this.z, this.map, this.weapon.type))
{
if (this.draw_weapon(this.main_weapon.type) is null) this.draw_weapon("fists");
}
}
}

if (!this.hidden)
{
if (this.in_smoke)
{
if (this.smoketimer.elapsed >= 510) this.in_smoke = false;
}
if (this.tracksound)
{
if (this.tracking_type > 0)
{
if (this.trackingtimer.elapsed > 300)
{
this.trackingtimer.force(0);
this.trackinfo(false);
}
}
}
if (this.sightvehicle !is null)
{
if (this.beaconvtimer.elapsed >= this.beacontime)
{
this.beaconvtimer.force(0);
vehicle@ temp = this.sightvehicle;
if (temp.health <= 0)
{
@ this.sightvehicle = null;
this.alert("대상은 완파되었습니다.");
return;
}
for (;;)
{
if (this.in_smoke)  break;
if (temp.in_smoke) break;
if (temp.map !is this.map) break;
if (temp.distancecheck(this.x, this.y, this.z) > ((75 / this.map.pan_step) / this.weaponsight)) break;
if (this.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(this.x, this.y, temp.x, temp.y, this.facing);
if (deg > this.map.tunnel_sight and deg < (360 - this.map.tunnel_sight)) break;
}
send(this.peer_id, "play_3ds beacon " + temp.x + " " + temp.y + " " + temp.z, 3);
break;
}
}
}
if (this.beacontimer.elapsed >= this.beacontime)
{
if (!this.invisible and !this.invinsible and !this.hidden and !this.in_smoke and this.map !is minigame_room)
{
this.beacontimer.force(0);
int range = 75 / this.map.pan_step;
int plength = this.map.players.length;
for (uint pl = 0; pl < plength; pl++)
{
player@ temp = this.map.players[pl];
if (temp is this) continue;
if (temp.following is this) continue;
if (temp.in_smoke) continue;
bool is_sighted = (temp.sightplayer is this);
if (temp.beacon <= 0)
{
if (!is_sighted) continue;
}
if (this.map.tunnel_sight > 0)
{
int deg = calculate_x_y_angle(temp.x, temp.y, this.x, this.y, temp.facing);
if (deg > this.map.tunnel_sight and deg < (360 - this.map.tunnel_sight)) continue;
}
if (temp.distancecheck(this.x, this.y, this.z) > (range / temp.weaponsight)) continue;
if (is_sighted)
{
send(temp.peer_id, "play_3ds beacon " + this.x + " " + this.y + " " + this.z, 3);
continue;
}
if (temp.gang !is null)
{
if (temp.gang is this.gang)
{
send(temp.peer_id, "play_3ds beaconteam " + this.x + " " + this.y + " " + this.z, 3);
continue;
}
}
send(temp.peer_id, "play_3ds beaconenemy " + this.x + " " + this.y + " " + this.z, 3);
}
}
}
if (this.weaponping)
{
this.weaponping = false;
this.sendsound("weaponping");
}
if (this.weaponping_head)
{
this.weaponping_head = false;
this.sendsound("weaponheadshot");
}
if (this.weaponping_team)
{
this.weaponping_team = false;
this.sendsound("weaponpingteam");
}
if (this.stunned)
{
if (this.unstuntrys > 0)
{
if (this.unstuntrys > (this.stuntime / 200))
{
this.unstuntrys = 0;
this.stuntimer.force(this.stuntime);
}
else if (this.unstuntrytimer.elapsed > 700)
{
this.unstuntrytimer.force(0);
this.unstuntrys--;
}
}
if (this.stuntimer.elapsed >= this.stuntime)
{
this.stuntimer.force(0);
this.stunned = false;
if (!this.invinsible)
{
if (!this.dmoving)
{
if (!this.working()) this.sendpacket("startmoving");
}
}
if (this.unstunplay) this.playsound("stun_dartstop");
}
}
if (this.poisoned >= 1)
{
if (this.poisontimer.elapsed >= 1000)
{
this.poisontimer.force(0);
if (this.temp_invinsible) this.poisoned = 0;
else
{
this.health -= random(this.poisoned * 1, this.poisoned * 150);
this.hitby = "internal:poison";
}
}
}
if (this.energy < 0) this.energy = 0;
else if (this.energy > 0)
{
if (this.energy > this.maxenergy) this.energy = this.maxenergy;
if (this.energytimer.elapsed >= 1000)
{
this.energytimer.force(0);
this.energy--;
if (this.oldenergy != this.energy)
{
this.oldenergy = this.energy;
this.sendpacket("walkmod " + round(this.origin_walktime * this.bonus_walktime * ((this.maxenergy * 2) / (this.energy + this.maxenergy)), 0));
}
}
}
if (this.origin_jump != this.origin_jump_old or this.bonus_jump != this.bonus_jump_old)
{
this.origin_jump_old = this.origin_jump;
this.bonus_jump_old = this.bonus_jump;
this.sendpacket("jumpset " + round(this.origin_jump * this.bonus_jump, 0));
}
if (this.air > 250) this.air = 250;
if (this.mask == 1)
{
if (this.airtimer.elapsed >= 3500)
{
this.airtimer.force(0);
if (this.air > 0)
{
this.air--;
this.playsound("gas_mask_breathe");
}
else
{
this.alert("숨이 턱 막힙니다.");
this.hitby = "internal:suffocate";
this.health -= random(8000, 10000);
}
}
}
if (this.underwater)
{
if (this.mask == 0)
{
if (this.airwarntimer.elapsed >= 15000)
{
this.airwarntimer.force(0);
this.alert("숨이 턱 막힙니다.");
}
if (this.airlifetimer.elapsed >= 60015)
{
this.airlifetimer.force(0);
this.hitby = "internal:drown";
this.death = true;
}
}
}
if (this.reloading > 0)
{
if (this.firetimer.elapsed >= firetime_starter) this.reloading = 0;
}
if (this.weapon !is null)
{
if (this.weapongathering)
{
if (this.weapongatheringtimer.elapsed >= this.weapon.gathering_max)
{
this.gathering_stop(true, false);
}
}
if (this.overheat_level < 100.0)
{
if (this.overheattimer.elapsed >= 1000)
{
this.overheattimer.force(0);
this.overheat_level -= this.weapon.overheat_decrease;
if (this.overheat_level < 0.0) this.overheat_level = 0.0;
}
}
else
{
if (this.overheattimer.elapsed >= this.weapon.overheattime)
{
this.overheattimer.force(0);
this.overheat_level -= 100.0;
}
}
if (this.firing)
{
int shot_level = 0;
bool final_shot = false;
if (this.overheat_level < 100.0 and this.firetimer.elapsed >= firetime_starter)
{
shot_level = 1;
if (!this.weapon.require_ammo.is_empty())
{
if (this.weapon.max_ammo == 0)
{
int am = this.get_item_count(this.weapon.require_ammo);
if (am >= 1)
{
shot_level = 2;
if (am == 1) final_shot = true;
}
else
{
shot_level = 0;
this.fire_stop();
}
}
else
{
int curr = this.get_ammo_count(this.weapon_group);
if (curr > 0)
{
shot_level = 2;
if (curr == 1) final_shot = true;
}
else
{
shot_level = 0;
this.fire_stop();
}
}
}
}
if (shot_level > 0)
{
this.shot_count++;
weapon@ temp = spawn_weapon(this.x, this.y, this.z, this.facing, this.weapon.type, this.map, this, empty, 1);
if (this.weapon.shot_limit > 0)
{
if (this.shot_count >= this.weapon.shot_limit)
{
this.fire_stop();
}
}
if (temp is null)
{
this.firetimer.force(firetime_starter);
this.fire_stop();
}
else
{
if (temp.gathering_current > 0) this.weapongatheringtimer.force(0);
if (shot_level >= 2)
{
if (this.weapon.max_ammo == 0) this.give(this.weapon.require_ammo, -1);
else
{
this.ammo_give(this.weapon_group, -1);
this.ammo_set(this.weapon.require_ammo, -1);
if (final_shot)
{
if (this.weapon.empty_ping > 0) this.playsound(this.weapon.empty_ping_sound + random(1, this.weapon.empty_ping));
this.fire_stop();
}
}
}
}
}
}
}
if (this.warping) this.warpcheck();
if (this.health < 1500)
{
if (!this.lowhealth)
{
this.lowhealth = true;
this.sendpacket("lowhealth " + this.health);
}
}
else
{
if (this.lowhealth)
{
this.lowhealth = false;
this.sendpacket("goodhealth");
}
}
if (this.newb == 1)
{
if (this.newbtimer.elapsed >= 3600000)
{
this.newbtimer.force(0);
this.alert("시간이 다 되었습니다.");
this.newb = 2;
}
}
else if (this.newb == 2)
{
if (this.newbtimer.elapsed >= 3000)
{
this.newb = 0;
this.newbtimer.force(0);
if (this.map.name == "입문") this.go_to("세이프존", 10, 10, 0, false);
this.alert("입문자를 졸업했습니다.");
string message = this.name + "님이 입문자를 졸업했습니다.";
send(0, "notify " + message, 0);
log("system_message", message);
this.save();
}
}
this.shieldshots = (this.shieldshots < 0 ? 0 : this.shieldshots > this.maxshields ? this.maxshields : this.shieldshots);
if (!this.shielded)
{
if (this.shieldshots > 0) this.shielded = true;
}
else
{
if (this.shieldshots <= 0)
{
this.shielded = false;
this.playsound("shieldbreak");
this.hurtlevel *= 1.25;
this.hurttimer.force(0);
}
}
if (this.hurtlevel > 3)
{
if (this.bleedsound is null) @ this.bleedsound = spawn_moving_sound("bleeding", this.x, this.y, this.z, this.map, this, 100.0, true);
}
else
{
if (this.bleedsound !is null) @ this.bleedsound = this.bleedsound.destroy();
}
if (this.hurtlevel > 1)
{
if (this.hurttimer.elapsed >= 3000)
{
this.hurttimer.force(0);
this.hurtlevel *= 0.8;
this.hurtlevel = (this.hurtlevel < 1 ? 1 : this.hurtlevel > 100 ? 100 : this.hurtlevel);
}
}
if (!this.no_save)
{
if (this.playtimer.elapsed >= 86400000) this.add_achievement("이런 재미 없는 게임을 24시간이나...", "1 membership_card", true);
}
else
{
if ((this.map.is_vehicle ? this.map.vhc.map : this.map) is default_sv)
{
if (this.survival_warning == 0)
{
if (this.survivaltimer.elapsed >= 5400000)
{
this.survival_warning = 1;
this.alert("경고: 눌러 앉기 방지를 위해 10분 후 자동으로 죽습니다.", true);
this.playsound("motdstart");
}
}
else
{
if (this.survivaltimer.elapsed >= 6000000)
{
this.hitby = "눌러앉기 금지 조항";
this.remove_equipments();
this.delete_all_inv();
this.death = true;
}
}
}
}
if (this.health != this.oldhealth)
{
if (this.health < this.oldhealth) this.statchangetimer.force(0);
this.oldhealth = this.health;
if (this.lowhealth) this.sendpacket("lowhealth " + this.health);
}
if (this.antibioticed)
{
if (this.antibiotictimer.elapsed >= 500)
{
this.antibiotictimer.force(0);
this.health += (10.0 - (this.health * 9.0 / this.maxhealth)) * 80.0;
if (this.poisoned >= 1) this.poisoned -= 3;
}
if (this.awarnouttimer.elapsed >= 20000)
{
this.awarnouttimer.force(0);
this.antibioticed = false;
this.statchangetimer.force(0);
}
}
if (this.power_up)
{
if (this.power_up_timer.elapsed >= (70000 - (this.dope_withdrawal * 30)))
{
this.power_up = false;
this.alert("약발이 다하여 금단 증상이 당신을 덮칩니다.");
}
}
else
{
if (this.dope_withdrawal > 0)
{
if (this.dopetimer.elapsed >= 1000)
{
this.dopetimer.force(0);
this.health -= this.dope_withdrawal;
this.energy -= (this.dope_withdrawal * 0.1);
this.hitby = "internal:withdrawal";
this.dope_withdrawal--;
}
}
}
if (this.invinsibility_starting)
{
if (this.invseconds > 0)
{
if (this.invinsibilitytimer.elapsed >= 1000)
{
this.invinsibilitytimer.force(0);
if (this.invseconds != 0) this.playsound("invtimer");
this.invseconds--;
}
}
else
{
this.invinsibility_starting = false;
this.invseconds = 5;
this.invinsible = true;
this.sendpacket("stopmoving");
if (this.rank < 1) send(0, "notify " + this.name + "님이 관전 모드를 켰습니다.", 0);
this.playsound("invstart");
}
}
if (this.rank > 4)
{
this.health = 2100000000;
this.oldhealth = 2100000000;
}
if (this.health > this.maxhealth)
{
this.health = this.maxhealth;
this.oldhealth = this.maxhealth;
if (this.rank > 4)
{
this.health = 2100000000;
this.oldhealth = 2100000000;
}
if (this.antibioticed)
{
this.antibioticed = false;
this.alert("당신은 이제 최상의 컨디션입니다.");
}
}
if (this.invisible)
{
if (this.invisibilitytimer.elapsed >= 20000)
{
this.invisible = false;
this.playsound("invisibility_stop");
this.invisibilitytimer.force(0);
this.statchangetimer.force(0);
}
}
if (this.temp_invinsible)
{
    if (this.temp_invinsibletimer.elapsed >= 35000)
{
if (this.rank != 5)
{
this.temp_invinsible = false;
this.alert("30초 부활 무적이 끝납니다.");
}
}
}
if (this.deathfreecards > 0)
{
if (this.deathfreetimer.elapsed >= 220000)
{
this.deathfreecards = 0;
this.playsound("dfcoff");
}
}
if (this.frequency)
{
if (this.frequencyscramblertimer.elapsed >= 30000)
{
this.frequency = false;
this.playsound("frequency_scrambleroff");
}
}
bool completed = false;
switch (this.workingtype)
{
case pc_robot_spawning:
{
if (this.workingtimer.elapsed > 4200)
{
completed = true;
if (this.map.fighting == 0) break;
Robot@ temp = robot_spawn(this.robotname, this.x, this.y, this.z, this.map, 0, empty, null, this.name);
if (temp !is null) this.robotspawntimer.force(robotspawn_origin - (temp.level * 1500));
this.temp_invinsible = false;
}
}
break; case pc_lockerplacing:
{
if (this.workingtimer.elapsed >= 47000)
{
completed = true;
int newlockcode = random(1000, 9999);
create_new_locker(this.x, this.y, this.z, this.name, string_to_number("0." + newlockcode));
this.sendpacket("clip " + newlockcode);
this.alert("사설 금고의 암호가 클립보드로 복사됩니다.");
}
}
break; case pc_ultrabombplacing:
{
if (this.workingtimer.elapsed >= 4900)
{
completed = true;
if (this.map.fighting == 0) break;
spawn_ultrabomb(this.rx, this.ry, this.z, this.map, this.name);
this.temp_invinsible = false;
}
}
break; case pc_sbombplacing:
{
if (this.workingtimer.elapsed >= 11000)
{
completed = true;
if (this.map.fighting == 0) break;
spawn_security_bomb(this.x, this.y, this.z, this.map, this.name, this);
this.alert("설치했습니다.");
this.temp_invinsible = false;
}
}
break; case pc_remconnecting:
{
if (this.workingtimer.elapsed >= (this.remguntype == 1 ? 9000 : 6343))
{
completed = true;
if (this.map.fighting == 0) break;
placeremgun(this.x, this.y, this.z, this.map, this.name, this.remguncount, this.remguntype == 1);
this.remguncount = 0;
this.remguntype = 0;
this.temp_invinsible = false;
}
}
break; case pc_setting_parachute:
{
if (this.workingtimer.elapsed >= 3200)
{
completed = true;
if (!is_fallable(this.x, this.y, this.z, this.map)) break;
if (this.parachutesound is null) @ this.parachutesound = spawn_moving_sound("parachute_loop", this.x, this.y, this.z, this.map, this, 100.0, true);
this.parachutist = true;
}
}
break; case pc_intercepting:
{
if (this.workingtimer.elapsed >= 775)
{
completed = true;
missile_intercept(this.x, this.y, this.z, this.map, this, 35);
}
}
break; case pc_eat:
{
if (this.nextsnack is null)
{
completed = true;
break;
}
if (this.workingtimer.elapsed >= this.nextsnack.time)
{
completed = true;
this.energy += random(this.nextsnack.minfood, this.nextsnack.maxfood);
this.health += random(this.nextsnack.minhealth, this.nextsnack.maxhealth);
@ this.nextsnack = null;
}
}
break; case pc_street_drugging:
{
if (this.workingtimer.elapsed >= 1500)
{
completed = true;
this.hurtlevel *= 0.8;
if (this.hurtlevel < 1) this.hurtlevel = 1;
if (!this.power_up and this.dope_withdrawal > 0)
{
this.dope_withdrawal -= 20;
if (this.dope_withdrawal < 0) this.dope_withdrawal = 0;
}
}
}
break; case pc_item_grabbing:
{
if (this.workingtimer.elapsed >= 24900)
{
completed = true;
this.playsound("itemgrabberfire");
playmap("itemgrabbdist", this.map, this);
this.objcheck(100);
if (this.grabsound !is null) @ this.grabsound = this.grabsound.destroy();
}
}
break; case pc_shielding:
{
if (this.workingtimer.elapsed >= 1500)
{
completed = true;
this.shieldshots = 300;
if (!this.no_save) this.add_achievement("첫번째 실드", "500000 coin", false);
}
}
break; case pc_shield_repairing:
{
if (this.workingtimer.elapsed >= 350)
{
completed = true;
this.shieldshots = this.nextshields;
this.nextshields = 0;
}
}
break; case pc_frequency_on:
{
if (this.workingtimer.elapsed >= 2000)
{
completed = true;
this.frequency = true;
}
}
break;
}
if (completed)
{
this.workingtype = pc_stop;
if (!this.stunned) this.sendpacket("startmoving");
}
}

if (this.health <= 0)
{
if (this.map is practice_room) this.health = this.maxhealth;
else if (this.deathfreecards > 0)
{
this.playsound("dfc");
this.health = 1;
if (this.health != this.oldhealth)
{
this.oldhealth = 1;
this.lowhealth = true;
this.sendpacket("lowhealth 1");
}
}
else this.death = true;
}
if (this.death)
{
this.death = false;
if (this.deadtimer.elapsed < 5000) continue;
this.deadtimer.force(0);
this.temp_invinsible = true;
this.temp_invinsibletimer.force(0);
if (this.death_sound.is_empty())
{
this.playsound("death" + this.voice + random(1, 5));
this.playsound("kill" + random(1, 4));
sendmap("hardland " + this.x + " " + this.y + " " + this.z, this.map, 0);
}
else
{
this.playsound(this.death_sound);
this.death_sound.resize(0);
}
playmap("kill", this.map, this);
if (this.bleedsound !is null) @ this.bleedsound = this.bleedsound.destroy();
if (this.grabsound !is null) @ this.grabsound = this.grabsound.destroy();
if (this.parachutesound !is null) @ this.parachutesound = this.parachutesound.destroy();
if (this.xmsound !is null) @ this.xmsound = this.xmsound.destroy();
if (this.xmsoundplus !is null) @ this.xmsoundplus = this.xmsoundplus.destroy();
this.gathering_stop(false);
this.lowhealth = false;
this.robotname.resize(0);
this.sendpacket("goodhealth");
if (this.cremguns)
{
this.cremguns = false;
this.sendpacket("remcontrolstop");
}
this.underwater = false;
this.dmoving = false;
this.frequency = false;
this.invinsibility_starting = false;
this.invisible = false;
this.hurtlevel = 1;
this.poisoned = 0;
this.power_up = false;
this.dope_withdrawal = 0;
this.health = 25000;
this.oldhealth = 25000;
this.fire_stop(false);
this.reloading = 0;
send(0, "playerdeath " + killmsg(this.name, this.hitby, get_zone_at(this.x, this.y, this.z, this.map), this.hit_head), 0);
if (!this.no_save)
{
this.deaths++;
if (this.should_subtract)
{
if (!this.itemnames.is_empty())
{
string choice;
int count = 0;
do
{
count++;
choice = this.itemnames[random(0, (this.itemnames.length - 1))];
}
while (count < 11 and dontlosedict.exists(choice));
if (count < 11)
{
int lost = round((this.get_item_count(choice) * random(1, 5) / 100), 0);
if (lost > 0)
{
this.give(choice, -lost);
this.alert(choice + " " + lost + "개를 벌칙으로 잃었습니다.", true);
}
}
}
}
}
else
{
this.survivaltimer.force(0);
this.survival_warning = 0;
this.remove_equipments();
this.draw_weapon("fists");
this.sendpacket("weaponlist " + wnames);
if (this.map.is_vehicle)
{
vehicle@ vv = this.map.vhc;
if (this.hitby != "눌러앉기 금지 조항" and vv.map.no_corpse == 0) new_corpse(vv.x, vv.y, vv.z, vv.map, this.name, dictionary_to_text(this.inventory));
}
else if (this.hitby != "눌러앉기 금지 조항" and this.map.no_corpse == 0) new_corpse(this.x, this.y, this.z, this.map, this.name, dictionary_to_text(this.inventory));
this.delete_all_inv();
this.shieldshots = 0;
this.air = 0;
this.energy = 25000;
this.antibioticed = false;
this.shielded = false;
this.deathfreecards = 0;
this.a.delete_all();
this.inventory = this.map.starting_items;
@ this.itemnames = this.inventory.keys;
}
@ this.deadmap = (this.map.is_vehicle ? this.map.vhc.map : this.map);
this.go_to("대기실", random(2, 32765), random(2, 32765), random(-16381, 16381), false, true);
this.sendpacket("resizemsound", 4);
if (this.hitby == "화마") this.add_achievement("불타오르네", "20 fire_extinguisher", true);
string hb;
string[]@ parsed_data = string_split(this.hitby, "의 ", true);
hb = parsed_data[0];
player@ temp = get_player_handle(hb);
if (temp !is null)
{
if (temp.name != this.name)
{
bool demerit_mark = false;
if (parsed_data.length > 1) demerit_mark = trapitems.exists(string_replace(parsed_data[1], " ", "_", true));
if (!demerit_mark)
{
int extracoins;
if (temp.no_save)
{
int killdiff = this.kills - temp.kills;
if (killdiff < 0) killdiff = 0;
extracoins = (killdiff + 2) * random(5000, 10000) + this.kills * random(2000, 3000);
}
else extracoins = 20000 + (random(225000, 250000) / (power(10, (this.rating - temp.rating) * 0.0025) + 1)) + this.kills * random(400, 600);
if (this.hit_head) extracoins *= 2;
temp.give("coin", extracoins);
temp.alert("보상으로 " + extracoins + " coin을 받습니다.", true);
}
temp.kills++;
int kk = 40;
if (demerit_mark) kk = 20;
if (temp.rank < 1)
{
if (this.rank < 1)
{
int rv = kk * (1 - 1 / (power(10, (this.rating - temp.rating) * 0.0025) + 1));
temp.rating += rv;
this.rating -= rv;
if (temp.no_save)
{
if (this.no_save)
{
double current = this.survivalreward / 10;
temp.survivalreward += current;
this.survivalreward -= current;
rv = kk * (1 - 1 / (power(10, (this.sv_rating - temp.sv_rating) * 0.0025) + 1));
temp.sv_rating += rv;
this.sv_rating -= rv;
}
}
}
}
if (temp.gang !is null and this.gang !is null)
{
if (temp.gang !is this.gang)
{
int l = random(250, 500);
this.gang.points -= l;
this.gang.transmit("소속 조직이 포인트 " + l + "점을 잃었습니다.");
l = random(500, 1000);
temp.gang.points += l;
temp.gang.transmit("소속 조직에게 " + l + "점의 보너스가 주어집니다.");
temp.gang.teamkills++;
}
}
}
}
achloop(hb, this.name);
this.hit_head = false;
this.should_subtract = false;
this.workingtype = pc_stop;
this.sitting = 0;
this.statchangetimer.force(60000);
this.sendpacket("death");
this.save();
this.sendpacket("stopmoving");
this.stunagaintimer.force(0);
this.stuntimer.force(0);
this.stuntime = 5000;
this.stunagaintime = 0;
this.stunned = true;
this.unstunplay = false;
}
}
}

void playerloop(mapdata@ map)
{
for (int i = map.players.length - 1; i > -1; i--)
{
player@ temp = map.players[i];
if (temp.disconnected)
{
map.players.remove_at(i);
continue;
}
if (temp.map !is map)
{
temp.map.players.insert_last(temp);
map.players.remove_at(i);
continue;
}
}
}

void spawn_player(const string& in name, int pi, const string& in cid, const string& in ver, const string& in ip, const string& in ctext)
{
player pt;
savedata ns;
ns.fn = "./chars/" + name + ".usr";
@ pt.sf = ns;
pt.name = name;
pt.name_hash = string_to_hash(name);
pt.peer_id = pi;
pt.compid = cid;
pt.version = ver;
pt.ip = ip;
pt.ctext = ctext;
pt.load(false);
if (pt.cheater == 1)
{
pt.sendsound("warn5");
pt.sendpacket("stopmoving");
pt.cheatertimer.force(0);
}
if (pt.warnlevel > 0)
{
pt.sendsound("warn" + pt.warnlevel);
pt.sendpacket("dlg 당신은 경고를 받았습니다: " + pt.warning + ". /경고확인 명령어를 사용하여 내용을 확인하세요.");
}
pt.sendpacket("weaponlist " + wnames);
pt.oldhealth = pt.health;
pt.invusetimer.force(60000);
pt.frequencyscramblertimer.force(60000);
pt.statchangetimer.force(60000);
pt.deadtimer.force(5000);
pt.robotspawntimer.force(robotspawn_origin);
pt.firetimer.force(firetime_starter);
pt.alert("Street Program " + (beta ? "베타 " : empty) + "서버에 오신 것을 환영합니다. 현재 버전은 " + version + "입니다. 새소식: " + oldmotd, true);
pt.sendsound("welcome");
if (pt.hidden)
{
pt.sendsound("pm");
pt.alert("당신은 현재 숨겨져 있습니다.", true);
}
else send(0, "online " + pt.x + " " + pt.y + " " + pt.z + " " + pt.name + " " + pt.map.name, 0);
if (pt.gang !is null)
{
if (pt.gang.members.exists(pt.name))
{
pt.gang.online.insert_last(pt);
pt.alert(pt.gang.teamname + " 조직에 복귀했습니다.", true);
if (!pt.hidden) send(pt.peer_id, pt.name + "님은 " + pt.gang.teamname + " 조직 소속입니다.", 2, true);
}
else
{
pt.alert("애석하게도 " + pt.gang.teamname + " 조직은 해산되었습니다.", true);
@ pt.gang = null;
}
}
if (pt.rank > 0 and !pt.hidden)
{
if (pt.rank < 3) send(pt.peer_id, pt.name + "님은 운영자입니다.", 2, true);
else
{
pt.sendsound("isdev");
send(pt.peer_id, pt.name + "님은 개발자입니다.", 2, true);
}
}
players.insert_last(pt);
pt.map.players.insert_last(pt);
player_list.set(pt.name, @ pt);
pid_list.set(pt.peer_id, @ pt);
compid_list.set(pt.compid, @ pt);
connections++;
}

player@ get_player_handle(const string& in name)
{
if (!player_list.exists(name)) return null;
player@ temp;
player_list.get(name, @ temp);
return temp;
}

player@ get_pid_handle(const string& in name)
{
if (!pid_list.exists(name)) return null;
player@ temp;
pid_list.get(name, @ temp);
return temp;
}

player@ get_cid_handle(const string& in name)
{
if (!compid_list.exists(name)) return null;
player@ temp;
compid_list.get(name, @ temp);
return temp;
}

player@ get_nearest_player(int px, int py, int pz, mapdata@ pmap, player@ ph)
{
int current_distance = -1;
int final_index = -1;
int playerslength = pmap.players.length;
for (uint i = 0; i < playerslength; i++)
{
player@ temp = pmap.players[i];
if (ph !is null)
{
if (ph is temp) continue;
}
if (temp.invisible) continue;
if (temp.invinsible) continue;
if (temp.hidden) continue;
int dist = temp.distancecheck(px, py, pz);
if (current_distance != -1)
{
if (dist >= current_distance) continue;
}
current_distance = dist;
final_index = i;
}
if (final_index < 0) return null;
return pmap.players[final_index];
}

int remove_player(const string& in name = empty, bool got_kicked = false, bool save = true)
{
if (!name.is_empty())
{
player@ temp = get_player_handle(name);
if (temp is null) return 0;
temp.remove(got_kicked, save);
player_list.delete(name);
pid_list.delete(temp.peer_id);
compid_list.delete(temp.compid);
return 1;
}
int result = players.length;
for (uint i = 0; i < result; i++)
{
players[i].remove(got_kicked, save);
}
player_list.delete_all();
pid_list.delete_all();
compid_list.delete_all();
players.resize(0);
return result;
}

class pld
{
double value;
player@ handle;
int opCmp(pld@ o)
{
return (o.value < value ? -1 : o.value > value ? 1 : 0);
}
}

string[]& nearest_player_sorted_array(player@ p)
{
pld@[] t;
int playerslength = p.map.players.length;
t.reserve(playerslength);
for (uint i = 0; i < playerslength; i++)
{
player@ tp = p.map.players[i];
if (tp.health <= 0) continue;
if (tp.hidden) continue;
if (tp.invinsible) continue;
if (tp.newb == 1) continue;
if (tp is p) continue;
pld temp;
@ temp.handle = tp;
temp.value = tp.distancecheck(p.x, p.y, p.z);
t.insert_last(temp);
}
if (t.is_empty()) return empty_s;
t.sort_descending();
ref_string_array.resize(0);
int tlength = t.length;
ref_string_array.reserve(tlength);
for (uint i = 0; i < tlength; i++)
{
ref_string_array.insert_last(t[i].handle.name);
}
return ref_string_array;
}

bool are_teamed(const string& in pn1, const string& in pn2, bool prevent_overlap = false)
{
if (pn1 == pn2) return !prevent_overlap;
if (player_list.exists(pn1) and player_list.exists(pn2))
{
player@ p1;
player_list.get(pn1, @ p1);
player@ p2;
player_list.get(pn2, @ p2);
if (p1.gang is null) return false_t;
if (p2.gang is null) return false_t;
if (p1.gang is p2.gang) return true_t;
return false_t;
}
int tx1 = is_in_team(pn1);
if (tx1 == -1) return false_t;
int tx2 = is_in_team(pn2);
if (tx2 == -1) return false_t;
if (tx1 == tx2) return true_t;
return false_t;
}

bool are_teamed(player@ pn1, player@ pn2, bool prevent_overlap = false)
{
if (pn1 is pn2) return !prevent_overlap;
if (pn1.gang is null) return false_t;
if (pn2.gang is null) return false_t;
if (pn1.gang is pn2.gang) return true_t;
return false_t;
}

int select_random_player(dictionary noname = empty_d)
{
int[] indexs;
int playerslength = players.length;
indexs.reserve(playerslength);
for (uint i = 0; i < playerslength; i++)
{
player@ temp = players[i];
if (temp.invinsible) continue;
if (temp.hidden) continue;
if (temp.invisible) continue;
if (noname.exists(temp.name)) continue;
indexs.insert_last(i);
}
if (indexs.is_empty()) return -1;
return indexs[random(0, indexs.length - 1)];
}

class chartime
{
string name, extrainfo;
float lastlog;
int opCmp(chartime@ otherlog)
{
return (this.lastlog > otherlog.lastlog ? 1 : this.lastlog < otherlog.lastlog ? -1 : 0);
}
}
// moving sound서버 소스코드
enum stationarymodes
{
STATIONARY_NONE, STATIONARY_OWNER, STATIONARY_ALL
}
dictionary msounds;
class msound
{
bool remove = false;
string id, soundloop;
player@ owner;
uint owner_hash = 0;
double x, y, z;
double pitch;
mapdata@ map;
double bend_size = 0, bend_time = 1, bend_limit = 0;
timer bend_timer;
bool bend_to_percent = false;
string benddata;
int stationary_mode = STATIONARY_NONE;
double volume = 1;

void send(bool send_pitch, bool send_volume = false)
{
sendmap("createmsound " + this.id + " " + this.soundloop + " " + this.x + " " + this.y + " " + this.z + (send_pitch ? " " + this.pitch : empty) + (send_volume ? " " + this.volume : empty), this.map, 4, this.owner);
if (bend_size != 0.0) sendmap("updatemsoundbend " + this.id + " " + this.benddata, this.map, 4, (stationary_mode == STATIONARY_OWNER ? null : this.owner));
}

void send(player &inout temp)
{
temp.sendpacket("createmsound " + this.id + " " + this.soundloop + " " + this.x + " " + this.y + " " + this.z + " " + this.pitch + " " + volume, 4);
if (bend_size != 0.0) temp.sendpacket("updatemsoundbend " + this.id + " " + this.benddata, 4);
}

void send_stationary(bool send_pitch, bool send_volume = false)
{
sendmap("createmsoundstationary " + this.id + " " + this.soundloop + " " + (send_pitch ? " " + this.pitch : empty) + (send_volume ? " " + this.volume : empty), this.map, 4, this.owner);
if (bend_size != 0.0) sendmap("updatemsoundbend " + this.id + " " + this.benddata, this.map, 4, (stationary_mode == STATIONARY_OWNER ? null : this.owner));
}

void send_stationary(player &inout temp)
{
temp.sendpacket("createmsoundstationary " + this.id + " " + this.soundloop + " " + this.pitch + " " + (stationary_mode <= STATIONARY_OWNER ? 100 : this.volume), 4);
if (bend_size != 0.0) temp.sendpacket("updatemsoundbend " + this.id + " " + this.benddata, 4);
}

void set_volume(double v)
{
this.volume = v;
sendmap("updatemsoundvolume " + this.id + " " + this.volume, this.map, 4, this.owner);
}

void set_bend(double c1, double c2, double c3, bool btp = true)
{
bend_size = c1;
bend_time = c2;
bend_limit = c3;
bend_to_percent = btp;
benddata = c1 + " " + c2 + " " + c3 + (btp ? " true" : empty);
sendmap("updatemsoundbend " + this.id + " " + this.benddata, this.map, 4, (stationary_mode == STATIONARY_OWNER ? null : this.owner));
bend_timer.force(0);
}

double remove_bend(bool synchronization = true)
{
sendmap("msoundbendstop " + this.id + (synchronization ? " " + pitch : empty), this.map, 4, (stationary_mode == STATIONARY_OWNER ? null : this.owner));
this.bend_size = 0.0;
this.benddata.resize(0);
return this.pitch;
}

void update(double x, double y, double z, double pitch = -1, const string& in loop = empty)
{
this.x = x;
this.y = y;
this.z = z;
if (pitch != -1) this.pitch = pitch;
if (!loop.is_empty()) this.soundloop = loop;
this.send(pitch > -1);
}

void update(double pitch = -1, const string& in loop = empty)
{
if (pitch != -1) this.pitch = pitch;
if (!loop.is_empty()) this.soundloop = loop;
if (stationary_mode == STATIONARY_ALL) this.send_stationary(pitch > -1);
else this.send(pitch > -1);
}

void change_owner(player@ owner = null)
{
if (this.owner is owner) return;
if (this.owner !is null)
{
this.owner.sendpacket("destroymsound " + id, 4);
if (this.stationary_mode == STATIONARY_ALL) this.send_stationary(this.owner);
else this.send(this.owner);
}
if (owner !is null)
{
owner.sendpacket("destroymsound " + id, 4);
if (this.stationary_mode == STATIONARY_OWNER) this.send_stationary(owner);
}
@ this.owner = owner;
}

msound@ change_map(mapdata &inout nmap, double nx, double ny, double nz)
{
destroy();
msound m1;
do
{
m1.id = randomstring();
}
while (msounds.exists(m1.id));
m1.soundloop = this.soundloop;
m1.x = nx;
m1.y = ny;
m1.z = nz;
@ m1.map = nmap;
@ m1.owner = this.owner;
m1.pitch = this.pitch;
m1.volume = this.volume;
m1.stationary_mode = this.stationary_mode;
if (this.stationary_mode == STATIONARY_ALL) m1.send_stationary(true, true);
else
{
if (this.stationary_mode == STATIONARY_OWNER)
{
if (owner !is null)
{
if (nmap is this.owner.map) m1.send_stationary(this.owner);
}
}
m1.send(true, true);
}
if (!this.benddata.is_empty())
{
m1.bend_size = this.bend_size;
m1.bend_time = this.bend_time;
m1.bend_limit = this.bend_limit;
m1.bend_to_percent = this.bend_to_percent;
m1.benddata = this.benddata;
sendmap("updatemsoundbend " + m1.id + " " + m1.benddata, nmap, 4, (m1.stationary_mode == STATIONARY_OWNER ? null : m1.owner));
}
nmap.msounds.insert_last(m1);
msounds.set(m1.id, @ m1);
return m1;
}

msound@ destroy()
{
sendmap("destroymsound " + this.id, this.map, 4);
this.remove = true;
msounds.delete(this.id);
return null;
}
}

msound@ spawn_moving_sound(const string& in loop, double x, double y, double z, mapdata@ map, player@ owner = null, double pitch = 100, bool owner_stationary = false)
{
msound m1;
do
{
m1.id = randomstring();
}
while (msounds.exists(m1.id));
m1.soundloop = loop;
m1.x = x;
m1.y = y;
m1.z = z;
@ m1.map = map;
@ m1.owner = owner;
m1.pitch = pitch;
if (owner_stationary)
{
m1.stationary_mode = STATIONARY_OWNER;
if (owner !is null)
{
if (map is owner.map) m1.send_stationary(owner);
}
}
m1.send(true);
map.msounds.insert_last(m1);
msounds.set(m1.id, @ m1);
return m1;
}

msound@ spawn_moving_sound(const string& in loop, mapdata@ map, player@ owner = null, double pitch = 100)
{
msound m1;
do
{
m1.id = randomstring();
}
while (msounds.exists(m1.id));
m1.stationary_mode = STATIONARY_ALL;
m1.soundloop = loop;
@ m1.map = map;
@ m1.owner = owner;
m1.pitch = pitch;
m1.volume = 100;
m1.send_stationary(true);
map.msounds.insert_last(m1);
msounds.set(m1.id, @ m1);
return m1;
}

msound@ get_moving_sound_handle(const string& in id)
{
if (!msounds.exists(id)) return null;
msound@ temp;
msounds.get(id, @ temp);
return temp;
}

void msoundloop(mapdata@ map)
{
for (int i = map.msounds.length - 1; i > -1; i--)
{
msound@ this = map.msounds[i];
if (this.remove)
{
map.msounds.remove_at(i);
continue;
}
if (this.bend_size == 0.0) continue;
if (this.bend_timer.elapsed < this.bend_time) continue;
this.pitch += (this.bend_to_percent ? percent_pro(this.pitch, this.bend_size, this.bend_timer.elapsed) : (this.bend_size * this.bend_timer.elapsed));
this.bend_timer.force(0);
if (this.bend_limit > 0)
{
if ((this.bend_size > 0 ? this.pitch >= this.bend_limit : this.pitch <= this.bend_limit))
{
this.pitch = this.bend_limit;
this.remove_bend();
}
}
}
}
// 클라이언트 코드
// map.bgt클라이언트 소스
dictionary item_descriptions;
timer maploadtimer;
int loadingtime;
maptravel@[] maptravels, autotravels;
class maptravel
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string dest_map;
int dest_x;
int dest_y;
int dest_z;
string text;
string limit;
bool smart = false;
bool autotravel = false;
}
maptravel@ get_travel_at(int x, int y, int z)
{
maptravel@[] list;
for (int i = maptravels.length - 1; i > -1; i--)
{
maptravel@ temp = maptravels[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
list.insert_last(temp);
}
if (list.is_empty()) return null;
if (list.length == 1) return list[0];
return select_travel(list);
}

mapzone@[] mapzones(0);
dictionary mapzone_list;
class mapzone
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string text;
bool trackable;
string id;
bool inve = false;

void tell_where(int x, int y, int z, int dir)
{
double dx = abs(x - center_x) - size_x;
double dy = abs(y - center_y) - size_y;
double dz = abs(z - center_z) - size_z;
double final = 0.0;
if (dx > 0) final += (dx * dx);
if (dy > 0) final += (dy * dy);
if (dz > 0) final += (dz * dz);
string s;
if (final > 0.0)
{
if (minz > z) s += "위에, ";
if (maxz < z) s += "밑에, ";
}
speak(s + calculate_x_y_string(calculate_x_y_angle(x, y, center_x, center_y, dir)) + ", " + round(final ** 0.5, 0) + "칸 떨어짐. ");
}
}

mapzone@ get_zone_handle(const string& in id)
{
if (!mapzone_list.exists(id)) return null;
mapzone@ temp;
mapzone_list.get(id, @ temp);
return temp;
}
const string& get_zone_at(int x, int y, int z)
{
for (int i = mapzones.length - 1; i > -1; i--)
{
mapzone@ temp = mapzones[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
ref_string = temp.text;
return ref_string;
}
return "미정의 지역";
}

maptravel@ create_travelpoint(string[]@ parsed)
{
if (parsed.length < 13) return null;
maptravel temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.dest_map = parsed[7];
temp.dest_x = string_to_number(parsed[8]);
temp.dest_y = string_to_number(parsed[9]);
temp.dest_z = string_to_number(parsed[10]);
temp.text = parsed[11];
int tempflag = string_to_number(parsed[12]);
if (tempflag & 1 > 0) temp.smart = true;
if (tempflag & 2 > 0) temp.autotravel = true;
if (parsed.length > 13) temp.limit = parsed[13];
return temp;
}
mapzone@ create_zone(string[]@ parsed)
{
if (parsed.length < 8) return null;
mapzone temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.text = parsed[7];
temp.trackable = (parsed.length > 8 ? true : false);
return temp;
}

maptile@[] maptiles, mapgates;
class maptile
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string type;
int plus_x = 0, plus_y = 0, plus_z = 0;
bool hazard = false;
int slidetime = 0;
int slidedir = -1;
}

const string& get_tile_at(int x, int y, int z, bool camera = false)
{
for (int i = sources.length - 1; i > -1; i--)
{
source@ temp = sources[i];
if (temp.id < 0) continue;
if (temp.tile.is_empty()) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
ref_string = temp.tile;
return ref_string;
}
if (camera)
{
for (int i = mapgates.length - 1; i > -1; i--)
{
maptile@ temp = mapgates[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (temp.hazard) return "미지의 플래폼";
ref_string = temp.type;
return ref_string;
}
for (int i = maptiles.length - 1; i > -1; i--)
{
maptile@ temp = maptiles[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (temp.hazard) return "미지의 플래폼";
ref_string = temp.type;
return ref_string;
}
}
else
{
for (int i = mapgates.length - 1; i > -1; i--)
{
maptile@ temp = mapgates[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
ref_string = temp.type;
return ref_string;
}
for (int i = maptiles.length - 1; i > -1; i--)
{
maptile@ temp = maptiles[i];
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
ref_string = temp.type;
return ref_string;
}
}
return empty;
}

maptile@ get_tile_handle_at(int x, int y, int z, bool check_obj = true)
{
bool fallable = false;
if (check_obj)
{
for (int i = sources.length - 1; i > -1; i--)
{
source@ temp = sources[i];
if (temp.id < 0) continue;
if (temp.tile.is_empty()) continue;
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
maptile new;
new.type = temp.tile;
return new;
}
}
for (int i = mapgates.length - 1; i > -1; i--)
{
maptile@ temp = mapgates[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
for (int i = maptiles.length - 1; i > -1; i--)
{
maptile@ temp = maptiles[i];
if (temp.minz > z) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
fallable = true;
if (temp.maxz < z) continue;
return temp;
}
return fallable ? maptile() : null;
}

void change_tile(int minx, int maxx, int miny, int maxy, int minz, int maxz, const string &in type)
{
for (int i = mapgates.length - 1; i > -1; i--)
{
maptile@ temp = mapgates[i];
if (temp.minx != minx) continue;
if (temp.maxx != maxx) continue;
if (temp.miny != miny) continue;
if (temp.maxy != maxy) continue;
if (temp.minz != minz) continue;
if (temp.maxz != maxz) continue;
if (temp.type != type) continue;
temp.minx += temp.plus_x;
temp.maxx += temp.plus_x;
temp.center_x += temp.plus_x;
temp.miny += temp.plus_y;
temp.maxy += temp.plus_y;
temp.center_y += temp.plus_y;
temp.minz += temp.plus_z;
temp.maxz += temp.plus_z;
temp.center_z += temp.plus_z;
temp.plus_x *= -1;
temp.plus_y *= -1;
temp.plus_z *= -1;
reserve_tilecheck = 2;
break;
}
}

mapetp@[] mapetps, entered_etps;
class mapetp
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
string sn;
int cooldown;
timer cooldowntimer;
int mode = 0;
int status = 0;
int play_count = 0;
int sound_id = -1;
double volume = 100.0;
}

void etploop()
{
for (int i = entered_etps.length - 1; i > -1; i--)
{
mapetp@ temp = entered_etps[i];
if (temp.status <= 0)
{
temp.status = 0;
entered_etps.remove_at(i);
continue;
}
if (temp.cooldowntimer.elapsed < temp.cooldown) continue;
temp.cooldowntimer.force(0);
if (temp.status <= 1) temp.status--;
sourcepool.play_3d(temp.sn + ".ogg", temp.minx, temp.miny, temp.minz, false, false, 0, abs(temp.maxx - temp.minx), 0, abs(temp.maxy - temp.miny), 0, abs(temp.maxz - temp.minz), 0, 0, (temp.volume - 100));
if (temp.mode == -1)
{
send_reliable("xplaysource " + temp.sn + " " + mr.x + " " + mr.y + " " + me.z, 2);
continue;
}
send_reliable("xplay " + temp.sn + " " + temp.minx + " " + temp.maxx + " " + temp.miny + " " + temp.maxy + " " + temp.minz + " " + temp.maxz + " " + temp.volume, 2);
if (temp.status < 2) continue;
temp.play_count++;
if (temp.play_count < temp.mode) continue;
temp.status = 0;
temp.play_count = 0;
entered_etps.remove_at(i);
}
}
void play_etp(int x, int y, int z, const string& in name = empty)
{
int etplength = mapetps.length;
if (name.is_empty())
{
for (uint i = 0; i < etplength; i++)
{
mapetp@ temp = mapetps[i];
if (temp.mode > 0) continue;
if (temp.cooldowntimer.elapsed < temp.cooldown) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
temp.cooldowntimer.force(0);
sourcepool.play_3d(temp.sn + ".ogg", temp.minx, temp.miny, temp.minz, false, false, 0, abs(temp.maxx - temp.minx), 0, abs(temp.maxy - temp.miny), 0, abs(temp.maxz - temp.minz), 0, 0, (temp.volume - 100));
send_reliable("xplay " + temp.sn + " " + temp.minx + " " + temp.maxx + " " + temp.miny + " " + temp.maxy + " " + temp.minz + " " + temp.maxz + " " + temp.volume, 2);
}
return;
}
for (uint i = 0; i < etplength; i++)
{
mapetp@ temp = mapetps[i];
if (temp.mode >= 0) continue;
if (temp.status == 2) continue;
if (temp.sn != name) continue;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (temp.status <= 0) entered_etps.insert_last(temp);
temp.status = 1;
}
}
void enter_etp(int x, int y, int z)
{
int etplength = mapetps.length;
for (uint i = 0; i < etplength; i++)
{
mapetp@ temp = mapetps[i];
if (temp.mode == 0) continue;
if (temp.status == 2) temp.status = -1;
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
temp.status = 2;
temp.play_count = 0;
entered_etps.insert_last(temp);
}
}
mapetp@ create_etp(string[]@ parsed)
{
if (parsed.length < 10) return null;
mapetp temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.sn = parsed[7];
temp.cooldown = string_to_number(parsed[8]);
temp.mode = string_to_number(parsed[9]);
if (parsed.length > 10) temp.volume = string_to_number(parsed[10]);
return temp;
}

checkpoint@ mycheckpoint;
checkpoint@[] checkpoints;
class checkpoint
{
int minx, maxx, miny, maxy, minz, maxz;
double center_x, center_y, center_z, size_x, size_y, size_z;
bool once = false;
}
void set_checkpoint(int x, int y, int z, bool inv = false)
{
int cpl = (inv ? vcheckpoints.length : checkpoints.length);
for (uint i = 0; i < cpl; i++)
{
checkpoint@ temp = (inv ? vcheckpoints[i] : checkpoints[i]);
if (temp.minx > x) continue;
if (temp.maxx < x) continue;
if (temp.miny > y) continue;
if (temp.maxy < y) continue;
if (temp.minz > z) continue;
if (temp.maxz < z) continue;
if (mycheckpoint !is null)
{
if (temp is mycheckpoint) continue;
if (abs(temp.center_x - mycheckpoint.center_x) <= temp.size_x + mycheckpoint.size_x and abs(temp.center_y - mycheckpoint.center_y) <= temp.size_y + mycheckpoint.size_y and abs(temp.center_z - mycheckpoint.center_z) <= temp.size_z + mycheckpoint.size_z) continue;
p.play_stationary("checkpoint.ogg", false);
}
@ mycheckpoint = temp;
if (invehicle) send_reliable("checkpointset " + round(vv.x, 0) + " " + round(vv.y, 0) + " " + round(vv.z, 0), 0);
else send_reliable("checkpointset " + x + " " + y + " " + z, 0);
break;
}
}

void spawn_checkpoint(int minx, int maxx, int miny, int maxy, int minz, int maxz, bool once = false, bool v = false)
{
checkpoint ss;
ss.center_x = (minx + maxx) * 0.5;
ss.size_x = abs(ss.center_x - minx);
ss.minx = ss.center_x - ss.size_x;
ss.maxx = ss.center_x + ss.size_x;
ss.center_y = (miny + maxy) * 0.5;
ss.size_y = abs(ss.center_y - miny);
ss.miny = ss.center_y - ss.size_y;
ss.maxy = ss.center_y + ss.size_y;
ss.center_z = (minz + maxz) * 0.5;
ss.size_z = abs(ss.center_z - minz);
ss.minz = ss.center_z - ss.size_z;
ss.maxz = ss.center_z + ss.size_z;
ss.once = once;
if (v) vcheckpoints.insert_last(ss);
else checkpoints.insert_last(ss);
}
void spawn_hobj(int x, int y, int z, const string& in soundfile, int id, const string& in tile = empty)
{
source ss;
ss.center_x = x;
ss.minx = x;
ss.maxx = x;
ss.center_y = y;
ss.miny = y;
ss.maxy = y;
ss.center_z = z;
ss.minz = z;
ss.maxz = z;
if (soundfile != "nosound")
{
ss.soundfile = soundfile + ".ogg";
ss.source_sound = sourcepool.play_3d(ss.soundfile, x, y, z, true);
}
ss.id = id;
ss.tile = tile;
sources.insert_last(ss);
}

void update_hobj(int id, int x, int y, int z, const string& in tile = empty)
{
if (id < 0) return;
for (int i = sources.length - 1; i > -1; i--)
{
source@ temp = sources[i];
if (temp.id != id) continue;
temp.center_x = x;
temp.minx = x;
temp.maxx = x;
temp.center_y = y;
temp.miny = y;
temp.maxy = y;
temp.center_z = z;
temp.minz = z;
temp.maxz = z;
if (temp.source_sound > -1) sourcepool.update_sound_3d(temp.source_sound, x, y, z);
temp.tile = tile;
}
}

mapswitch@[] mapswitchs;
class mapswitch
{
int minx, maxx, miny, maxy, minz, maxz;
int tminx, tmaxx, tminy, tmaxy, tminz, tmaxz;
int cooldown = 1000;
string name;
string press;
string limit;
timer presstimer;
}

maptile@ create_platform(string[]@ parsed)
{
if (parsed.length < 8) return null;
maptile temp;
int tempx = string_to_number(parsed[1]);
temp.center_x = (tempx + string_to_number(parsed[2])) * 0.5;
temp.size_x = abs(temp.center_x - tempx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
int tempy = string_to_number(parsed[3]);
temp.center_y = (tempy + string_to_number(parsed[4])) * 0.5;
temp.size_y = abs(temp.center_y - tempy);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
int tempz = string_to_number(parsed[5]);
temp.center_z = (tempz + string_to_number(parsed[6])) * 0.5;
temp.size_z = abs(temp.center_z - tempz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = parsed[7];
if (parsed.length > 9)
{
temp.slidedir = string_to_number(parsed[8]);
temp.slidetime = string_to_number(parsed[9]);
}
if (parsed.length > 10 or parsed.length == 9) temp.hazard = true;
return temp;
}
void create_gate(int minx, int maxx, int miny, int maxy, int minz, int maxz, string type, int plus_x, int plus_y, int plus_z, int slt = 0, int sld = -1, bool haz = false, bool v = false)
{
maptile temp;
temp.center_x = (minx + maxx) * 0.5;
temp.size_x = abs(temp.center_x - minx);
temp.minx = temp.center_x - temp.size_x;
temp.maxx = temp.center_x + temp.size_x;
temp.center_y = (miny + maxy) * 0.5;
temp.size_y = abs(temp.center_y - miny);
temp.miny = temp.center_y - temp.size_y;
temp.maxy = temp.center_y + temp.size_y;
temp.center_z = (minz + maxz) * 0.5;
temp.size_z = abs(temp.center_z - minz);
temp.minz = temp.center_z - temp.size_z;
temp.maxz = temp.center_z + temp.size_z;
temp.type = type;
temp.plus_x = plus_x;
temp.plus_y = plus_y;
temp.plus_z = plus_z;
temp.plus_y = plus_y;
temp.plus_z = plus_z;
temp.slidetime = slt;
temp.slidedir = sld;
temp.hazard = haz;
if (v) vmapgates.insert_last(temp);
else mapgates.insert_last(temp);
}
mapswitch@ create_switch(string[]@ parsed)
{
if (parsed.length < 16) return null;
mapswitch temp;
temp.minx = string_to_number(parsed[1]);
temp.maxx = string_to_number(parsed[2]);
temp.miny = string_to_number(parsed[3]);
temp.maxy = string_to_number(parsed[4]);
temp.minz = string_to_number(parsed[5]);
temp.maxz = string_to_number(parsed[6]);
temp.tminx = string_to_number(parsed[7]);
temp.tmaxx = string_to_number(parsed[8]);
temp.tminy = string_to_number(parsed[9]);
temp.tmaxy = string_to_number(parsed[10]);
temp.tminz = string_to_number(parsed[11]);
temp.tmaxz = string_to_number(parsed[12]);
temp.cooldown = string_to_number(parsed[13]);
if (temp.cooldown < 200) temp.cooldown = 200;
temp.name = parsed[14];
temp.press = parsed[15];
if (parsed.length > 16) temp.limit = parsed[16];
return temp;
}

void clear_map()
{
maptiles.resize(0);
mapswitchs.resize(0);
mapzones.resize(0);
maptravels.resize(0);
autotravels.resize(0);
mapzone_list.delete_all();
checkpoints.resize(0);
@ mycheckpoint = null;
item_descriptions.delete_all();
mapetps.resize(0);
entered_etps.resize(0);
no_coord = false;
no_seethrough = false;
min.z = 0;
max.z = 0;
}

bool in_map = false;
void load_map(const string& in mdata)
{
maploadtimer.force(0);
in_map = false;
destroy_all_sources();
destroy_all_doors();
map_preload.delete_all();
sbs.resize(0);
bound_default_volume = 50;
new_bound_default_volume = 50;
clear_map();
garbage_collect();
mapstring = mdata;
@ ldata = string_split(mdata, "\r\n", false);
string delim = ":";
int ldatalength = ldata.length;
for (uint i = 0; i < ldatalength; i++)
{
string[]@ parsed = string_split(ldata[i], delim, true);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed);
}
if (new_bound_default_volume != bound_default_volume) bound_default_volume = new_bound_default_volume;
if (!pan_changed and old_pan != 1.0)
{
new_pan = 1.0;
old_pan = 1.0;
pan_step_update(old_pan * weaponsight);
}
else pan_changed = false;
load_src();
msound_map_update();
in_map = true;
p.sound_boundary_update();
distpool.sound_boundary_update();
mpool.sound_boundary_update();
ambloop();
loadingtime = maploadtimer.elapsed;
sourcechange = true;
reserve_tilecheck = 2;
}

void add_map_data(const string& in mdata)
{
int sbslength = sbs.length;
mapstring += mdata;
string[]@ ndata = string_split(mdata, "\r\n", false);
string delim = ":";
int ndatalength = ndata.length;
ldata.reserve(ldata.length + ndatalength);
for (uint i = 0; i < ndatalength; i++)
{
ldata.insert_last(ndata[i]);
string[]@ parsed = string_split(ndata[i], delim, true);
if (parsed.length < 2) continue;
map_hash@ func;
if (!map_handles.get(parsed[0], @ func)) continue;
func(parsed);
}
pan_changed = false;
load_src(true);
if (sbslength == sbs.length and bound_default_volume == new_bound_default_volume) load_src(true);
else
{
bound_default_volume = new_bound_default_volume;
load_src();
@ my_sb = get_sound_boundary_names(me.x, me.y, me.z);
p.sound_boundary_update(my_sb);
sourcepool.sound_boundary_update(my_sb);
distpool.sound_boundary_update(my_sb);
mpool.sound_boundary_update(my_sb);
ambloop();
}
reserve_tilecheck = 2;
}

string[]@[] srctemp, ambtemp;
void load_src(bool update_now = false)
{
int srclength = srctemp.length;
for (uint i = 0; i < srclength; i++)
{
string[]@ parsed = srctemp[i];
double volume = 100.0;
if (parsed.length > 8) volume = string_to_number(parsed[8]);
spawn_source(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), parsed[7], false, -1, volume);
}
int amblength = ambtemp.length;
for (uint i = 0; i < amblength; i++)
{
string[]@ parsed = ambtemp[i];
int volume = 100.0;
if (parsed.length > 8) volume = string_to_number(parsed[8]);
create_amb(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), parsed[7], volume, (update_now ? -2 : -1));
}
srctemp.resize(0);
ambtemp.resize(0);
}

funcdef void map_hash(string[]@ parsed);
dictionary map_handles;
dictionary vmap_handles;

void install_map_hash()
{
map_handles.set("tile", @ map_hash_tile);
map_handles.set("switch", @ map_hash_switch);
map_handles.set("zone", @ map_hash_zone);
map_handles.set("travelpoint", @ map_hash_travelpoint);
map_handles.set("etp", @ map_hash_etp);
vmap_handles.set("tile", @ vmap_hash_tile);
vmap_handles.set("zone", @ vmap_hash_zone);
vmap_handles.set("travelpoint", @ vmap_hash_travelpoint);
vmap_handles.set("etp", @ vmap_hash_etp);
map_handles.set("door", @ map_hash_door);
map_handles.set("src", @ map_hash_src);
map_handles.set("amb", @ map_hash_amb);
map_handles.set("sb", @ map_hash_sb);
map_handles.set("mapname", @ map_hash_mapname);
map_handles.set("maxx", @ map_hash_maxx);
map_handles.set("maxy", @ map_hash_maxy);
map_handles.set("no_coord", @ map_hash_no_coord);
map_handles.set("no_seethrough", @ map_hash_no_seethrough);
vmap_handles.set("mapname", @ vmap_hash_mapname);
vmap_handles.set("maxx", @ vmap_hash_maxx);
vmap_handles.set("maxy", @ vmap_hash_maxy);
vmap_handles.set("no_coord", @ vmap_hash_no_coord);
map_handles.set("x", @ map_hash_x);
map_handles.set("y", @ map_hash_y);
map_handles.set("z", @ map_hash_z);
map_handles.set("pan", @ map_hash_pan);
map_handles.set("bd", @ map_hash_bd);
map_handles.set("idscr", @ map_hash_idscr);
vmap_handles.set("idscr", @ map_hash_idscr);
map_handles.set("checkpoint", @ map_hash_checkpoint);
vmap_handles.set("checkpoint", @ vmap_hash_checkpoint);
}

void map_hash_travelpoint(string[]@ parsed)
{
maptravel@ temp = create_travelpoint(parsed);
if (temp is null) return;
if (temp.autotravel) autotravels.insert_last(temp);
else maptravels.insert_last(temp);
}

void map_hash_etp(string[]@ parsed)
{
mapetp@ temp = create_etp(parsed);
if (temp !is null) mapetps.insert_last(temp);
}

void map_hash_tile(string[]@ parsed)
{
maptile@ temp = create_platform(parsed);
if (temp is null) return;
if (max.z < temp.maxz) max.z = temp.maxz;
if (min.z > temp.minz) min.z = temp.minz;
maptiles.insert_last(temp);
}

void map_hash_switch(string[]@ parsed)
{
mapswitch@ temp = create_switch(parsed);
if (temp !is null) mapswitchs.insert_last(temp);
}

void map_hash_zone(string[]@ parsed)
{
mapzone@ temp = create_zone(parsed);
if (temp is null) return;
string id;
do
{
id = randomstring(8);
}
while (mapzone_list.exists(id));
temp.id = id;
mapzones.insert_last(temp);
mapzone_list.set(id, @ temp);
}

void vmap_hash_travelpoint(string[]@ parsed)
{
maptravel@ temp = create_travelpoint(parsed);
if (temp is null) return;
if (temp.autotravel) vautotravels.insert_last(temp);
else vmaptravels.insert_last(temp);
}

void vmap_hash_etp(string[]@ parsed)
{
mapetp@ temp = create_etp(parsed);
if (temp !is null) vmapetps.insert_last(temp);
}

void vmap_hash_tile(string[]@ parsed)
{
maptile@ temp = create_platform(parsed);
if (temp !is null) vmaptiles.insert_last(temp);
}

void vmap_hash_zone(string[]@ parsed)
{
mapzone@ temp = create_zone(parsed);
if (temp is null) return;
string id;
do
{
id = randomstring(8);
}
while (vmapzone_list.exists(id));
temp.id = id;
temp.inve = true;
vmapzones.insert_last(temp);
vmapzone_list.set(id, @ temp);
}

void map_hash_door(string[]@ parsed)
{
if (parsed.length < 15) return;
if (parsed.length > 17) spawn_door(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), string_to_number(parsed[7]), string_to_number(parsed[8]), string_to_number(parsed[9]), parsed[10], string_to_number(parsed[11]), string_to_number(parsed[12]), parsed[13], parsed[14], parsed[15], string_to_number(parsed[16]), string_to_number(parsed[17]), (parsed.length > 18 ? parsed[18] : empty));
else spawn_door(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), string_to_number(parsed[7]), string_to_number(parsed[8]), string_to_number(parsed[9]), parsed[10], string_to_number(parsed[11]), string_to_number(parsed[12]), parsed[13], string_to_number(parsed[14]), (parsed.length > 15 ? parsed[15] : empty));
}

void map_hash_src(string[]@ parsed)
{
if (parsed.length < 8) return;
srctemp.insert_last(parsed);
}

void map_hash_amb(string[]@ parsed)
{
if (parsed.length < 8) return;
ambtemp.insert_last(parsed);
}

void map_hash_sb(string[]@ parsed)
{
if (parsed.length < 8) return;
spawn_sound_boundary(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), parsed[7], (parsed.length > 8 ? string_to_number(parsed[8]) : 0), (parsed.length > 9 ? string_to_number(parsed[9]) : 0), (parsed.length > 10 ? string_to_number(parsed[10]) : 0));
}

void map_hash_idscr(string[]@ parsed)
{
if (parsed.length < 3) return;
item_descriptions.set(parsed[1], parsed[2]);
}

void map_hash_checkpoint(string[]@ parsed)
{
if (parsed.length < 7) return;
spawn_checkpoint(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), (parsed.length > 7), false);
}
void vmap_hash_checkpoint(string[]@ parsed)
{
if (parsed.length < 7) return;
spawn_checkpoint(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), string_to_number(parsed[6]), (parsed.length > 7), true);
}

void map_hash_mapname(string[]@ parsed)
{
mapname = parsed[1];
}
void map_hash_maxx(string[]@ parsed)
{
max.x = string_to_number(parsed[1]);
}
void map_hash_maxy(string[]@ parsed)
{
max.y = string_to_number(parsed[1]);
}
void map_hash_no_coord(string[]@ parsed)
{
no_coord = (string_to_number(parsed[1]) == 1 ? true : false);
}
void map_hash_no_seethrough(string[]@ parsed)
{
no_seethrough = (string_to_number(parsed[1]) == 1 ? true : false);
}
void vmap_hash_mapname(string[]@ parsed)
{
vmapname = parsed[1];
}
void vmap_hash_maxx(string[]@ parsed)
{
vmax.x = string_to_number(parsed[1]);
}
void vmap_hash_maxy(string[]@ parsed)
{
vmax.y = string_to_number(parsed[1]);
}
void vmap_hash_no_coord(string[]@ parsed)
{
v_no_coord = (string_to_number(parsed[1]) == 1 ? true : false);
}
void map_hash_x(string[]@ parsed)
{
me.x = string_to_number(parsed[1]);
mr.x = round(me.x, 0);
}
void map_hash_y(string[]@ parsed)
{
me.y = string_to_number(parsed[1]);
mr.y = round(me.y, 0);
}
void map_hash_z(string[]@ parsed)
{
me.z = string_to_number(parsed[1]);
}
void map_hash_pan(string[]@ parsed)
{
pan_changed = true;
new_pan = string_to_number(parsed[1]);
if (new_pan == old_pan) return;
old_pan = new_pan;
pan_step_update(old_pan * weaponsight);
}
void map_hash_bd(string[]@ parsed)
{
new_bound_default_volume = string_to_number(parsed[1]);
if (new_bound_default_volume <= 0 or new_bound_default_volume >= 50) new_bound_default_volume = 50;
}
// map편집 관련 클라이언트 소스.bgt클라이언트 소스
sound mapeditor_player;
void mapeditor_play(const string &in name)
{
mapeditor_player.close();
if (!mapeditor_player.stream(sndfolder + name + ".ogg")) return;
mapeditor_player.play();
}

string[]@ select_mapdata_type(bool admin = false)
{
setupmenu();
m.multi_checking = true;
m.add_item_tts("플래폼", "tile");
m.add_item_tts("문", "gate");
m.add_item_tts("문 스위치", "switch");
m.add_item_tts("사운드 효과", "src");
m.add_item_tts("사운드 환경", "amb");
m.add_item_tts("엔터로 재생", "etp");
m.add_item_tts("사운드 경계", "sb");
m.add_item_tts("텍스트 지역", "zone");
m.add_item_tts("포탈", "travelpoint");
m.add_item_tts("리프트", "door");
m.add_item_tts("아이템 소환", "ispawn");
m.add_item_tts("깃발 게임 지역", "ctf");
m.add_item_tts("아이템 제한", "noitem");
m.add_item_tts("체크 포인트", "checkpoint");
m.add_item_tts("로봇", "robots");
m.add_item_tts("아이템 설명", "idscr", empty, true, true);
m.add_item_tts("기존 데이터 편집", "edit", empty, true, true);
m.add_item_tts("명령 프롬프트를 통한 고급 설정", "cmd", empty, true, true);
int mres = m.run("무엇을 만들까요?", true);
if (mres <= 0)
{
return empty_s;
}
string result = m.get_item_name(mres);
if (result.is_empty()) return empty_s;
string[]@ new = m.get_checked_item_list();
if (new.is_empty()) new.insert_last(result);
return new;
}

bool& buildsomething(const string& in old_data = empty, bool admin = false)
{
string[]@ what;
string[] old_parsed;
if (!old_data.is_empty()) old_parsed = string_split(old_data, ":", false);
if (old_parsed.is_empty()) @ what = select_mapdata_type(admin);
else
{
if (old_parsed[0] == "edit") return false_t;
if (old_parsed[0] == "cmd") return false_t;
if (old_parsed[0] == "ispawn") return false_t;
if (old_parsed[0] == "ctf") return false_t;
string[] new;
new.insert_last(old_parsed[0]);
@ what = new;
}
if (what is null) return false_t;
if (what.is_empty()) return false_t;
uint whatnum = string_to_hash(what[0]);
switch (whatnum)
{
case maporder_edit:
{
map_editor(admin);
}
break; case maporder_cmd:
{
string ntext = input_box_pro("명령어를 입력하세요.");
if (!text_builder(ntext)) return true_t;
send_reliable("/맵설 " + mapname + " " + ntext, 1);
}
break; case maporder_idscr:
{
string ntext = input_box_pro("아이템 이름을 입력하세요. 사용자 지정 아이템은 뒤에 언더바 한개를 붙이세요.", (old_parsed.length > 1 ? old_parsed[1] : empty));
if (!text_builder(ntext)) return true_t;
string ntext2 = input_box_pro("아이템 설명을 입력하세요.", (old_parsed.length > 2 ? old_parsed[2] : empty));
if (!text_builder(ntext2)) return true_t;
ntext += ":" + ntext2;
if (old_data.is_empty()) send_reliable("buildnow \r\nidscr:" + ntext, 4);
else send_reliable("mapedit \r\n" + old_data + "\r\n[]\r\nidscr:" + ntext + "\r\n", 4);
}
break; default:
{
string sendtext;
string minx, maxx, miny, maxy, minz, maxz;
if (!old_data.is_empty())
{
string[]@ locs = get_old_loc_array(old_data);
if (locs is null) return false_t;
minx = locs[0];
maxx = locs[1];
miny = locs[2];
maxy = locs[3];
minz = locs[4];
maxz = locs[5];
}
else
{
minx = number_builder("서쪽 끝 X 좌표를 입력하세요.", mr.x);
if (minx.is_empty()) return true_t;
maxx = number_builder("동쪽 끝 X 좌표를 입력하세요.", string_to_number(minx));
if (maxx.is_empty()) return true_t;
miny = number_builder("남쪽 끝 Y 좌표를 입력하세요.", mr.y);
if (miny.is_empty()) return true_t;
maxy = number_builder("북쪽 끝 Y 좌표를 입력하세요.", string_to_number(miny));
if (maxy.is_empty()) return true_t;
minz = number_builder("아래쪽 끝 Z 좌표를 입력하세요.", me.z);
if (minz.is_empty()) return true_t;
maxz = number_builder("위쪽 끝 Z 좌표를 입력하세요.", string_to_number(minz));
if (maxz.is_empty()) return true_t;
}
string loc = minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz;
int xlength = abs(string_to_number(maxx) - string_to_number(minx));
int ylength = abs(string_to_number(maxy) - string_to_number(miny));
int zlength = abs(string_to_number(maxz) - string_to_number(minz));
string default_string;
double default_double = 0;
int whatlength = what.length;
for (uint i = 0; i < whatlength; i++)
{
whatnum = string_to_hash(what[i]);
switch (whatnum)
{
case maporder_noitem:
{
default_string = (old_parsed.length > 7 ? string_replace(string_trim_left(old_data, string_contains(old_data, ":", 7)), ":", " ", true) : empty);
string ntext = input_box_pro("사용 제한을 걸 아이템 목록을 입력하세요. 여러 개를 한번에 입력할 때는 아이템 이름 사이에 빈 칸이나 쉼표를 삽입하세요. 아이템 그룹으로 현재 무기, 차량, 식음료, 탄약, 함정, 폭발물이 있으며, 해당 분류의 아이템을 사용할 수 없게 합니다.", default_string);
if (!text_builder(ntext)) return true_t;
ntext = string_replace(ntext, " ", ":", true);
ntext = string_replace(ntext, ",", ":", true);
sendtext += "\r\nnoitem:" + loc + ":" + ntext;
}
break; case maporder_zone:
{
default_string = (old_parsed.length > 7 ? old_parsed[7] : empty);
string ztext = input_box_pro("지역 이름, 묘사 등을 입력하세요.", default_string);
if (!text_builder(ztext)) break;
string temp;
int trackable = yesno("M키로 추적이 가능하게 할까요?", (old_parsed.length > 8 ? 1 : 0));
if (trackable <= 0) break;
if (trackable == 1) temp = ":trackme";
sendtext += "\r\nzone:" + loc + ":" + ztext + temp;
}
break; case maporder_checkpoint:
{
string temp;
int trackable = yesno("최초 한 번만 저장되게 하시겠습니까?", (old_parsed.length > 7 ? 1 : 0));
if (trackable <= 0) break;
if (trackable == 1) temp = ":once";
sendtext += "\r\ncheckpoint:" + loc + temp;
}
break; case maporder_ctf:
{
int cz = ctf_zone_select();
if (cz == 0) break;
if (cz == 3)
{
string unit = number_builder("S flag를 몇 밀리초마다 소환되게 만들까요? 기본값은 1초, 최소 100 밀리초입니다.", 1000);
if (string_to_number(unit) < 100) break;
string unspawn = number_builder("S flag를 몇 밀리초 뒤에 사라지게 할까요? 기본값은 2분, 최소 100 밀리초입니다.", 120000);
if (string_to_number(unspawn) < 100) break;
sendtext += "\r\nispawn:" + loc + ":1:" + unit + ":" + unspawn + ":0:0:s_flag";
break;
}
if (cz == 4)
{
string unit = number_builder("R flag를 몇 밀리초마다 소환되게 만들까요? 기본값은 1초, 최소 100 밀리초입니다.", 1000);
if (string_to_number(unit) < 100) break;
string unspawn = number_builder("R flag를 몇 밀리초 뒤에 사라지게 할까요? 기본값은 2분, 최소 100 밀리초입니다.", 120000);
if (string_to_number(unspawn) < 100) break;
if (unspawn.is_empty()) break;
sendtext += "\r\nispawn:" + loc + ":1:" + unit + ":" + unspawn + ":0:0:r_flag";
break;
}
sendtext += "\r\nctf:" + loc + ":" + cz;
}
break; case maporder_ispawn:
{
default_double = (old_parsed.length > 7 ? string_to_number(old_parsed[7]) : 1);
string amount = number_builder("몇 개까지 누적 소환할까요? 음수를 입력하면 플레이어 수에 맞춰 가변으로 소환합니다. 경고: 렉 방지를 위해 5를 초과한 값은 입력할 수 없습니다. 기본값은 " + default_double + "입니다.", default_double);
if (amount.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 1000);
string unit = number_builder("몇 밀리초마다 소환하게 할까요? 기본값은 " + default_double + "밀리초, 최소 100 밀리초입니다.", default_double);
if (string_to_number(unit) < 100) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : 120000);
string unspawn = number_builder("몇 밀리초 뒤에 사라지게 할까요? 기본값은 " + default_double + "밀리초, 최소 100 밀리초입니다.", default_double);
if (string_to_number(unspawn) < 100) break;
default_string = (old_parsed.length > 10 ? old_parsed[10] : 0);
string limit = input_box_pro("습득할 수 있는 개수를 제한할까요? 기본값은 " + default_string + "입니다. 0보다 작은 값을 입력하면 습득할 수 있는 갯수를 모든 플레이어가 공유하고, 0보다 큰 값을 입력하면 플레이어별로 따로 계산합니다.", default_string);
if (limit != "a" and string_to_number(limit) == 0) limit = "0:0";
else
{
default_double = (old_parsed.length > 11 ? string_to_number(old_parsed[11]) : 3600000);
string limittime = number_builder("몇 밀리초마다 초기화할까요? 기본값은 " + default_double + "밀리초입니다.", default_double);
if (string_to_number(limittime) <= 0) break;
else limit += ":" + limittime;
}
default_string = (old_parsed.length > 12 ? string_replace(string_trim_left(old_data, string_contains(old_data, ":", 12)), ":", " ", true) : empty);
string itemnames = input_box_pro("아이템 이름을 입력하세요. 두 개 이상의 아이템 중 무작위로 소환하게 하려면 아이템 이름 사이에 빈 칸이나 쉼표를 삽입하세요. 아이템 이름 안에는 빈 칸, 쉼표, 더하기, 등호, 쌍점, 대괄호, 새문단 기호가 들어갈 수 없습니다. 경고: 사용자 맵 전용 아이템 이름에는 자동으로 뒤에 언더바 한 개가 붙으므로 관련 편집 시 참고 바랍니다.", default_string);
if (!text_builder(itemnames)) break;
if (string_contains(itemnames, "+", 1) > -1) break;
if (string_contains(itemnames, "=", 1) > -1) break;
itemnames = string_replace(itemnames, " ", ":", true);
itemnames = string_replace(itemnames, ",", ":", true);
sendtext += "\r\nispawn:" + loc + ":" + amount + ":" + unit + ":" + unspawn + ":" + limit + ":" + itemnames;
break;
}
break; case maporder_door:
{
default_double = (old_parsed.length > 7 ? string_to_number(old_parsed[7]) : mr.x);
string arx = number_builder("도착할 X 좌표를 입력하세요.", default_double);
if (arx.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : mr.y);
string ary = number_builder("도착할 Y 좌표를 입력하세요.", default_double);
if (ary.is_empty()) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : me.z);
string arz = number_builder("도착할 Z 좌표를 입력하세요.", default_double);
if (arz.is_empty()) break;
default_string = (old_parsed.length > 10 ? old_parsed[10] : "리프트");
string dn = input_box_pro("리프트 이름을 입력하세요. 기본값은 " + default_string + "입니다.", default_string);
if (!text_builder(dn)) break;
default_double = (old_parsed.length > 11 ? string_to_number(old_parsed[11]) : 100);
int movingspeed = string_to_number(input_box_pro("이동 속도를 입력하세요. 기본값은 " + default_double + "밀리초입니다.", default_double));
if (movingspeed < 1) break;
default_double = (old_parsed.length > 12 ? string_to_number(old_parsed[12]) : 0);
int movepattern = select_course(default_double);
if (movepattern == 0) break;
string doortype;
if (old_parsed.length < 18) doortype = list_doors(old_parsed.length > 13 ? old_parsed[13] : empty);
else
{
int reset = yesno("현재 리프트 사운드는 사용자 지정 버전으로 동작하고 있습니다. 초기화하고 처음부터 다시 설정하시겠습니까?", 2);
if (reset == 0) break;
if (reset == 1) doortype = list_doors(empty);
else
{
default_string = (old_parsed.length > 13 ? old_parsed[13] : empty);
string open = input_box_pro("리프트가 출발할 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.", default_string);
if (!text_builder(open)) break;
default_string = (old_parsed.length > 14 ? old_parsed[14] : empty);
string close = input_box_pro("리프트가 도착할 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.", default_string);
if (!text_builder(close)) break;
default_string = (old_parsed.length > 15 ? old_parsed[15] : empty);
string loop = input_box_pro("리프트가 움직일 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.", default_string);
if (!text_builder(loop)) break;
default_double = (old_parsed.length > 16 ? string_to_number(old_parsed[16]) : 0);
string ready = number_builder("리프트가 출발할 때까지 몇 밀리초동안 준비해야 합니까? 기본값은 " + default_double + "밀리초입니다.", default_double);
if (!string_is_digits(ready)) break;
doortype = open + ":" + close + ":" + loop + ":" + ready;
}
}
if (doortype.is_empty()) break;
default_double = (old_parsed.length > 17 ? string_to_number(old_parsed[17]) : old_parsed.length > 14 ? string_to_number(old_parsed[14]) : 0);
if (old_parsed.length == 16 and old_parsed.length == 19) default_double += doorflag_limit;
int flags = select_door_flags(default_double);
if (flags == -1) break;
int tempflag = 0;
if (flags & doorflag_auto > 0) tempflag += doorflag_auto;
if (flags & doorflag_smart > 0) tempflag += doorflag_smart;
if (flags & doorflag_no_enter_sound > 0) tempflag += doorflag_no_enter_sound;
if (flags & doorflag_no_leave_sound > 0) tempflag += doorflag_no_leave_sound;
string wtext;
if (flags & doorflag_limit > 0)
{
default_string = (old_parsed.length == 19 ? old_parsed[18] : old_parsed.length == 16 ? old_parsed[15] : empty);
string wtext2 = input_box_pro("사용 자격을 입력하세요. 하나만 입력 가능합니다. 숫자만 입력하면 경험치로 사용 가능 여부를 판단합니다. 사용자 맵 전용 아이템인 경우 아이템 이름을 쓰고 뒤에 언더바 1개를 붙이세요.", default_string);
if (!text_builder(wtext2)) break;
wtext = ":" + wtext2;
if (string_contains(wtext2, "=", 1) == -1)
{
string amount = input_box_pro("아이템 이름으로 자격을 지정하는 경우에만 입력하세요. 몇 개가 필요합니까? 기본값은 1입니다. 모두 필요한 경우 a를 입력하세요.", 0, false, -1, -1, 2, false);
int am = string_to_number(amount);
if (am > 0)
{
int atext = yesno("이용하면 아이템을 소모하게 할까요?");
if (atext == 1) am *= -1;
}
if (am != 0) wtext += "*" + am;
else if (amount == "a") wtext += "*a";
}
}
if (flags & (doorflag_auto + doorflag_smart + doorflag_oppo) == (doorflag_smart + doorflag_oppo)) sendtext += "\r\ndoor:" + arx + ":" + int(string_to_number(arx) + xlength) + ":" + ary + ":" + int(string_to_number(ary) + ylength) + ":" + arz + ":" + int(string_to_number(arz) + zlength) + ":" + minx + ":" + miny + ":" + minz + ":" + dn + ":" + movingspeed + ":" + movepattern + ":" + doortype + ":" + tempflag + wtext;
sendtext += "\r\ndoor:" + loc + ":" + arx + ":" + ary + ":" + arz + ":" + dn + ":" + movingspeed + ":" + movepattern + ":" + doortype + ":" + tempflag + wtext;
}
break; case maporder_travelpoint:
{
default_string = (old_parsed.length > 7 ? old_parsed[7] : mapname);
string newmap = input_box_pro("도착할 맵 이름을 입력하세요. 경고: 현재 맵과 다른 맵을 입력하는 경우 해당 맵의 개발자 목록에 등록되어 있어야 사용 가능합니다.", default_string);
if (!text_builder(newmap)) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : mr.x);
string newx = number_builder("도착할 X 좌표를 입력하세요. 랜덤 이동은 -1, 체크 포인트로 이동은 -2를 입력하세요.", default_double);
if (newx.is_empty()) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : mr.y);
string newy = number_builder("도착할 Y 좌표를 입력하세요. 랜덤 이동은 -1, 체크 포인트로 이동은 -2를 입력하세요.", default_double);
if (newy.is_empty()) break;
default_double = (old_parsed.length > 10 ? string_to_number(old_parsed[10]) : me.z);
string newz = number_builder("도착할 Z 좌표를 입력하세요.", default_double);
if (newz.is_empty()) break;
default_string = (old_parsed.length > 11 ? old_parsed[11] : "포탈");
string dn = input_box_pro("포탈 이름을 입력하세요. 기본값은 " + default_string + "입니다.", default_string);
if (!text_builder(dn)) break;
int tempflag = 0;
int smart = yesno("스마트 포인터를 사용할까요?", (old_parsed.length > 12 ? (string_to_number(old_parsed[12]) & 1 > 0 ? 1 : 2) : 0));
if (smart <= 0) break;
if (smart == 1) tempflag += 1;
int auto1 = yesno("자동 포탈을 만들까요?", (old_parsed.length > 12 ? (string_to_number(old_parsed[12]) & 2 > 0 ? 1 : 2) : 0));
if (auto1 <= 0) break;
if (auto1 == 1) tempflag += 2;
string wtext;
int atext = yesno("사용 가능한 사람을 제한할까요?", (old_parsed.length > 13 ? 1 : 0));
if (atext <= 0) break;
if (atext == 1)
{
default_string = (old_parsed.length > 13 ? old_parsed[13] : empty);
string wtext2 = input_box_pro("사용 자격을 입력하세요. 하나만 입력 가능합니다. 숫자만 입력하면 경험치로 사용 가능 여부를 판단합니다. 사용자 맵 전용 아이템인 경우 아이템 이름을 쓰고 뒤에 언더바 1개를 붙이세요.", default_string);
if (!text_builder(wtext2)) break;
wtext = ":" + wtext2;
if (string_contains(wtext2, "=", 1) == -1)
{
string amount = input_box_pro("아이템 이름으로 자격을 지정하는 경우에만 입력하세요. 몇 개가 필요합니까? 기본값은 1입니다. 모두 필요한 경우 a를 입력하세요.", 0, false, -1, -1, 2, false);
int am = string_to_number(amount);
if (am > 0)
{
atext = yesno("이용하면 아이템을 소모하게 할까요?");
if (atext == 1) am *= -1;
}
if (am != 0) wtext += "*" + am;
else if (amount == "a") wtext += "*a";
}
}
if (mapname == newmap and smart == 1 and auto1 != 1)
{
int oppo = yesno("반대쪽에도 만들까요?");
if (oppo < 1) break;
if (oppo == 1) sendtext += "\r\ntravelpoint:" + newx + ":" + int(string_to_number(newx) + xlength) + ":" + newy + ":" + int(string_to_number(newy) + ylength) + ":" + newz + ":" + int(string_to_number(newz) + zlength) + ":" + newmap + ":" + minx + ":" + miny + ":" + minz + ":" + dn + ":" + tempflag + wtext;
}
sendtext += "\r\ntravelpoint:" + loc + ":" + newmap + ":" + newx + ":" + newy + ":" + newz + ":" + dn + ":" + tempflag + wtext;
}
break; case maporder_sb:
{
default_string = (old_parsed.length > 7 ? old_parsed[7] : empty);
string btext = input_box_pro("경계 이름을 입력하세요.", default_string);
if (!text_builder(btext)) break;
if (btext == sb_last) break;
default_string = (old_parsed.length > 8 ? old_parsed[8] : empty);
string vol = input_box_pro("볼륨 크기를 입력하세요. 0 이하 또는 50 초과는 음소거입니다.", default_string);
if (!string_is_digits(vol)) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : 0);
string priority = number_builder("우선순위를 0 이상의 숫자로 입력하세요. 숫자가 높을 수록 우선순위가 높습니다.", default_double);
if (!string_is_digits(priority)) break;
int tempflag = 0;
int lay = yesno("걸쳐 있는 사운드는 경계 대상에서 제외할까요?", (old_parsed.length > 9 ? (string_to_number(old_parsed[9]) & 1 > 0 ? 1 : 2) : 0));
if (lay <= 0) break;
if (lay == 1) tempflag += 1;
int inclu = yesno("경계보다 큰 사운드는 경계 대상에서 제외할까요?", (old_parsed.length > 9 ? (string_to_number(old_parsed[9]) & 2 > 0 ? 1 : 2) : 0));
if (inclu <= 0) break;
if (inclu == 1) tempflag += 2;
sendtext += "\r\nsb:" + loc + ":" + btext + ":" + vol + ":" + priority + ":" + tempflag;
}
break; case maporder_etp:
{
string sn = list_ambiences(old_parsed.length > 7 ? old_parsed[7] : empty);
if (sn.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 1000);
string cooldown = number_builder("사운드를 재생할 쿨다운을 밀리초 단위로 입력하세요. 기본값은 " + default_double + "밀리초, 최소는 50밀리초입니다.", default_double);
if (cooldown.is_empty()) break;
if (string_to_number(cooldown) < 50) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : 0);
string autoplay = number_builder("들어가면 자동으로 재생되게 할까요? 기본값은 " + default_double + "이며, 0을 입력하면 엔터 키를 눌러 재생합니다. 1 이상의 숫자를 입력하면 해당 칸에 들어가면 지정된 횟수만큼 자동 재생하며, 다른 플레이어의 엔터로 재생과 중복됩니다. 중복 재생 없는 무한 재생은 -1을 입력하세요.", default_double);
if (autoplay.is_empty()) break;
if (string_to_number(autoplay) <= -2) break;
default_double = (old_parsed.length > 10 ? string_to_number(old_parsed[10]) : 100);
string volume = number_builder("볼륨 크기를 0에서 100 사이의 값으로 입력하세요. 기본값은 " + default_double + "입니다.", default_double);
if (!string_is_digits(volume)) break;
sendtext += "\r\netp:" + loc + ":" + sn + ":" + cooldown + ":" + autoplay + ":" + volume;
}
break; case maporder_src:
{
string soundfile = list_ambiences(old_parsed.length > 7 ? old_parsed[7] : empty);
if (soundfile.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 100);
string volume = number_builder("볼륨 크기를 0에서 100 사이의 값으로 입력하세요. 기본값은 " + default_double + "입니다.", default_double);
if (!string_is_digits(volume)) break;
sendtext += "\r\nsrc:" + loc + ":" + soundfile + ":" + volume;
}
break; case maporder_amb:
{
string soundfile = list_ambiences(old_parsed.length > 7 ? old_parsed[7] : empty);
if (soundfile.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 100);
string volume = number_builder("볼륨 크기를 0에서 100 사이의 값으로 입력하세요. 기본값은 " + default_double + "입니다.", default_double);
if (!string_is_digits(volume)) break;
sendtext += "\r\namb:" + loc + ":" + soundfile + ":" + volume;
}
break; case maporder_robots:
{
default_double = (old_parsed.length > 7 ? string_to_number(old_parsed[7]) : 1);
string amount = number_builder("몇 개까지 누적 소환할까요? 음수를 입력하면 플레이어 수에 맞춰 가변으로 소환합니다. 기본값은 " + default_double + "입니다.", default_double);
if (amount.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 1000);
string unit = number_builder("몇 밀리초마다 소환하게 할까요? 기본값은 " + default_double + "밀리초, 최소 50 밀리초입니다.", default_double);
if (string_to_number(unit) < 50) break;
default_double = (old_parsed.length > 11 ? string_to_number(old_parsed[11]) : 0);
string teamnum = number_builder("팀 번호를 부호 없는 32비트 정수로 입력하세요. 기본값은 " + default_double + "입니다.", default_double);
teamnum = uint(string_to_number(teamnum));
default_string = (old_parsed.length > 10 ? old_parsed[10] : ".");
string platform = plattypemenu(default_string, true);
if (platform.is_empty()) break;
default_string = (old_parsed.length > 9 ? old_parsed[9] : empty);
string rtnames = input_box_pro("로봇 이름을 입력하세요. 두 개 이상의 로봇 중 무작위로 소환하게 하려면 로봇 이름 사이에 빈 칸이나 쉼표를 삽입하세요. 로봇 이름 안에는 더하기, 등호, 쌍점, 대괄호, 새문단 기호가 들어갈 수 없습니다.", default_string);
if (!text_builder(rtnames)) break;
if (string_contains(rtnames, "+", 1) > -1) break;
if (string_contains(rtnames, "=", 1) > -1) break;
rtnames = string_replace(rtnames, " ", ",", true);
sendtext += "\r\nrobots:" + loc + ":" + amount + ":" + unit + ":" + rtnames + ":" + platform + ":" + teamnum;
break;
}
break; case maporder_tile:
{
default_string = (old_parsed.length > 7 ? old_parsed[7] : empty);
string platform = plattypemenu(default_string);
if (platform.is_empty()) break;
string temp;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[8]) : -2);
int slide = select_slide(default_double);
if (slide > -1)
{
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : 200);
int movingspeed = string_to_number(input_box_pro("플래폼 위에서 자동으로 움직일 속도를 입력하세요. 기본값은 " + default_double + "밀리초입니다.", default_double));
if (movingspeed < 1) break;
temp += ":" + slide + ":" + movingspeed;
}
int trackable = yesno("카메라로 조사 가능한 플래폼입니까?", (old_parsed.length == 9 or old_parsed.length == 11 ? 2 : 0));
if (trackable <= 0) break;
if (trackable == 2) temp += ":hazard";
sendtext += "\r\ntile:" + loc + ":" + platform + temp;
}
break; case maporder_gate:
{
default_string = (old_parsed.length > 7 ? old_parsed[7] : empty);
string platform = plattypemenu(default_string);
if (platform.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : 0);
int open1 = string_to_number(number_builder("문을 몇 밀리초 뒤에 자동으로 열까요? 기본값은 " + default_double + "입니다. 0을 입력하면 문을 자동으로 열지 않습니다.", default_double));
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : 0);
int open2 = string_to_number(number_builder("문을 열 때 몇 밀리초가 걸립니까? 기본값은 " + default_double + "입니다. 음수를 입력하면 문 좌표에 물체가 있으면 문을 열지 않습니다.", default_double));
default_string = (old_parsed.length > 10 ? old_parsed[10] : empty);
string sound_f = list_ambiences(default_string, true);
if (sound_f.is_empty()) break;
default_double = (old_parsed.length > 11 ? string_to_number(old_parsed[11]) : 0);
int close1 = string_to_number(number_builder("문을 몇 밀리초 뒤에 자동으로 닫을까요? 기본값은 " + default_double + "입니다. 0을 입력하면 문을 자동으로 닫지 않습니다.", default_double));
default_double = (old_parsed.length > 12 ? string_to_number(old_parsed[12]) : 0);
int close2 = string_to_number(number_builder("문을 닫을 때 몇 밀리초가 걸립니까? 기본값은 " + default_double + "입니다. 음수를 입력하면 문 좌표 위에 물체가 있으면 문을 닫지 않습니다.", default_double));
default_string = (old_parsed.length > 13 ? old_parsed[13] : empty);
string sound_s = list_ambiences(default_string, true);
if (sound_s.is_empty()) break;
string temp;
default_double = (old_parsed.length > 14 ? string_to_number(old_parsed[14]) : 0);
string movex = input_box_pro("열린 문은 X 축으로 몇 칸 움직입니까? 기본값은 " + default_double + "입니다. 음수는 서쪽, 양수는 동쪽입니다. 칸 수를 잘 모르겠다면 방향만 입력하세요. 0을 입력하면 문은 X 축으로 움직이지 않습니다.", default_double);
int plus_x = string_to_number(movex);
if (word_east.exists(movex)) plus_x = (xlength + 1);
else if (word_west.exists(movex)) plus_x = -(xlength + 1);
default_double = (old_parsed.length > 15 ? string_to_number(old_parsed[15]) : 0);
string movey = input_box_pro("열린 문은 Y 축으로 몇 칸 움직입니까? 기본값은 " + default_double + "입니다. 음수는 남쪽, 양수는 북쪽입니다. 칸 수를 잘 모르겠다면 방향만 입력하세요. 0을 입력하면 문은 Y 축으로 움직이지 않습니다.", default_double);
int plus_y = string_to_number(movey);
if (word_north.exists(movey)) plus_y = (ylength + 1);
else if (word_south.exists(movey)) plus_y = -(ylength + 1);
default_double = (old_parsed.length > 16 ? string_to_number(old_parsed[16]) : 0);
string movez = input_box_pro("열린 문은 Z 축으로 몇 칸 움직입니까? 기본값은 " + default_double + "입니다. 음수는 아래쪽, 양수는 위쪽입니다. 칸 수를 잘 모르겠다면 방향만 입력하세요. 0을 입력하면 문은 Z 축으로 움직이지 않습니다.", default_double);
int plus_z = string_to_number(movez);
if (word_up.exists(movez)) plus_z = (zlength + 1);
else if (word_down.exists(movez)) plus_z = -(zlength + 1);
default_double = (old_parsed.length > 18 ? string_to_number(old_parsed[17]) : -2);
int slide = select_slide(default_double);
if (slide > -1)
{
default_double = (old_parsed.length > 18 ? string_to_number(old_parsed[18]) : 200);
int movingspeed = string_to_number(input_box_pro("플래폼 위에서 자동으로 움직일 속도를 입력하세요. 기본값은 " + default_double + "밀리초입니다.", default_double));
if (movingspeed < 1) break;
temp += ":" + slide + ":" + movingspeed;
}
int trackable = yesno("카메라로 조사 가능한 플래폼입니까?", (old_parsed.length == 18 or old_parsed.length == 20 ? 2 : 0));
if (trackable <= 0) break;
if (trackable == 2) temp += ":hazard";
sendtext += "\r\ngate:" + loc + ":" + platform + ":" + open1 + ":" + open2 + ":" + sound_f + ":" + close1 + ":" + close2 + ":" + sound_s + ":" + plus_x + ":" + plus_y + ":" + plus_z + temp;
}
break; case maporder_switch:
{
string targetloc;
if (old_parsed.length < 13) targetloc = set_switch_radius();
else
{
int reset = yesno("스위치 관할 구역을 초기화하고 처음부터 다시 설정하시겠습니까?", 2);
if (reset == 0) break;
if (reset == 1) targetloc = set_switch_radius();
else
{
default_double = (old_parsed.length > 7 ? string_to_number(old_parsed[7]) : mr.x);
string targetminx = number_builder("스위치의 관할 영역 서쪽 끝 X 좌표를 입력하세요.", default_double);
if (targetminx.is_empty()) break;
default_double = (old_parsed.length > 8 ? string_to_number(old_parsed[8]) : string_to_number(targetminx));
string targetmaxx = number_builder("스위치의 관할 영역 동쪽 끝 X 좌표를 입력하세요.", default_double);
if (targetmaxx.is_empty()) break;
default_double = (old_parsed.length > 9 ? string_to_number(old_parsed[9]) : mr.y);
string targetminy = number_builder("스위치의 관할 영역 남쪽 끝 Y 좌표를 입력하세요.", default_double);
if (targetminy.is_empty()) break;
default_double = (old_parsed.length > 10 ? string_to_number(old_parsed[10]) : string_to_number(targetminy));
string targetmaxy = number_builder("스위치의 관할 영역 북쪽 끝 Y 좌표를 입력하세요.", default_double);
if (targetmaxy.is_empty()) break;
default_double = (old_parsed.length > 11 ? string_to_number(old_parsed[11]) : me.z);
string targetminz = number_builder("스위치의 관할 영역 아래쪽 끝 Z 좌표를 입력하세요.", default_double);
if (targetminz.is_empty()) break;
default_double = (old_parsed.length > 12 ? string_to_number(old_parsed[12]) : string_to_number(targetminz));
string targetmaxz = number_builder("스위치의 관할 영역 위쪽 끝 Z 좌표를 입력하세요.", default_double);
if (targetmaxz.is_empty()) break;
targetloc = targetminx + ":" + targetmaxx + ":" + targetminy + ":" + targetmaxy + ":" + targetminz + ":" + targetmaxz;
}
}
default_double = (old_parsed.length > 13 ? string_to_number(old_parsed[13]) : 1000);
int time = string_to_number(number_builder("쿨다운을 밀리초 단위로 입력하세요. 기본값은 " + default_double + "밀리초, 최소 200 밀리초입니다.", default_double));
if (time < 200) break;
default_string = (old_parsed.length > 14 ? old_parsed[14] : "문");
string name = input_box_pro("문 이름을 입력하세요. 기본값은 " + default_string + "입니다.", default_string);
if (name.is_empty()) break;
default_string = (old_parsed.length > 15 ? old_parsed[15] : empty);
string press = list_ambiences(default_string, true);
if (press.is_empty()) break;
string wtext;
int atext = yesno("사용 가능한 사람을 제한할까요?", (old_parsed.length > 16 ? 1 : 0));
if (atext <= 0) break;
if (atext == 1)
{
default_string = (old_parsed.length > 16 ? old_parsed[16] : empty);
string wtext2 = input_box_pro("사용 자격을 입력하세요. 하나만 입력 가능합니다. 숫자만 입력하면 경험치로 사용 가능 여부를 판단합니다. 사용자 맵 전용 아이템인 경우 아이템 이름을 쓰고 뒤에 언더바 1개를 붙이세요.", default_string);
if (!text_builder(wtext2)) break;
wtext = ":" + wtext2;
if (string_contains(wtext2, "=", 1) == -1)
{
string amount = input_box_pro("아이템 이름으로 자격을 지정하는 경우에만 입력하세요. 몇 개가 필요합니까? 기본값은 1입니다. 모두 필요한 경우 a를 입력하세요.", 0, false, -1, -1, 2, false);
int am = string_to_number(amount);
if (am > 0)
{
atext = yesno("이용하면 아이템을 소모하게 할까요?");
if (atext == 1) am *= -1;
}
if (am != 0) wtext += "*" + am;
else if (amount == "a") wtext += "*a";
}
}
sendtext += "\r\nswitch:" + loc + ":" + targetloc + ":" + time + ":" + name + ":" + press + wtext;
}
break;
}
}
if (!sendtext.is_empty())
{
if (old_data.is_empty()) send_reliable("buildnow " + sendtext, 4);
else send_reliable("mapedit \r\n" + old_data + "\r\n[]" + sendtext + "\r\n", 4);
}
}
}
return true_t;
}

void map_editor(bool admin = false)
{
string xyz;
int ldatalength = ldata.length;
if (ldatalength == 0) return;
m.reset(true, true);
m.wrap = true;
if (sidescrolling == 1) m.enable_left_and_right = true;
else m.enable_up_and_down = true;
m.multi_checking = true;
m.set_callback(editor_loop, empty);
for (uint i = 0; i < ldatalength; i++)
{
string[]@ params = string_split(ldata[i], ":", false);
if (params.length < 3) continue;
if (params[0] == "idscr")
{
m.add_item_tts("아이템 설명: " + params[1] + ", " + params[2], ldata[i]);
continue;
}
if (params.length < 7) continue;
xyz = "X " + params[1] + " ~ " + params[2] + ", Y " + params[3] + " ~ " + params[4] + ", Z " + params[5] + " ~ " + params[6];
switch (string_to_hash(params[0]))
{
case maporder_tile:
{
int pl = params.length;
if (pl < 8) continue;
string mess = params[7] + ", " + xyz;
if (pl > 10) m.add_item_tts("미지의 플래폼: " + mess + ", 미끄러짐 " + (get_slide(params[8])) + ", 속도 " + params[9], ldata[i]);
else if (pl > 9) m.add_item_tts("플래폼: " + mess + ", 미끄러짐 " + (get_slide(params[8])) + ", 속도 " + params[9], ldata[i]);
else if (pl > 8) m.add_item_tts("미지의 플래폼: " + mess, ldata[i]);
else m.add_item_tts("플래폼: " + mess, ldata[i]);
}
break; case maporder_gate:
{
int pl = params.length;
if (pl < 17) continue;
string mess = params[7] + ", " + xyz + ", 열림 유지 시간 " + params[8] + ", 열림 준비 시간 " + params[9] + ", 열림 사운드 " + params[10] + ", 닫힘 유지 시간 " + params[11] + ", 닫힘 준비 시간 " + params[12] + ", 닫힘 사운드 " + params[13] + ", X 축 이동 " + params[14] + ", Y 축 이동 " + params[15] + ", Z 축 이동 " + params[16];
if (pl > 19) m.add_item_tts("미지의 문: " + mess + ", 미끄러짐 " + (get_slide(params[17])) + ", 속도 " + params[18], ldata[i]);
else if (pl > 18) m.add_item_tts("문: " + mess + ", 미끄러짐 " + (get_slide(params[17])) + ", 속도 " + params[18], ldata[i]);
else if (pl > 17) m.add_item_tts("미지의 문: " + mess, ldata[i]);
else m.add_item_tts("문: " + mess, ldata[i]);
}
break; case maporder_switch:
{
if (params.length > 15) m.add_item_tts("문 스위치: " + params[14] + ", 사운드 " + params[15] + ", " + xyz + ", 관할 구역: X " + params[7] + " ~ " + params[8] + ", Y " + params[9] + " ~ " + params[10] + ", Z " + params[11] + " ~ " + params[12] + ", 쿨다운 " + params[13] + (params.length > 16 ? ", 자격 " + params[16] : empty), ldata[i]);
}
break; case maporder_robots:
{
int pl = params.length;
if (pl < 10) continue;
string mess = "로봇 팀 " + (pl > 11 ? params[11] : 0) + ": 로봇 이름 " + string_replace(params[9], ",", ", ", true) + ", " + xyz + ", 최대 소환 기수 " + params[7] + ", " + params[8] + "밀리초마다 소환";
if (pl > 10) m.add_item_tts(mess + ", 타일 제한 " + string_replace(params[10], ",", ", ", true), ldata[i]);
else m.add_item_tts( mess, ldata[i]);
}
break; case maporder_zone:
{
if (params.length < 8) continue;
string mess = params[7] + ", " + xyz;
if (params.length > 8) m.add_item_tts("추적 가능한 텍스트 지역: " + mess, ldata[i]);
else m.add_item_tts("텍스트 지역: " + mess, ldata[i]);
}
break; case maporder_checkpoint:
{
if (params.length < 7) continue;
if (params.length > 7) m.add_item_tts("체크 포인트 1회용: " + xyz, ldata[i]);
else m.add_item_tts("체크 포인트: " + xyz, ldata[i]);
}
break; case maporder_noitem:
{
if (params.length < 8) break;
string text;
int pl = params.length;
for (uint x = 7; x < pl; x++)
{
text += params[x] + ", ";
}
m.add_item_tts("아이템 제한 " + text + ": " + xyz, ldata[i]);
}
break; case maporder_ctf:
{
if (params.length < 8) break;
string name;
int type = string_to_number(params[7]);
switch (type)
{
case 1:
name = "S 깃대";
break;
case 2:
name = "R 깃대";
break;
}
m.add_item_tts("깃발 게임 지역: " + name + ", " + xyz, ldata[i]);
}
break; case maporder_ispawn:
{
int pl = params.length;
if (pl < 13) continue;
string tempi;
for (uint i = 12; i < pl; i++)
{
if (i > 12) tempi += ", ";
tempi += params[i];
}
m.add_item_tts("아이템 소환 " + tempi + ": " + xyz + ", 최대 누적 소환 " + params[7] + "개, " + params[8] + "밀리초마다 소환하여 " + params[9] + "밀리초 동안 유지" + (string_to_number(params[10]) <= 0 ? empty : ", " + params[11] + "밀리초당 " + params[10] + "개 습득 가능"), ldata[i]);
}
break; case maporder_sb:
{
if (params.length < 8) continue;
string mess = params[7] + ", " + xyz;
if (params.length > 10) m.add_item_tts("사운드 경계 볼륨 " + params[8] + ": " + mess + ", 우선순위 " + params[9] + ", 플래그 " + flag_analysis("sb", params[10]), ldata[i]);
else if (params.length > 8) m.add_item_tts("사운드 경계 볼륨 " + params[8] + ": " + mess, ldata[i]);
else m.add_item_tts("사운드 경계 음소거: " + mess, ldata[i]);
}
break; case maporder_src:
{
if (params.length > 7) m.add_item_tts("사운드 효과: " + params[7] + (params.length > 8 ? ", 볼륨 " + params[8] : empty) + ", " + xyz, ldata[i]);
}
break; case maporder_amb:
{
if (params.length > 7) m.add_item_tts("사운드 환경" + (params.length > 8 ? " 볼륨 " + params[8] : empty) + ": " + params[7] + ", " + xyz, ldata[i]);
}
break; case maporder_travelpoint:
{
if (params.length > 12) m.add_item_tts("포탈: " + params[11] + ", 출발: " + xyz + ", 도착: " + params[8] + ", " + params[9] + ", " + params[10] + ", 도착 맵: " + params[7] + ", 플래그 " + flag_analysis("travelpoint", params[12]) + (params.length > 13 ? ", 자격 " + params[13] : empty), ldata[i]);
}
break; case maporder_etp:
{
if (params.length < 10) continue;
int mode = string_to_number(params[9]);
string mode_text;
switch (mode)
{
case -1: mode_text = "자동 재생, 중복 금지";
break; case 0: mode_text = "수동 재생";
break; default: mode_text = mode + "회 자동 재생, 중복 허용";
break;
}
m.add_item_tts("엔터로 재생: " + params[7] + ", 모드 " + mode_text + ", " + xyz + ", 쿨다운 " + params[8] + "밀리초" + (params.length > 10 ? ", 볼륨 " + params[10] : empty), ldata[i]);
}
break; case maporder_door:
{
if (params.length < 15) continue;
string mess;
if (params.length > 17) mess = params[10] + ", 출발 사운드 " + params[13] + ", 도착 사운드 " + params[14] + ", 루프 사운드 " + params[15] + ", 루프 준비 시간 " + params[16] + ", 출발: " + xyz + ", 도착: " + params[7] + ", " + params[8] + ", " + params[9] + ", 속도 " + params[11] + ", 진행 방향 " + params[12] + ", 플래그 " + flag_analysis("door", params[17]);
else mess = params[10] + ", 사운드 " + params[13] + ", 출발: " + xyz + ", 도착: " + params[7] + ", " + params[8] + ", " + params[9] + ", 속도 " + params[11] + ", 진행 방향 " + params[12] + ", 플래그 " + flag_analysis("door", params[14]);
if (params.length > 18) m.add_item_tts("리프트: " + mess + ", 자격 " + params[18], ldata[i]);
else if (params.length > 17) m.add_item_tts("리프트: " + mess, ldata[i]);
else if (params.length > 15) m.add_item_tts("리프트: " + mess + ", 자격 " + params[15], ldata[i]);
else m.add_item_tts("리프트: " + mess, ldata[i]);
}
break;
}
}
int mres = m.run("맵 데이터 편집기", true);
if (mres < 0) return;
if (mres == 0)
{
speak("취소되었습니다.");
return;
}
if (mres == -5) return;
string result = m.get_item_name(mres);
if (result.is_empty())
{
speak("취소되었습니다.");
return;
}
string[]@ selected = m.get_checked_item_list();
int checknum = selected.length;
if (checknum == 0)
{
if (!buildsomething(result, admin))
{
int init = yesno("직접 편집이 불가능한 데이터입니다. 삭제할까요?");
if (init == 1) send_reliable("mapdelete \r\n" + result + "\r\n", 4);
}
return;
}
string final;
for (uint i = 0; i < checknum; i++)
{
final += "\r\n" + selected[i] + "\r\n[]";
}
send_reliable("mapdelete " + final, 4);
}

int editor_loop(dynamic_menu_pro@ m, string data)
{
if (key_pressed(KEY_F5))
{
string old_convert = m.get_item_name(m.menu_position);
string convert = mapeditor_change_loc(old_convert, shift_is_down);
if (!convert.is_empty() and convert != old_convert)
{
send_reliable("mapedit \r\n" + old_convert + "\r\n[]\r\n" + convert + "\r\n", 4);
return -5;
}
}
if (key_pressed(KEY_F6))
{
string old_convert = m.get_item_name(m.menu_position);
string selected;
int itemlength = m.item_list.length;
for (uint i = 0; i < itemlength; i++)
{
if (m.item_list[i].checked)
{
selected = m.item_list[i].name;
break;
}
}
string convert = mapeditor_change_loc(old_convert, shift_is_down);
if (!convert.is_empty())
{
if (selected.is_empty()) send_reliable("buildnow \r\n" + convert, 4);
else send_reliable("mapedit \r\n" + selected + "\r\n[]\r\n" + convert + "\r\n" + selected + "\r\n", 4);
return -5;
}
}
if (key_pressed(KEY_F7))
{
string old_convert = m.get_item_name(m.menu_position);
string convert = mapeditor_split_loc(old_convert, shift_is_down);
if (!convert.is_empty() and convert != old_convert)
{
send_reliable("mapedit \r\n" + old_convert + "\r\n[]\r\n" + convert + "\r\n", 4);
return -5;
}
}
if (key_pressed(KEY_F8))
{
string current;
int itemlength = m.item_list.length;
for (uint i = 0; i < itemlength; i++)
{
if (m.item_list[i].checked) current += "\r\n" + m.item_list[i].name;
}
if (current.is_empty()) current = m.get_item_name(m.menu_position);
string mapname = input_box_pro("어떤 맵으로 내보낼까요?");
if (!mapname.is_empty())
{
send_reliable("buildothermap " + mapname + " \r\n" + current, 4);
return -5;
}
}
return 0;
}

string mapeditor_change_loc(const string& in origin, bool my_loc = false)
{
string[]@ params = string_split(origin, ":", true);
if (params.length < 7) return empty;
if (params[0] == "idscr") return empty;
int oldminx = (my_loc ? mr.x : string_to_number(params[1]));
string minx = number_builder("서쪽 끝 X 좌표를 입력하세요. 기본값은 " + oldminx + "입니다.", oldminx);
if (minx.is_empty()) return empty;
int oldmaxx = (my_loc ? string_to_number(minx) : string_to_number(params[2]));
string maxx = number_builder("동쪽 끝 X 좌표를 입력하세요. 기본값은 " + oldmaxx + "입니다.", oldmaxx);
if (maxx.is_empty()) return empty;
int oldminy = (my_loc ? mr.y : string_to_number(params[3]));
string miny = number_builder("남쪽 끝 Y 좌표를 입력하세요. 기본값은 " + oldminy + "입니다.", oldminy);
if (miny.is_empty()) return empty;
int oldmaxy = (my_loc ? string_to_number(miny) : string_to_number(params[4]));
string maxy = number_builder("북쪽 끝 Y 좌표를 입력하세요. 기본값은 " + oldmaxy + "입니다.", oldmaxy);
if (maxy.is_empty()) return empty;
int oldminz = (my_loc ? me.z : string_to_number(params[5]));
string minz = number_builder("아래쪽 끝 Z 좌표를 입력하세요. 기본값은 " + oldminz + "입니다.", oldminz);
if (minz.is_empty()) return empty;
int oldmaxz = (my_loc ? string_to_number(minz) : string_to_number(params[6]));
string maxz = number_builder("위쪽 끝 Z 좌표를 입력하세요. 기본값은 " + oldmaxz + "입니다.", oldmaxz);
if (maxz.is_empty()) return empty;
string result = params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz;
int pl = params.length;
for (uint i = 7; i < pl; i++) result += ":" + params[i];
return result;
}

string mapeditor_split_loc(const string& in origin, bool my_loc = false)
{
string[]@ params = string_split(origin, ":", true);
if (params.length < 7) return empty;
if (params[0] == "idscr") return empty;
string stype = input_box_pro("어느 방향으로 나눌까요? X, Y, Z 중 하나를 입력하세요.");
if (stype.is_empty()) return empty;
string mess = string_trim_left(origin, string_contains(origin, ":", 7));
int minx = string_to_number(params[1]);
int maxx = string_to_number(params[2]);
int miny = string_to_number(params[3]);
int maxy = string_to_number(params[4]);
int minz = string_to_number(params[5]);
int maxz = string_to_number(params[6]);
string final;
int split = character_to_ascii(string_to_lower_case(stype));
switch (split)
{
case ascii_x:
{
int tx = (my_loc ? mr.x : (minx + maxx) * 0.5);
string newx = input_box_pro("어디를 기준으로 나눌까요? 3개 이상 나누려면 기준이 되는 좌표와 좌표 사이를 한 칸씩 띄우세요.", tx);
if (newx.is_empty()) return empty;
string[]@ splits = string_split(newx, " ", true);
splits.sort_ascending();
int slength = splits.length;
for (uint i = 0; i <= slength; i++)
{
if (i == slength)
{
if (final.is_empty()) return empty;
final += "\r\n" + params[0] + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxx + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz + mess;
return final;
}
if (final.is_empty())
{
int f = string_to_number(splits[i]);
if (f < minx) continue;
if (f >= maxx) return empty;
final = params[0] + ":" + minx + ":" + f + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz + mess;
continue;
}
int f = string_to_number(splits[i]);
if (f >= maxx)
{
final += "\r\n" + params[0] + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxx + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz + mess;
return final;
}
final += "\r\n" + params[0] + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + f + ":" + miny + ":" + maxy + ":" + minz + ":" + maxz + mess;
}
}
break; case ascii_y:
{
int ty = (my_loc ? mr.y : (miny + maxy) * 0.5);
string newy = input_box_pro("어디를 기준으로 나눌까요? 3개 이상 나누려면 기준이 되는 좌표와 좌표 사이를 한 칸씩 띄우세요.", ty);
if (newy.is_empty()) return empty;
string[]@ splits = string_split(newy, " ", true);
splits.sort_ascending();
int slength = splits.length;
for (uint i = 0; i <= slength; i++)
{
if (i == slength)
{
if (final.is_empty()) return empty;
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxy + ":" + minz + ":" + maxz + mess;
return final;
}
if (final.is_empty())
{
int f = string_to_number(splits[i]);
if (f < miny) continue;
if (f >= maxy) return empty;
final = params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + f + ":" + minz + ":" + maxz + mess;
continue;
}
int f = string_to_number(splits[i]);
if (f >= maxy)
{
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxy + ":" + minz + ":" + maxz + mess;
return final;
}
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + f + ":" + minz + ":" + maxz + mess;
}
}
break; case ascii_z:
{
int tz = (my_loc ? me.z : (minz + maxz) * 0.5);
string newz = input_box_pro("어디를 기준으로 나눌까요? 3개 이상 나누려면 기준이 되는 좌표와 좌표 사이를 한 칸씩 띄우세요.", tz);
if (newz.is_empty()) return empty;
string[]@ splits = string_split(newz, " ", true);
splits.sort_ascending();
int slength = splits.length;
for (uint i = 0; i <= slength; i++)
{
if (i == slength)
{
if (final.is_empty()) return empty;
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxz + mess;
return final;
}
if (final.is_empty())
{
int f = string_to_number(splits[i]);
if (f < minz) continue;
if (f >= maxz) return empty;
final = params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + minz + ":" + f + mess;
continue;
}
int f = string_to_number(splits[i]);
if (f >= maxz)
{
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + maxz + mess;
return final;
}
final += "\r\n" + params[0] + ":" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":" + (string_to_number(splits[i - 1]) + 1) + ":" + f + mess;
}
}
}
return empty;
}

string[]@ get_old_loc_array(const string& in origin)
{
string[]@ params = string_split(origin, ":", true);
if (params.length < 7) return null;
if (params[0] == "idscr") return null;
string[] new = {string_to_number(params[1]), string_to_number(params[2]), string_to_number(params[3]), string_to_number(params[4]), string_to_number(params[5]), string_to_number(params[6])};
return new;
}

string flag_analysis(const string& in type, const string& in flag)
{
uint thash = string_to_hash(type);
uint tflag = string_to_number(flag);
string temp;
switch (thash)
{
case maporder_door:
{
if (tflag & doorflag_auto > 0) temp += "자동리프트, ";
if (tflag & doorflag_smart > 0) temp += "스마트 포인터, ";
if (tflag & doorflag_no_enter_sound > 0) temp += "출발 사운드 없음, ";
if (tflag & doorflag_no_leave_sound > 0) temp += "도착 사운드 없음, ";
}
break;
case maporder_travelpoint:
{
if (tflag & 1 > 0) temp += "스마트 포인터, ";
if (tflag & 2 > 0) temp += "자동 포탈, ";
}
break;
case maporder_sb:
{
if (tflag & 1 > 0) temp += "걸치기 금지, ";
if (tflag & 2 > 0) temp += "덮기 금지, ";
}
break;
}
if (temp.is_empty()) temp = "없음";
return temp;
}

string plattypemenu(const string& in defv = empty, bool multi = false)
{
setupmenu();
m.multi_checking = multi;
dictionary old_list;
if (multi) old_list = text_to_dictionary(defv, ",", VALUE_NONE);
int platformlen = tilearray.length;
for (uint i = 0; i < platformlen; i++)
{
m.add_item_tts(tilearray[i], empty, empty, true, false, old_list.exists(tilearray[i]));
}
m.set_callback(plm, empty);
int mres = m.run("플래폼을 선택하세요.", true, m.get_item_index(defv));
mapeditor_player.close();
if (mres <= 0) return empty;
if (multi)
{
string new;
int itemlength = m.item_list.length;
for (uint i = 0; i < itemlength; i++)
{
if (!m.item_list[i].checked) continue;
if (!new.is_empty()) new += ",";
new += m.item_list[i].name;
}
if (new.is_empty()) new = ".";
return new;
}
return m.get_item_name(mres);
}

int plm(dynamic_menu_pro@ m, string data)
{
data = m.get_item_name(m.menu_position);
if (key_pressed(KEY_F5))
{
if (string_left(data, 4) == "wall") mapeditor_play(data);
else mapeditor_play(data + "step" + random(1, 5));
}
else if (key_pressed(KEY_F6))
{
mapeditor_play(data + "land");
}
else if (key_pressed(KEY_F7))
{
mapeditor_play(data + "hardland");
}
return 0;
}

const string& list_doors(const string& in defv = empty)
{
setupmenu();
m.add_item_tts("직접 입력하기", "...", empty);
int doorlen = doorarray.length;
for (uint i = 0; i < doorlen; i++)
{
m.add_item_tts(doorarray[i]);
}
m.set_callback(doormenu, empty);
int mres = m.run("리프트 종류를 선택하세요.", true, m.get_item_index(defv));
mapeditor_player.close();
if (mres <= 0) return empty;
string result = m.get_item_name(mres);
if (result.is_empty()) return empty;
if (result == "...")
{
string open = input_box_pro("리프트가 출발할 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.");
if (!text_builder(open)) return empty;
string close = input_box_pro("리프트가 도착할 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.");
if (!text_builder(close)) return empty;
string loop = input_box_pro("리프트가 움직일 때 재생할 사운드 이름을 입력하세요. 없으면 없는 사운드 이름을 입력하세요.");
if (!text_builder(loop)) return empty;
string ready = number_builder("리프트가 출발할 때까지 몇 밀리초동안 준비해야 합니까? 기본값은 0입니다.", 0);
if (!string_is_digits(ready)) return empty;
ref_string = open + ":" + close + ":" + loop + ":" + ready;
return ref_string;
}
ref_string = result;
return ref_string;
}

int doormenu(dynamic_menu_pro@ m, string data)
{
data = m.get_item_name(m.menu_position);
if (key_pressed(KEY_F5))
{
mapeditor_play(data + "_loop");
}
else if (key_pressed(KEY_F6))
{
mapeditor_play(data + "_open");
}
else if (key_pressed(KEY_F7))
{
mapeditor_play(data + "_close");
}
return 0;
}

string list_ambiences(const string& in defv = empty, bool is_door_sound = false)
{
setupmenu();
m.multi_checking = true;
string[] old_parsed;
dictionary old_list;
if (!defv.is_empty())
{
old_parsed = string_split(defv, "*", false);
string nsn = input_box_pro("사운드 이름을 입력하세요. 확장자는 붙이지 않아도 되며, 표현식을 사용할 수 있습니다. 초기화하고 처음부터 다시 선택하려면 마침표를 입력하세요.", defv);
if (nsn.is_empty()) return empty;
if (nsn != ".") return nsn;
old_list = text_to_dictionary(old_parsed[0], "|", VALUE_NONE);
}
m.add_item_tts("직접 입력하기.", "???", empty, true, true);
m.add_item_tts("고급 설정을 시작하려면 1개 이상의 항목을 선택 후 여기를 누르세요.", "...", empty, true, true);
if (is_door_sound)
{
int doorlen = doorarray.length;
for (uint i = 0; i < doorlen; i++)
{
if (file_exists(sndfolder + doorarray[i] + "_open.ogg")) m.add_item(doorarray[i] + "_open.ogg", doorarray[i] + "_open", empty, true, false, (old_list.exists(doorarray[i])));
if (file_exists(sndfolder + doorarray[i] + "_close.ogg")) m.add_item(doorarray[i] + "_close.ogg", doorarray[i] + "_close", empty, true, false, (old_list.exists(doorarray[i])));
}
}
else
{
int srcarraylength = srcarray.length;
for (uint i = 0; i < srcarraylength; i++)
{
if (file_exists(sndfolder + srcarray[i] + ".ogg")) m.add_item(srcarray[i] + ".ogg", srcarray[i], empty, true, false, (old_list.exists(srcarray[i])));
}
}
m.set_callback(srcclb, empty);
int mres = m.run("사운드를 선택하세요.", true);
if (mres <= 0) return empty;
string result = m.get_item_name(mres);
if (result.is_empty()) return empty;
string new;
int itemlength = m.item_list.length;
for (uint i = 0; i < itemlength; i++)
{
if (!m.item_list[i].checked) continue;
if (!new.is_empty()) new += "|";
new += m.item_list[i].name;
}
if (new.is_empty())
{
if (result == "...")
{
speak("아무것도 선택되어 있지 않습니다.");
return list_ambiences(defv);
}
new = result;
}
if (result == "???")
{
string sn = input_box_pro("사운드 이름을 입력하세요. 확장자는 붙이지 않아도 되며, 표현식을 사용할 수 있습니다.", new);
if (!text_builder(sn)) return empty;
return sn;
}
if (result != "...") return new;
string mins = number_builder("무작위 재생 시간 최소 밀리초를 입력하세요.", 0);
if (mins.is_empty()) return empty;
string maxs = number_builder("무작위 재생 시간 최대 밀리초를 입력하세요.", string_to_number(mins));
if (maxs.is_empty()) return empty;
string limit = number_builder("재생 횟수를 입력하세요. 기본값은 0이며, 0으로 지정하면 무한 재생합니다.", 0);
if (limit.is_empty()) return empty;
int tempflag = 0;
int rand = yesno("재생 순서를 무작위로 할까요?");
if (rand <= 0) return empty;
if (rand == 1) tempflag++;
else
{
new = src_swap_array(string_split(new, "|", false));
if (new.is_empty()) return empty;
}
int paused = yesno("무작위 재생 시간 카운트는 사운드 재생을 마친 후부터 할까요?");
if (paused <= 0) return empty;
if (paused == 1) tempflag += 2;
return new + "*" + mins + "|" + maxs + "*" + limit + "*" + tempflag;
}

int srcclb(dynamic_menu_pro@ m, string data)
{
if (key_pressed(KEY_TAB))
{
speak(m.get_item_name(m.menu_position) + ", 「" + m.menu_position + " / " + m.item_list.length) + "」";
return 0;
}
if (key_pressed(KEY_F9))
{
if (m.menu_position > 0 and m.menu_position <= m.item_list.length)
{
if (m.item_list[m.menu_position - 1].is_filename and m.internal_sound !is null)
{
speak(m.internal_sound.length + "밀리초");
return 0;
}
}
}
return 0;
}

int select_slide(int dir = -2)
{
setupmenu(true);
m.add_item_tts("안 함", "-1");
m.add_item_tts("북", "0");
m.add_item_tts("동", "1");
m.add_item_tts("남", "2");
m.add_item_tts("서", "3");
m.add_item_tts("위", "4");
m.add_item_tts("밑", "5");
m.add_item_tts("북동", "6");
m.add_item_tts("북서", "7");
m.add_item_tts("남동", "8");
m.add_item_tts("남서", "9");
int mres = m.run("이 플래폼 위에 서 있으면 미끄러지게 만들까요?", true, dir + 2);
if (mres <= 0) return -1;
return string_to_number(m.get_item_name(mres));
}

int select_course(int start_p = 0)
{
setupmenu(true);
m.add_item_tts("x, y, z", "1");
m.add_item_tts("y, x, z", "2");
m.add_item_tts("x, z, y", "3");
m.add_item_tts("y, z, x", "4");
m.add_item_tts("z, x, y", "5");
m.add_item_tts("z, y, x", "6");
int mres = m.run("좌표를 움직일 순서를 지정하세요.", true, start_p);
return string_to_number(m.get_item_name(mres));
}

int ctf_zone_select()
{
setupmenu(true);
m.add_item_tts("S 깃대", "1");
m.add_item_tts("R 깃대", "2");
m.add_item_tts("S 깃발 소환 지점", "3");
m.add_item_tts("R 깃발 소환 지점", "4");
int mres = m.run("여기에 무엇을 만들까요?", true);
return string_to_number(m.get_item_name(mres));
}

string src_swap_array(string[]@ temp_array, int last_cursor = 0)
{
setupmenu();
m.multi_checking = true;
m.add_item_tts("새 사운드 추가.", "/new", empty, true, true);
m.add_item_tts("슬립 삽입", "/sleep", empty, true, true);
m.add_item_tts("사운드를 복사하려면 1개 이상의 항목 선택 후 여기를 누르세요.", "/copy", empty, true, true);
m.add_item_tts("사운드를 삭제하려면 1개 이상의 항목 선택 후 여기를 누르세요.", "/delete", empty, true, true);
int arraylength = temp_array.length;
for (uint i = 0; i < arraylength; i++)
{
if (string_left(temp_array[i], 1) == "/") m.add_item_tts("슬립 " + string_trim_left(temp_array[i], 1) + "밀리초", temp_array[i], empty);
else if (file_exists(sndfolder + temp_array[i] + ".ogg")) m.add_item(temp_array[i] + ".ogg", temp_array[i], empty);
else m.add_item_tts(temp_array[i] + ".ogg", temp_array[i], empty);
}
m.add_item_tts("모두 다 편집했으면 여기를 누르세요.", "/confirm", empty, true, true);
m.set_callback(srcclb, empty);
int mres = m.run("사운드 편집 메뉴", true, last_cursor);
if (mres <= 0) return empty;
string result = m.get_item_name(mres);
if (result.is_empty()) return empty;
if (result == "/sleep")
{
string ntext = input_box_pro("몇 밀리초동안 슬립하게 할까요? 기본값은 1초입니다.", 1000);
if (string_is_digits(ntext))
{
temp_array.insert_last("/" + ntext);
speak("가장 뒤에 삽입했습니다. 적절한 위치에 배치하세요.");
}
return src_swap_array(temp_array);
}
if (result == "/new")
{
string ntext = input_box_pro("사운드 이름을 입력하세요.");
if (!ntext.is_empty())
{
temp_array.insert_last(ntext);
speak("가장 뒤에 삽입했습니다. 적절한 위치에 배치하세요.");
}
return src_swap_array(temp_array);
}
if (result == "/confirm")
{
if (temp_array.is_empty())
{
speak("사운드는 최소 1개 이상 있어야 합니다.");
return src_swap_array(temp_array);
}
if (string_left(temp_array[0], 1) == "/")
{
speak("맨 처음에는 슬립이 올 수 없습니다.");
return src_swap_array(temp_array);
}
string new;
for (uint i = 0; i < arraylength; i++)
{
if (!new.is_empty()) new += "|";
new += temp_array[i];
}
return new;
}
int[]@ multi_checked = m.get_checked_item_index(-4);
if (result == "/copy")
{
if (!multi_checked.is_empty())
{
int amount = string_to_number(number_builder("몇 번 복사할까요? 기본값은 1입니다.", 1));
if (amount > 0)
{
int multilength = multi_checked.length;
for (uint j = 0; j < amount; j++)
{
for (uint i = 0; i < multilength; i++) temp_array.insert_last(temp_array[multi_checked[i]]);
}
speak(multilength + "개 항목을 가장 뒤에 " + amount + "회 복사했습니다. 적절한 위치에 배치하세요.");
}
}
return src_swap_array(temp_array);
}
if (result == "/delete")
{
if (!multi_checked.is_empty())
{
multi_checked.sort_descending();
int multilength = multi_checked.length;
for (uint i = 0; i < multilength; i++) temp_array.remove_at(multi_checked[i]);
speak(multilength + "개 항목을 삭제했습니다.");
}
return src_swap_array(temp_array);
}
bool success = swap_array(temp_array, multi_checked, mres - 5);
return src_swap_array(temp_array, mres);
}

int select_door_flags(int defv = 0)
{
m.reset(true, true);
m.wrap = true;
if (sidescrolling == 1) m.enable_left_and_right = true;
else m.enable_up_and_down = true;
m.multi_checking = true;
m.add_item_tts("자동리프트입니다. 좌표에 들어가면 자동으로 출발합니다.", doorflag_auto, empty, true, false, defv & doorflag_auto > 0);
m.add_item_tts("스마트 포인터를 사용합니다.", doorflag_smart, empty, true, false, defv & doorflag_smart > 0);
m.add_item_tts("출발 사운드가 출력되지 않습니다.", doorflag_no_enter_sound, empty, true, false, defv & doorflag_no_enter_sound > 0);
m.add_item_tts("도착 사운드가 출력되지 않습니다.", doorflag_no_leave_sound, empty, true, false, defv & doorflag_no_leave_sound > 0);
m.add_item_tts("사용 가능한 사람을 제한합니다.", doorflag_limit, empty, true, false, defv & doorflag_limit > 0);
m.add_item_tts("반대쪽에도 만듭니다. 자동리프트가 꺼져 있고, 스마트 포인터가 켜져 있어야 작동합니다.", doorflag_oppo);
int mres = m.run("원하는 항목을 모두 선택하고 엔터 키를 누르세요.", true);
if (mres <= 0) return -1;
int flags = 0;
int itemlength = m.item_list.length;
for (uint i = 0; i < itemlength; i++)
{
if (!m.item_list[i].checked) continue;
flags += string_to_number(m.item_list[i].name);
}
return flags;
}

const string& set_switch_radius()
{
setupmenu();
m.add_item_tts("직접 입력하기", "...", empty);
string colon = ":";
int mglength = mapgates.length;
for (uint i = 0; i < mglength; i++)
{
maptile@ temp = mapgates[i];
m.add_item_tts(temp.type + ", 닫힘: X " + temp.minx + " ~ " + temp.maxx + ", Y " + temp.miny + " ~ " + temp.maxy + ", Z " + temp.minz + " ~ " + temp.maxz + ", 열림: X " + int(temp.minx + temp.plus_x) + " ~ " + int(temp.maxx + temp.plus_x) + ", Y " + int(temp.miny + temp.plus_y) + " ~ " + int(temp.maxy + temp.plus_y) + ", Z " + int(temp.minz + temp.plus_z) + " ~ " + int(temp.maxz + temp.plus_z), temp.minx + colon + temp.maxx + colon + temp.miny + colon + temp.maxy + colon + temp.minz + colon + temp.maxz + colon + temp.center_x + colon + temp.center_y + colon + temp.center_z + colon + int(temp.minx + temp.plus_x) + colon + int(temp.maxx + temp.plus_x) + colon + int(temp.miny + temp.plus_y) + colon + int(temp.maxy + temp.plus_y) + colon + int(temp.minz + temp.plus_z) + colon + int(temp.maxz + temp.plus_z) + colon + double(temp.center_x + temp.plus_x) + colon + double(temp.center_y + temp.plus_y) + colon + double(temp.center_z + temp.plus_z) + colon + int(temp.size_x * 2) + colon + int(temp.size_y * 2) + colon + int(temp.size_z * 2));
}
int mres = m.run("문 좌표 선택.", true);
if (mres <= 0) return empty;
string result = m.get_item_name(mres);
if (result.is_empty()) return empty;
if (result == "...")
{
string targetminx = number_builder("스위치의 관할 영역 서쪽 끝 X 좌표를 입력하세요.", mr.x);
if (targetminx.is_empty()) return empty;
string targetmaxx = number_builder("스위치의 관할 영역 동쪽 끝 X 좌표를 입력하세요.", string_to_number(targetminx));
if (targetmaxx.is_empty()) return empty;
string targetminy = number_builder("스위치의 관할 영역 남쪽 끝 Y 좌표를 입력하세요.", mr.y);
if (targetminy.is_empty()) return empty;
string targetmaxy = number_builder("스위치의 관할 영역 북쪽 끝 Y 좌표를 입력하세요.", string_to_number(targetminy));
if (targetmaxy.is_empty()) return empty;
string targetminz = number_builder("스위치의 관할 영역 아래쪽 끝 Z 좌표를 입력하세요.", me.z);
if (targetminz.is_empty()) return empty;
string targetmaxz = number_builder("스위치의 관할 영역 위쪽 끝 Z 좌표를 입력하세요.", string_to_number(targetminz));
if (targetmaxz.is_empty()) return empty;
ref_string = targetminx + ":" + targetmaxx + ":" + targetminy + ":" + targetmaxy + ":" + targetminz + ":" + targetmaxz;
return ref_string;
}
string[]@ locs = string_split(result, colon, true);
if (locs.length < 21) return empty;
setupmenu();
int center_x1 = string_to_number(locs[6]);
int center_x2 = string_to_number(locs[15]);
int center_y1 = string_to_number(locs[7]);
int center_y2 = string_to_number(locs[16]);
int center_z1 = string_to_number(locs[8]);
int center_z2 = string_to_number(locs[17]);
int minx, maxx;
if (abs(center_x1 - center_x2) <= string_to_number(locs[18]))
{
minx = floor((center_x1 + center_x2) * 0.5);
maxx = ceiling((center_x1 + center_x2) * 0.5);
}
else if (center_x1 > center_x2)
{
minx = string_to_number(locs[10]);
maxx = string_to_number(locs[0]);
}
else
{
minx = string_to_number(locs[1]);
maxx = string_to_number(locs[9]);
}
int miny, maxy;
if (abs(center_y1 - center_y2) <= string_to_number(locs[19]))
{
miny = floor((center_y1 + center_y2) * 0.5);
maxy = ceiling((center_y1 + center_y2) * 0.5);
}
else if (center_y1 > center_y2)
{
miny = string_to_number(locs[12]);
maxy = string_to_number(locs[2]);
}
else
{
miny = string_to_number(locs[3]);
maxy = string_to_number(locs[11]);
}
int minz, maxz;
if (abs(center_z1 - center_z2) <= string_to_number(locs[20]))
{
minz = floor((center_z1 + center_z2) * 0.5);
maxz = ceiling((center_z1 + center_z2) * 0.5);
}
else if (center_z1 > center_z2)
{
minz = string_to_number(locs[14]);
maxz = string_to_number(locs[4]);
}
else
{
minz = string_to_number(locs[5]);
maxz = string_to_number(locs[13]);
}
m.add_item_tts("열기 및 닫기", minx + colon + maxx + colon + miny + colon + maxy + colon + minz + colon + maxz);
m.add_item_tts("열기", int(center_x1) + colon + int(center_x1) + colon + int(center_y1) + colon + int(center_y1) + colon + int(center_z1) + colon + int(center_z1));
m.add_item_tts("닫기", int(center_x2) + colon + int(center_x2) + colon + int(center_y2) + colon + int(center_y2) + colon + int(center_z2) + colon + int(center_z2));
mres = m.run("스위치의 선택한 문에 대한 움직임을 선택하세요.", true);
if (mres <= 0) return empty;
ref_string = m.get_item_name(mres);
return ref_string;
}